#================
# FILE          : KIWISchema.rnc
#****************
# PROJECT       : OpenSUSE Build-Service
# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH, Germany
#               :
# AUTHOR        : Thomas Schraitle <toms@suse.de>
# AUTHOR        : Marcus Schaefer <ms@suse.de>
#               :
# BELONGS TO    : Operating System images
#               :
# DESCRIPTION   : This is the RELAX NG Schema for KIWI
#               : configuration files. The schema is maintained
#               : in the relax compact syntax. Any changes should
#               : made in !! *** KIWISchema.rnc *** !!
#               : 
#               :
# STATUS        : Development
#****************
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace xsi = "http://www.w3.org/2001/XMLSchema-instance"
datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"
namespace db  = "http://docbook.org/ns/docbook"

db:info [
	db:releaseinfo [
		"$Id: kiwi.rnc 2957 2008-01-11 12:53:39Z thomas-schraitle $"
	]
	db:releaseinfo [ "RNC Schema Version 5.3" ]
	db:pubdate [ "START" ]
	db:pubdate [ "2008-01-08" ]
]

image-name = xsd:token {pattern = "[a-zA-Z0-9_\-\.]+"}
locale-name = xsd:token {pattern = "[a-z]{2}_[A-Z]{2}(,[a-z]{2}_[A-Z]{2})*"}
mac-address-type = xsd:token {pattern = "([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}"}
size-type = xsd:token {pattern = "\d*|image"}
volume-size-type = xsd:token {pattern = "\d+|\d+M|\d+G|all"}

#==========================================
# start with image description
#
start =
	## The start pattern of an image
	k.image

#==========================================
# main block: <image>
#
div {
	k.image.name.attribute = k.imagename.attribute 
	k.image.displayname.attribute = k.displayname.attribute
	k.image.noNamespaceSchemaLocation.attribute =
		## The location of the XSD Schema (not relevant for RELAX NG or DTD)
		attribute xsi:noNamespaceSchemaLocation { xsd:anyURI }
	k.image.schemaLocation.attribute =
		## A pair of URI references: First is a namespace name,
		## second the location of the XSD Schema
		## (not relevant for RELAX NG or DTD)
		attribute xsi:schemaLocation { xsd:anyURI }
	k.image.schemaversion.attribute =
		## The allowed Schema version (fixed value)
		attribute schemaversion { "5.3" }
	k.image.kiwirevision.attribute =
		## A kiwi git revision number which is known to build
		## a working image from this description. If the kiwi git
		## revision is less than the specified value the
		## process will exit.
		attribute kiwirevision { xsd:nonNegativeInteger }
	k.image.id =
		## An identification number which is represented in a file
		## named /etc/ImageID
		attribute id { xsd:string {length="10"} }
	k.image.attlist = k.image.name.attribute 
		& k.image.displayname.attribute?
		& k.image.kiwirevision.attribute?
		& k.image.id?
		& k.image.schemaversion.attribute
		& ( k.image.noNamespaceSchemaLocation.attribute?
		  | k.image.schemaLocation.attribute? )?

	k.image =
		## The root element of the configuration file		
		[
		db:para [
			"Each KIWI configuration file consists of a root element\x{a}" ~
			"image."
		]
		]
		element image {
			k.image.attlist &
			k.description &
			k.preferences+ &
			k.profiles? &
			k.instsource? &
			k.users* &
			k.drivers* &
			k.strip* &
			k.repository+ &
			k.packages*
		}
}

#==========================================
# common attributes
#
k.id.attribute          =
	## An ID
	attribute id { xsd:ID }
k.name.attribute        =
	## A name
	attribute name { text }
k.replaces.attribute    =
	## Replace package with some other package
	attribute replaces { text }
k.bootinclude.attribute =
	## Indicates that this package should be part of
	## the boot image (initrd) too. This attribute
	## can be used to include for example branding packages
	## specified in the system image description to become
	## part of the boot image also
	attribute bootinclude { xsd:boolean }
k.bootdelete.attribute =
	## Indicates that this package should be removed from
	## the boot image (initrd). the attribute is only
	## evaluated if the bootinclude attribute is specified
	## along with it too
	attribute bootdelete { xsd:boolean }
k.displayname.attribute =
	## A friendly display name. Used in the boot menu
	## for isolinux and grub
	attribute displayname { text }
k.arch.attribute        =
	## An architecture
	attribute arch { text }
k.description.attribute =
	## A short description
	attribute description { text }
k.path.attribute        =
	## A path
	attribute path { text }
k.profiles.attribute    =
	## A profile name which binds the section to this name
	attribute profiles { text }
k.pwd.attribute         =
	## The password
	attribute pwd { text }
k.script.attribute      =
	## A script hook for meta files to be called after the
	## file was fetched
	attribute script { text }
k.source.attribute      =
	## A location where packages can be found to build an
	## installation source from
	attribute source { text }
k.size.attribute        =
	## A partition size or optional image size
	attribute size { size-type }
k.dest.attribute        =
	## Destination of a resource
	attribute dest { text }
k.username.attribute    =
	## A name of a user
	attribute username { text }
k.imagename.attribute   =
	## An image name without / and spaces
	attribute name { image-name }

#==========================================
# common element <author>
#
div {
	k.author.attlist = empty
	k.author =
		## Author of the image
		element author { k.author.attlist, text }
}

#==========================================
# common element <configuration>
#
div {
	k.configuration.source.attribute = k.source.attribute
	k.configuration.dest.attribute = k.dest.attribute
	k.configuration.arch.attribute = k.arch.attribute
	k.configuration.attlist = 
		k.configuration.source.attribute &
		k.configuration.dest.attribute &
		k.configuration.arch.attribute?

	k.configuration =
		## Specifies Configuration files
		[
		db:para [
			"As part of the network deploy configuration this section\x{a}" ~
			"specifies the configuration files which should be included\x{a}"~
			"into the image after deployment."
		]
		]
		element configuration {
			k.configuration.attlist,
			empty
		}
}

#==========================================
# common element <contact>
#
div {
	k.contact.attlist = empty
	k.contact = 
		## Contact Information from the Author, like Email etc.
		element contact {
			k.contact.attlist,
			text
		}
}

#==========================================
# common element <defaultdestination>
#
div {
	k.defaultdestination.attlist = empty
	k.defaultdestination =
		## Default Path if destdir Otion is Not Specified
		element defaultdestination {
			k.defaultdestination.attlist,
			text
		}
}

#==========================================
# common element <defaultroot>
#
div {
	k.defaultroot.attlist = empty
	k.defaultroot =
		## Default Root Directory Name if root Option is Not Specified
		element defaultroot {
			k.defaultroot.attlist,
			text
		}
}

#==========================================
# common element <ec2accountnr>
#
div {
	k.ec2accountnr.attlist = empty
	k.ec2accountnr =
		## The user's EC2 user ID (Note: AWS account number, NOT Access Key ID)
		element ec2accountnr {
			k.ec2accountnr.attlist,
			xsd:nonNegativeInteger
		}
}

#==========================================
# common element <ec2certfile>
#
div {
	k.ec2certfile.attlist = empty
	k.ec2certfile =
		## Path to the AWS user's PEM encoded RSA pubkey certificate file
		## cert-*.pem
		element ec2certfile {
			k.ec2certfile.attlist,
			text
		}
}

#==========================================
# common element <ec2privatekeyfile>
#
div {
	k.ec2privatekeyfile.attlist = empty
	k.ec2privatekeyfile =
		## Path to the AWS user's PEM encoded RSA private key file pk-*.pem
		element ec2privatekeyfile {
			k.ec2privatekeyfile.attlist,
			text
		}
}

#==========================================
# common element <ec2region>
#
div {
	k.ec2region.attlist = empty
	k.ec2region =
		## Specify the region/availability zone
		[
		db:para [
			"Specify the region/availability zone in EC2 for this image.\x{a}"~
			"Values are limited to the EC2 recognized zones:\x{a}"~
			"AP-Northeast, AP-Southeast, EU-West, SA-East, US-East, \x{a}"~
            "US-West, and US-West2"
		]
		]
		element ec2region {
			k.ec2region.attlist,
			text
		}
}

#==========================================
# common element <file>
#
div {
	k.file.name.attribute = k.name.attribute
	k.file.arch.attribute = k.arch.attribute
	k.file.attlist =
		k.file.name.attribute &
		k.file.arch.attribute?
	k.file =
		## A Pointer to a File
		element file {
			k.file.attlist,
			empty
		}
}

#==========================================
# common element <except>
#
div {
	k.except.name.attribute = k.name.attribute
	k.except.attlist =
		k.except.name.attribute
	k.except =
		## A Pointer to a File which should be excluded
		element except {
			k.except.attlist,
			empty
		}
}

#==========================================
# common element <ignore>
#
div {
	k.ignore.name.attribute = k.name.attribute
	k.ignore.attlist = k.ignore.name.attribute
	k.ignore = 
		## Ignores a Package
		element ignore {
			k.ignore.attlist,
			empty
		}
}

#==========================================
# common element <initrd>
#
div {
	k.initrd.attlist = empty
	k.initrd =
		## Specifies where the Boot Image can be Found
		[
		db:para [
			"As part of the network deploy configuration this element\x{a}"~
			"specifies where the boot image (initrd) can be found."
		]
		]
		element initrd {
			k.initrd.attlist,
			text
		}
}

#==========================================
# common element <instrepo>
#
div {
	#k.instrepo.name.attribute = k.id.attribute
	k.instrepo.name.attribute = 
		attribute name { xsd:ID }
	k.instrepo.priority.attribute =
		## Search priority for packages in this repo
		attribute priority { text }
	k.instrepo.username.attribute = k.username.attribute
	k.instrepo.pwd.attribute = k.pwd.attribute
	k.instrepo.local.attribute =
		attribute local { xsd:boolean }
	k.instrepo.attlist =
		k.instrepo.name.attribute &
		k.instrepo.priority.attribute &
		k.instrepo.username.attribute? &
		k.instrepo.pwd.attribute? &
		k.instrepo.local.attribute?
	k.instrepo =
		## Name of a Installation Repository
		[
		db:para [
			"Name of a repository which is used to create an\x{a}" ~
			"installation source\x{a}"~
			"The Priority specifies the order the repositories are\x{a}"~
			"layered when looking for a package.\x{a}"~
			"Username and pwd are the credentials for ftp access.\x{a}"~
			"The local attribute tells kiwi to use hardlinks instead of\x{a}"~
			"downloads in case the source and destination trees are on\x{a}"~
			"the same machine."
		]
		]
		element instrepo {
			k.instrepo.attlist,
			k.source
		}
}

#==========================================
# common element <kernel>
#
div {
	k.kernel.attlist = empty
	k.kernel =
		## Specifies Where to Find the Boot Kernel
		[
		db:para [
			"As part of the network deploy configuration this section\x{a}" ~
			"specifies the where to find the boot kernel."
		]
		]
		element kernel {
			k.kernel.attlist,
			text
		}
}

#==========================================
# common element <keytable>
#
div {
	k.keytable.attlist = empty
	k.keytable =
		## Image keytable setup.
		[
		db:para [
			"The value will be part of /etc/sysconfig/keyboard"
		]
		]
		element keytable {
			k.keytable.attlist,
			text
		}
}

#==========================================
# common element <locale>
#
div { # locale
	k.locale.attlist = empty
	k.locale =
		## Image locale setup.
		[
		db:para [
			"The value will be part of /etc/sysconfig/keyboard"
		]
		]
		element locale {
			k.locale.attlist,
			locale-name
		}
}

#==========================================
# common element <boot-theme>
#
div { # boot-theme
	k.boot-theme.attlist = empty
	k.boot-theme =
		## Image bootsplash/gfxboot theme setup.
		[
		db:para [
			"The value will be part used in suseGFXBoot"
		]
		]
		element boot-theme {
			k.boot-theme.attlist,
			text
		}
}

#==========================================
# common element <metadata>
#
div {
	k.metadata.attlist = empty
	k.metadata =
		## Contains Metadata
		[
		db:para [
			"When building an installation source not only packages are\x{a}" ~
			"relevant but also metadata. metadata are files or packages\x{a}"~
			"combined with script calls. If a package is specified as\x{a}"~
			"metadata it will not be installed by rpm but its cpio\x{a}"~
			"archive is extracted in a specific way."		    
		]
		]
		element metadata {
			k.metadata.attlist &
			k.repopackage* &
			k.metafile* &
			k.chroot*
		}
}

#==========================================
# common element <metafile>
#
div {
	k.metafile.url.attribute =
		## URL where to find the metafile
		attribute url { text }
	k.metafile.script.attribute = k.script.attribute
	k.metafile.target.attribute =
		## Destination path where to download the file
		attribute target { text }
	k.metafile.attlist =
		k.metafile.url.attribute &
		k.metafile.script.attribute &
		k.metafile.target.attribute
	k.metafile =
		## A file Pointer Optionally Bundled With a Script
		element metafile {
			k.metafile.attlist,
			empty
		}
}

#==========================================
# common element <opensusePattern>
#
div {
	k.opensusepattern.name.attribute = k.name.attribute
	k.opensusepattern.arch.attribute = k.arch.attribute
	k.opensusepattern.attlist =
		k.opensusepattern.name.attribute &
		k.opensusepattern.arch.attribute?
	k.opensusepattern =
		## Name of a Pattern From openSUSE
		element opensusePattern {
			k.opensusepattern.attlist,
			empty
		}
}

#==========================================
# common element <rhelGroup>
#
div {
	k.rhelgroup.name.attribute = k.name.attribute
	k.rhelgroup.arch.attribute = k.arch.attribute
	k.rhelgroup.attlist =
		k.rhelgroup.name.attribute &
		k.rhelgroup.arch.attribute?
	k.rhelgroup =
		## Name of RHEL package group 
		element rhelGroup {
			k.rhelgroup.attlist,
			empty
		}
}

#==========================================
# common element <opensuseProduct>
#
div {
	k.opensuseproduct.name.attribute = k.name.attribute
	k.opensuseproduct.arch.attribute = k.arch.attribute
	k.opensuseproduct.attlist =
		k.opensuseproduct.name.attribute &
		k.opensuseproduct.arch.attribute?
	k.opensuseproduct =
		## Name of a Product From openSUSE
		element opensuseProduct {
			k.opensuseproduct.attlist,
			empty
		}
}

#==========================================
# common element <repopackage>
#
div {
	k.repopackage.name.attribute = k.name.attribute
	k.repopackage.arch.attribute = k.arch.attribute
	k.repopackage.forcerepo.attribute =
		## Specifies the search priority
		attribute forcerepo { xsd:IDREF }
	k.repopackage.addarch.attribute =
		## Specifies that this package should
		## additionally add the same package from the given arch
		attribute addarch { text }
	k.repopackage.removearch.attribute =
		## Specifies that the package with the
		## given arch should be removed
		attribute removearch { text }
	k.repopackage.onlyarch.attribute =
		## Specifies that the package with
		## the given arch should be used in any case
		attribute onlyarch { text }
	k.repopackage.version.attribute =
		## Specifies that the package with
		## the given version[-release] should be used
		attribute version { text }
	k.repopackage.medium.attribute =
		## Specifies that the package will be put
		## to the specific medium number (CD1, DVD7, ...)
		attribute medium { xsd:nonNegativeInteger }
	k.repopackage.source.attribute = k.source.attribute
	k.repopackage.script.attribute = k.script.attribute
	k.repopackage.attlist =
		k.repopackage.name.attribute & 
		k.repopackage.arch.attribute? &
		k.repopackage.forcerepo.attribute? &
		k.repopackage.addarch.attribute? &
		k.repopackage.removearch.attribute? &
		k.repopackage.onlyarch.attribute? &
		k.repopackage.version.attribute? &
		k.repopackage.source.attribute? &
		k.repopackage.script.attribute? &
		k.repopackage.medium.attribute?
	k.repopackage =
		## Name of an instsource Package
		element repopackage {
			k.repopackage.attlist,
			empty
		}
}

#==========================================
# common element <package>
#
div {
	k.package.name.attribute = k.name.attribute
	k.package.arch.attribute = k.arch.attribute
	k.package.replaces.attribute = k.replaces.attribute
	k.package.bootinclude.attribute = k.bootinclude.attribute
	k.package.bootdelete.attribute = k.bootdelete.attribute
	k.package.attlist =
		k.package.name.attribute &
		k.package.arch.attribute? &
		k.replaces.attribute? &
		k.bootdelete.attribute? &
		k.bootinclude.attribute?
	k.package =
		## Name of an image Package
		element package {
			k.package.attlist,
			empty
		}
}

#==========================================
# common element <archive>
#
div {
	k.archive.name.attribute = k.name.attribute
	k.archive.bootinclude.attribute = k.bootinclude.attribute
	k.archive.attlist =
		k.archive.name.attribute &
		k.archive.bootinclude.attribute?
	k.archive =
		## Name of an image archive file (tarball)
		element archive {
			k.archive.attlist,
			empty
		}
}

#==========================================
# common element <packagemanager>
#
div {
	k.packagemanager.content = "smart" | "zypper" | "ensconce" | "yum"
	k.packagemanager.attlist = empty
	k.packagemanager =
		## Name of the Package Manager
		[
		db:para [
			"The package manager used for package installation\x{a}"~
			"could be either zypper or smart"
		]
		]
		element packagemanager {
			k.packagemanager.attlist,
			k.packagemanager.content
		}
}

#==========================================
# common element <partitions>
#
div {
	k.partitions.device.attribute =
		## As part of the network deploy configuration this section
		## specifies the disk device name
		attribute device { text }
	k.partitions.attlist = k.partitions.device.attribute?
	k.partitions =
		## A List of Partitions
		element partitions { 
			k.partitions.attlist, 
			k.partition+
		}
}

#==========================================
# common element <partition>
#
div {
	k.partition.type.attribute =
		## Partition Type identifier, see parted for details
		attribute type { text }
	k.partition.number.attribute =
		## Partition ID
		attribute number { text }
	k.partition.size.attribute = k.size.attribute
	k.partition.mountpoint.attribute = 
		## Mount path for this partition
		attribute mountpoint { text }
	k.partition.target.attribute =
		## Is a real target or not which means is part of
		## the /etc/fstab file or not
		attribute target { xsd:boolean }
	k.partition.attlist =
		k.partition.type.attribute &
		k.partition.number.attribute & 
		k.partition.size.attribute? &
		k.partition.mountpoint.attribute? &
		k.partition.target.attribute?
	k.partition =
		## A Partition
		element partition {
			k.partition.attlist,
			empty
		}
}

#==========================================
# common element <persistent>
#
div {
	k.persistent.attlist = empty
	k.persistent =
		## Specifies Filenames in the Read-Write Disk Area
		[
		db:para [
			"As part of the split section the persistent element\x{a}"~
			"specifies filenames which are in the read-write disk area"
		]
		]
		element persistent {
			k.persistent.attlist &
			k.except* &
			k.file+
		}
}

#==========================================
# common element <profile>
#
div {
	k.profile.name.attribute = k.name.attribute
	k.profile.description.attribute =
		## Description of how this profiles influences the image
		attribute description { text }
	k.profile.import.attribute =
		## Import profile by default if no profile was set on
		## the command line
		attribute import { xsd:boolean }
	k.profile.attlist =
		k.profile.name.attribute &
		k.profile.description.attribute &
		k.profile.import.attribute?
	k.profile =
		## Creates Profiles
		[
		db:para [
			"Profiles creates a namespace on an image description and\x{a}"~
			"thus can be used to have one description with different\x{a}"~
			"profiles for example KDE and GNOME including different\x{a}"~
			"packages."
		]
		]
		element profile {
			k.profile.attlist,
			empty
		}
}

#==========================================
# common element <repository>
#
div {
	k.repository.profiles.attribute = k.profiles.attribute
	k.repository.type.attribute =
	  ## Type of repository
	  attribute type {
		"apt-deb" | "apt-rpm" | "deb-dir" | "mirrors" | "red-carpet" |
		"rpm-dir" | "rpm-md"  | "slack-site" | "up2date-mirrors" | "urpmi" |
		"yast2"
	}
	k.repository.status.attribute =
		## Specifies the status of the repository. This can be
		## replacable or if not specified it's a must have repository
		attribute status {  "fixed" | "replaceable" }
	k.repository.alias.attribute =
		## Alias name to be used for this repository. This is an
		## optional free form text. If not set the source attribute
		## value is used and builds the alias name by replacing
		## each '/' with a '_'. An alias name should be set if the
		## source argument doesn't really explain what this repository
		## contains
		attribute alias { text }
    k.repository.imageinclude.attribute =
        ## Specify whether or not this repository should be configured in the
        ## resulting image. Boolean value true or false, the default is false.
        attribute imageinclude { xsd:boolean }
	k.repository.prefer-license.attribute =
		attribute prefer-license { xsd:boolean }
	k.repository.priority.attribute =
		## Channel priority assigned to all packages available in
		## this channel (0 if not set). If the exact same package
		## is available in more than one channel, the highest
		## priority is used
		attribute priority { xsd:integer }
	k.repository.password.attribute =
		## Channel password if required. It depends on the url type
		## whether and how this information is passed
		attribute password { text }
	k.repository.username.attribute =
		## Channel username if required. It depends on the url type
		## whether and how this information is passed
		attribute username { text }
	k.repository.attlist =
		k.repository.type.attribute &
		k.repository.profiles.attribute? &
		k.repository.status.attribute? &
		k.repository.alias.attribute? &
        k.repository.imageinclude.attribute? &
		k.repository.prefer-license.attribute? &
		k.repository.priority.attribute? &
		k.repository.password.attribute? &
		k.repository.username.attribute?
	k.repository =
		## The Name of the Repository
		element repository {
			k.repository.attlist,
			k.source
		}
}

#==========================================
# common element <rpm-check-signatures>
#
div {
	k.rpm-check-signatures.content = xsd:boolean
	k.rpm-check-signatures.attlist = empty
	k.rpm-check-signatures =
		## Setup a Package Signature
		[
		db:para [
			"Setup if the package manager should check the package\x{a}"~
			"signature or not. This option could be ignored according\x{a}"~
			"to the used package manager."
		]
		]
		element rpm-check-signatures {
			k.rpm-check-signatures.attlist,
			k.rpm-check-signatures.content
		}
}

#==========================================
# common element <rpm-excludedocs>
#
div {
	k.rpm-excludedocs.content = xsd:boolean
	k.rpm-excludedocs.attlist = empty
	k.rpm-excludedocs =
		## Do not install files marked as documentation in the package
		[
		db:para [
			"Setup if the package manager should exclude docs files\x{a}"~
			"during package installation. This option could be ignored\x{a}"~
			"according to the used package manager."
		]
		]
		element rpm-excludedocs {
			k.rpm-excludedocs.attlist,
			k.rpm-excludedocs.content
		}
}

#==========================================
# common element <rpm-force>
#
div {
	k.rpm-force.content = xsd:boolean
	k.rpm-force.attlist = empty
	k.rpm-force =
		## Force the Installation of a Package
		[
		db:para [
			"Setup if the package manager should force the install of the\x{a}"~
			"package or not. This option could be ignored according\x{a}"~
			"to the used package manager."
		]
		]
		element rpm-force {
			k.rpm-force.attlist,
			k.rpm-force.content
		}
}

#==========================================
# common element <oem-align-partition>
#
div {
	k.oem-align-partition.content = xsd:boolean
	k.oem-align-partition.attlist = empty
	k.oem-align-partition =
		## For oemboot driven images: align start sectors.
		## For parted the option -a is passed
		[
		db:para [
			"For oemboot driven images: align start sectors.\x{a}"~
			"For parted the option -a is passed."
		]
		]
		element oem-align-partition {
			k.oem-align-partition.attlist,
			k.oem-align-partition.content
		}
}

#==========================================
# common element <oem-boot-title>
#
div {
	k.oem-boot-title.attlist = empty
	k.oem-boot-title =
		## For oemboot driven images: setup of the boot menu text
		## displayed within the square brackets after first reboot
		## of the OEM image
		[
		db:para [
			"For oemboot driven images: setup of the boot menu text\x{a}"~
			"displayed within the square brackets after first reboot\x{a}"~
			"of the OEM image."
		]
		]
		element oem-boot-title {
			k.oem-boot-title.attlist,
			text
		}
}

#==========================================
# common element <oem-bootwait>
#
div {
	k.oem-bootwait.content = xsd:boolean
	k.oem-bootwait.attlist = empty
	k.oem-bootwait =
		## For oemboot driven images: halt system after image dump true/false
		[
		db:para [
			"For oemboot driven images: wait for user acknowledgement "~
			"after first deployment true/false. A message to be "~
			"acknowledged by the user is posted after the image has been "~
			"dumped (installed) on the target disk. After user interaction "~
			"the system reboots (softboot)."
		]
		]
		element oem-bootwait {
			k.oem-bootwait.attlist,
			k.oem-bootwait.content
		}
}

#==========================================
# common element <oem-inplace-recovery>
#
div {
	k.oem-inplace-recovery.content = xsd:boolean
	k.oem-inplace-recovery.attlist = empty
	k.oem-inplace-recovery =
		## For oemboot driven images: Specify whether the
		## recovery archive should be stored as part of the image
		## or not. If it's not stored it's created during install
		## of the oem image
		[
		db:para [
			"For oemboot driven images: Specify whether the\x{a}"~
			"recovery archive should be stored as part of the image\x{a}"~
			"or not. If it's not stored it's created during install\x{a}"~
			"of the oem image"
		]
		]
		element oem-inplace-recovery {
			k.oem-inplace-recovery.attlist,
			k.oem-inplace-recovery.content
		}
}

#==========================================
# common element <oem-kiwi-initrd>
#
div {
	k.oem-kiwi-initrd.content = xsd:boolean
	k.oem-kiwi-initrd.attlist = empty
	k.oem-kiwi-initrd =
		## For oemboot driven images: use kiwi initrd in any case
		## and don't replace it with mkinitrd created initrd
		[
		db:para [
			"For oemboot driven images: use kiwi initrd in any case\x{a}"~
            "and don't replace it with mkinitrd created initrd"
		]
		]
		element oem-kiwi-initrd {
			k.oem-kiwi-initrd.attlist,
			k.oem-kiwi-initrd.content
		}
}

#==========================================
# common element <oem-partition-install>
#
div {
	k.oem-partition-install.content = xsd:boolean
	k.oem-partition-install.attlist = empty
	k.oem-partition-install =
		## For oemboot driven images: install the system not as
		## disk but into a free partition. If this option is set
		## all other oem-* options concerning the partition table
		## will not have any effect
		[
		db:para [
			"For oemboot driven images: install the system not as\x{a}"~
			"disk but into a free partition. If this option is set\x{a}"~
			"all other oem-* options concerning the partition table\x{a}"~
			"will not have any effect"
		]
		]
		element oem-partition-install {
			k.oem-partition-install.attlist,
			k.oem-partition-install.content
		}
}

#==========================================
# common element <oem-reboot>
#
div {
	k.oem-reboot.content = xsd:boolean
	k.oem-reboot.attlist = empty
	k.oem-reboot =
		## For oemboot driven images: reboot after first deployment true/false
		[
		db:para [
			"For oemboot driven images: reboot after first deployment "~
			"true/false. The system is rebooted in similar fashion to "~
			"shutdown -r after the image has been dumped (installed) "~
			"and expanded on the target disk."
		]
		]
		element oem-reboot {
			k.oem-reboot.attlist,
			k.oem-reboot.content
		}
}

#==========================================
# common element <oem-reboot-interactive>
#
div {
	k.oem-reboot-interactive.content = xsd:boolean
	k.oem-reboot-interactive.attlist = empty
	k.oem-reboot-interactive =
		## For oemboot driven images: reboot after first deployment true/false
		[
		db:para [
			"For oemboot driven images: reboot after first deployment "~
			"true/false. A message to be acknowledged by the user is "~
			"posted after the image has been dumped (installed) and "~
			"expanded on the target disk. After user interaction the "~
			"system is rebooted in similar fashion to shutdown -r."
		]
		]
		element oem-reboot-interactive {
			k.oem-reboot-interactive.attlist,
			k.oem-reboot-interactive.content
		}
}

#==========================================
# common element <oem-recovery>
#
div {
	k.oem-recovery.content = xsd:boolean
	k.oem-recovery.attlist = empty
	k.oem-recovery =
		## For oemboot driven images: create a recovery archive yes/no
		[
		db:para [
			"For oemboot driven images: create a recovery archive yes/no"
		]
		]
		element oem-recovery {
			k.oem-recovery.attlist,
			k.oem-recovery.content
		}
}

#==========================================
# common element <oem-recoveryID>
#
div {
	k.oem-recoveryID.attlist = empty
	k.oem-recoveryID =
		## For oemboot driven images: Set the partition ID of
		## recovery partition. Default value is 83 (Linux)
		[
		db:para [
			"For oemboot driven images: Set the partition ID of\x{a}"~
			"recovery partition. Default value is 83 (Linux)"
		]
		]
		element oem-recoveryID {
			k.oem-recoveryID.attlist,
			xsd:nonNegativeInteger
		}
}

#==========================================
# common element <oem-silent-boot>
#
div {
	k.oem-silent-boot.content = xsd:boolean
	k.oem-silent-boot.attlist = empty
	k.oem-silent-boot =
		## For oemboot driven images: boot silently during the initial boot
		## true/false
    	[
        db:para [
			"For oemboot driven images: complete the initial boot of the "~
			"system in silent mode, true/false. "
		]
		]
    	element oem-silent-boot {
			k.oem-silent-boot.attlist,
			k.oem-silent-boot.content
		}
}

#==========================================
# common element <oem-shutdown>
#
div {
	k.oem-shutdown.content = xsd:boolean
	k.oem-shutdown.attlist = empty
	k.oem-shutdown =
		## For oemboot driven images: shutdown after first deployment 
		## true/false
		[
		db:para [
			"For oemboot driven images: shutdown after first deployment "~
			"true/false. The system is powered down after the image has "~
			"been dumped (installed) and expanded on the target disk. "
		]
		]
		element oem-shutdown {
			k.oem-shutdown.attlist,
			k.oem-shutdown.content
		}
}

#==========================================
# common element <oem-shutdown-interactive>
#
div {
	k.oem-shutdown-interactive.content = xsd:boolean
	k.oem-shutdown-interactive.attlist = empty
	k.oem-shutdown-interactive =
		## For oemboot driven images: shutdown after first deployment 
		## true/false
		[
		db:para [
			"For oemboot driven images: shutdown after first deployment "~
			"true/false. A message to be acknowledged by the user is posted "~
			"after the image has been dumped (installed) and expanded on "~
			"the target disk. After user interaction the system is shutdown."
		]
		]
		element oem-shutdown-interactive {
			k.oem-shutdown-interactive.attlist,
			k.oem-shutdown-interactive.content
		}
}

#==========================================
# common element <oem-swap>
#
div {
	k.oem-swap.content = xsd:boolean
	k.oem-swap.attlist = empty
	k.oem-swap =
		## For oemboot driven images: use a swap partition yes/no
		[
		db:para [
			"For oemboot driven images: use a swap partition yes/no."
		]
		]
		element oem-swap {
			k.oem-swap.attlist,
			k.oem-swap.content
		}
}

#==========================================
# common element <oem-swapsize>
#
div {
	k.oem-swapsize.attlist = empty
	k.oem-swapsize =
		## For oemboot driven images: Set the size of the swap
		## partition in MB
		[
		db:para [
			"For oemboot driven images: Set the size of the swap\x{a}"~
			"partition in MB. No swapspace with oem-swap set to false."
		]
		]
		element oem-swapsize {
			k.oem-swapsize.attlist,
			xsd:nonNegativeInteger
		}
}

#==========================================
# common element <oem-systemsize>
#
div {
	k.oem-systemsize.attlist = empty
	k.oem-systemsize =
		## For oemboot driven images: Set the size of the system
		## (root) partition in MB
		[
		db:para [
			"For oemboot driven images: Set the size of the system\x{a}"~
			"(root) partition in MB."
		]
		]
		element oem-systemsize {
			k.oem-systemsize.attlist,
			xsd:nonNegativeInteger
		}
}

#==========================================
# common element <oem-unattended>
#
div {
	k.oem-unattended.content = xsd:boolean
	k.oem-unattended.attlist = empty
	k.oem-unattended =
		## For oemboot driven images: don't ask questions if possible
		## true/false
		[
		db:para [
			"For oemboot driven images: don't ask questions if"~
            "possible true/false"
		]
		]
		element oem-unattended {
			k.oem-unattended.attlist,
			k.oem-unattended.content
		}
}

#==========================================
# common element <oem-unattended-id>
#
div {
	k.oem-unattended-id.attlist = empty
	k.oem-unattended-id =
		## For oemboot driven images: use the specified disk id
		## the id corresponds with the value of devicepersistency
		## or by default with /dev/disk/by-id/...
		[
		db:para [
			"For oemboot driven images: use the specified disk id"
            "the id corresponds with the value of devicepersistency"
			"or by default with /dev/disk/by-id/..."
		]
		]
		element oem-unattended-id {
			k.oem-unattended-id.attlist,
			text
		}
}

#==========================================
# common element <size>
#
div {
	k.size.unit.attribute =
		## The unit of the image
		attribute unit { "M" | "G" }
	k.size.additive.attribute =
		attribute additive { xsd:boolean }
	k.size.attlist =
		k.size.unit.attribute? &
		k.size.additive.attribute?
	k.size =
		## Specifies the Size of an Image in (M)egabyte or (G)igabyte
		## If the attribute additive is set the value will be added
		## to the required size of the image
		element size {
			k.size.attlist,
			xsd:nonNegativeInteger
		}
}

#==========================================
# common element <source>
#
div {
	k.source.path.attribute = k.path.attribute
	k.source.attlist = k.source.path.attribute
	k.source =
		## A Pointer to a Repository/Package Source
		element source {
			k.source.attlist,
			empty
		}
}

#==========================================
# common element <specification>
#
div {
	k.specification.attlist = empty
	k.specification =
		## A Detailed Description
		[
		db:para [
			"A detailed description of this image and what it can be\x{a}"~
			"used for."
		]
		]
		element specification {
			k.specification.attlist,
			text
		}
}

#==========================================
# common element <temporary>
#
div {
	k.temporary.attlist = empty
	k.temporary =
		## Specifies Files in RAM
		[
		db:para [
			"As part of the split section the temporary element\x{a}"~
			"specifies file names which are in the RAM disk area."
		]
		]
		element temporary {
			k.temporary.attlist &
			k.except* &
			k.file+
		}
}

#==========================================
# common element <timeout>
#
div {
	k.timeout.attlist = empty
	k.timeout = 
		## Specifies an ATFTP Download Timeout
		[
		db:para [
			"As part of the network deploy configuration this section \x{a}"~
			"specifies an ATFTP download timeout"
		]
		]
		element timeout {
			k.timeout.attlist,
			text
		}
}

#==========================================
# common element <hwclock>
#
div {
	k.hwclock.content = "utc" | "localtime"
	k.hwclock.attlist = empty
	k.hwclock =
		## Setup Image harware clock setup, either utc or localtime
		[
		db:para [
			"Image hardware clock setup. The value can be either\x{a}"~
            "set to utc or localtime."
		]
		]
		element hwclock {
			k.hwclock.attlist,
			k.hwclock.content
		}
}

#==========================================
# common element <showlicense>
#
div {
	k.showlicense.attlist = empty
	k.showlicense =
		## Setup showlicense
		[
		db:para [
			"Image license setup. The specfied license name\x{a}"~
			"will be displayed in a dialog window on boot."
		]
		]
		element showlicense {
			k.showlicense.attlist,
			text
		}
}

#==========================================
# common element <timezone>
#
div {
	k.timezone.attlist = empty
	k.timezone =  
		## Setup Image Timezone setup
		[
		db:para [
			"Image timezone setup. The value will be used to search\x{a}"~
			"the correct timezone and copy it to /etc/localtime."
		]
		]
		element timezone {
			k.timezone.attlist,
			text
		}
}

#==========================================
# common element <type>
#
div {
	k.type.boot.attribute =
		## Specifies the path of the boot image (initrd), relative
		## to /usr/share/kiwi/image
		attribute boot { text }
	k.type.editbootconfig.attribute =
		## Specifies the path to a script which is called right
		## before the bootloader is installed. The script runs
		## relative to the directory which contains the image
		## structure
		attribute editbootconfig { text }
	k.type.bootkernel.attribute =
		## Specifies the kernel boot profile defined in the boot
		## image description. When kiwi builds the boot image the
		## information is passed as add-profile option
		attribute bootkernel { text }
	k.type.bootloader.attribute =
		## Specifies the bootloader used for booting the image."
		## At the moment grub, zipl and sys|extlinux are supported
		attribute bootloader {
			"extlinux" | "grub" | "grub2" | "syslinux" | "zipl" | "yaboot" | "uboot"
		}
	k.type.bootprofile.attribute =
		## Specifies the boot profile defined in the boot image
		## description. When kiwi builds the boot image the
		## information is passed as add-profile option
		attribute bootprofile { text }
	k.type.boottimeout.attribute =
		## Specifies the boot timeout in seconds prior to launching
		## the default boot option. the unit for the timeout value
		## is seconds if GRUB is used as the boot loader and 1/10
		## seconds if syslinux is used
		attribute boottimeout { xsd:nonNegativeInteger }
	k.type.checkprebuilt.attribute =
		## Activates whether KIWI should search for a prebuild boot
		## image or not
		attribute checkprebuilt { xsd:boolean }
	k.type.compressed.attribute =
		## Specifies whether the image output file should be
		## compressed or not. This makes only sense for filesystem
		## only images respectively for the pxe or cpio type
		attribute compressed { xsd:boolean }
	k.type.devicepersistency.attribute =
		## Specifies which method to use in order to get persistent
		## storage device names. By default by-id is used.
		attribute devicepersistency { "by-uuid" | "by-label" | "by-path" }
	k.type.filesystem.attribute = 
		## Specifies the filesystem which can be one of:
		## btrfs, clicfs, ext2, ext3, ext4, reiserfs, squashfs, or xfs
		## clicfs is a fuse based compressed filesystem using a cow
		## file for write operations
		attribute filesystem {
			"btrfs" | "clicfs" | "ext2" | "ext3" | "ext4" |
			"reiserfs" | "squashfs" | "xfs"
		}
	k.type.flags.attribute =
		## Specifies flags for the image type. This could be compressed
		## or clic and applies to the iso type only
		attribute flags {
			"clic" | "compressed"
		}
	k.type.format.attribute =
		## Specifies the format of the virtual disk.
		attribute format {
			"ec2" | "ovf" | "ova" | "qcow2" | "vmdk" | "vhd"
		}
	k.type.fsnocheck.attribute =
		## Turn off periodic filesystem checks on ext2/3/4.
		attribute fsnocheck { xsd:boolean }
	k.type.fsreadonly.attribute =
		## Specifies the filesystem for the read-only part of a split image
		attribute fsreadonly {
			"btrfs" | "ext2" | "ext3" | "ext4" |
			"reiserfs" | "squashfs" | "xfs"
		}
	k.type.fsreadwrite.attribute =
		## Specifies the filesystem for the read-write part of a split image
		attribute fsreadwrite {
			"btrfs" | "ext2" | "ext3" | "ext4" | "reiserfs" | "xfs"
		}
	k.type.hybrid.attribute =
		## for the iso type only:
		## Specifies that the iso file should be turned into
		## a hybrid iso file. It's required to use the vmxboot
		## boot image to boot that iso though
		attribute hybrid { xsd:boolean }
	k.type.hybridpersistent.attribute =
		## for the iso type only:
		## will trigger the creation of a partition for a COW file
		## to keep data persistent over a reboot
		attribute hybridpersistent { xsd:boolean }
	k.type.ramonly.attribute =
		## for use with overlay filesystems only:
		## will force any COW action to happen in RAM
		attribute ramonly { xsd:boolean }
	k.type.image.attribute =
		## Specifies the image type
		attribute image {
			"btrfs" | "clicfs" | "cpio" | "ext2" | "ext3" |
			"ext4" | "iso" | "oem" | "product" | "pxe" | "reiserfs" |
			"split" | "squashfs" | "tbz" | "vmx" | "xfs"
		}
	k.type.installboot.attribute =
		## Specifies the bootloader default boot entry for the"
		## initial boot of a kiwi install image. This value is"
		## only evaluated for grub and ext|syslinux"
		attribute installboot {
			"failsafe-install" | "harddisk" | "install"
		}
	k.type.installprovidefailsafe.attribute =
		## Specifies if the bootloader menu should provide an"
		## failsafe entry with special kernel parameters or not"
		attribute installprovidefailsafe { xsd:boolean }
	k.type.installiso.attribute =
		## Specifies if a install iso should be created (oem only)
		attribute installiso { xsd:boolean }
	k.type.installstick.attribute =
		## Specifies if a install stick should be created (oem only)
		attribute installstick { xsd:boolean }
	k.type.kernelcmdline.attribute =
		# The kernelcmdline element specifies additional
		# kernel command line options
		attribute kernelcmdline { text }
	k.type.luks.attribute =
		## Setup cryptographic volume along with the given filesystem
		## using the LUKS extension. The value of this attribute
		## represents the password string used to be able to
		## mount that filesystem while booting
		attribute luks { text }
	k.type.primary.attribute =
		## Specifies the primary type (choose KIWI option type)
		attribute primary { xsd:boolean }
	k.type.vga.attribute =
		## Specifies the kernel framebuffer mode. More information
		## about the possible values can be found by calling
		## hwinfo --framebuffer or in /usr/src/linux/Documentation/fb/vesafb.txt
		attribute vga { text }
	k.type.volid.attribute =
		## for the iso type only:
		## Specifies the volume ID (volume name or label) to be written
		## into the master block. There is space for 32 characters.
		attribute volid { text }
	k.type.attlist =
		k.type.boot.attribute? &
		k.type.editbootconfig.attribute? &
		k.type.bootkernel.attribute? &
		k.type.bootloader.attribute? &
		k.type.bootprofile.attribute? &
		k.type.boottimeout.attribute? &
		k.type.checkprebuilt.attribute? &
		k.type.compressed.attribute? &
		k.type.devicepersistency.attribute? &
		k.type.filesystem.attribute? &
		k.type.flags.attribute? &
		k.type.format.attribute? &
		k.type.fsnocheck.attribute? &
		k.type.fsreadonly.attribute? &
		k.type.fsreadwrite.attribute? &
		k.type.hybrid.attribute? &
		k.type.hybridpersistent.attribute? &
		k.type.ramonly.attribute? &
		k.type.image.attribute &
		k.type.installboot.attribute? &
		k.type.installprovidefailsafe.attribute? &
		k.type.installiso.attribute? &
		k.type.installstick.attribute? &
		k.type.kernelcmdline.attribute? &
		k.type.luks.attribute? &
		k.type.primary.attribute? &
		k.type.vga.attribute? &
		k.type.volid.attribute?
	k.type =
		## The Image Type of the Logical Extend
		element type { 
			k.type.attlist &
            k.ec2config? &
			k.machine? &
			k.oemconfig? &
			k.pxedeploy? &
			k.size? &
			k.split? &
			k.systemdisk?
		}
}

#==========================================
# common element <volume>
#
div {
	k.volume.freespace.attribute =
		## free space to be added to this volume. The value is
		## used as MB by default but you can add "M" and/or "G" as
		## postfix
		attribute freespace { volume-size-type }
	k.volume.name.attribute =
		## volume name. The name specifies a path which has to
		## exist inside the root directory.
		attribute name { text }
	k.volume.size.attribute =
		## absolute size of the volume. If the size value
		## is too small to store all data it will be ignored.
		## The value is used as MB by default but you can
		## add "M" and/or "G" as postfix
		attribute size { volume-size-type }
	k.volume.attlist =
		k.volume.freespace.attribute? &
		k.volume.name.attribute &
		k.volume.size.attribute?
	k.volume =
		## Specify which parts of the filesystem should be
		## on an extra volume.
		[
		db:para [
			"Specify which parts of the filesystem should be on\x{a}"
			"an extra volume."
		]
		]
		element volume {
			k.volume.attlist,
			empty
		}
}


#==========================================
# common element <systemdisk>
#
div {
	k.systemdisk.lvmgroup.attribute =
		## Specify Volume group name, default is kiwiVG.
		attribute name { text }
    k.systemdisk.attlist =
		k.systemdisk.lvmgroup.attribute?

	k.systemdisk =
		## Specify LVM volumes other than the root volume
		[
		db:para [
			"Specify LVM volumes other than the root volume."
		]
		]
		element systemdisk {
			k.systemdisk.attlist &
			k.volume*
		}
}

#==========================================
# common element <union>
#
div {
	k.union.ro.attribute =
		## Device only for read-only 
		attribute ro { text }
	k.union.rw.attribute =
		## Device for Read-Write
		attribute rw { text }
	k.union.type.attribute = attribute type { "clicfs" }
	k.union.attlist =
		k.union.ro.attribute &
		k.union.rw.attribute &
		k.union.type.attribute
	
	k.union =  
		## Specifies the Overlay Filesystem
		[
		db:para [
			"As part of the network deploy configuration this section\x{a}"~
			"specifies the overlay filesystem setup if required by the\x{a}"~
			"filesystem type of the system image.An overlay setup is only\x{a}"~
			"required if the system image uses a squashfs\x{a}"~
			"compressed filesystem."
		]
		]
		element union {
			k.union.attlist,
			empty
		}
}

#==========================================
# common element <user>
#
div {
	k.user.name.attribute = k.name.attribute
	k.user.id.attribute = 
		## The user ID for this user
		attribute id { xsd:nonNegativeInteger }
	k.user.realname.attribute =
		## The name of an user
		attribute realname { text }
	k.user.pwd.attribute = k.pwd.attribute
	k.user.pwdformat =
		## Format of the given password, encrypted is the default
		attribute pwdformat { "encrypted" | "plain" }
	k.user.home.attribute =
		## The home directory for this user
		attribute home { text }
	k.user.shell.attribute =
		## The shell for this user
		attribute shell { text }
	k.user.attlist =
		k.user.home.attribute &
		k.user.id.attribute? &
		k.user.name.attribute &
		k.user.pwd.attribute? &
		k.user.pwdformat? &
		k.user.realname.attribute? &
		k.user.shell.attribute?
	k.user =
		## A User with Name, Password, Path to Its Home And Shell
		element user {
			k.user.attlist &
			empty
		}
}

#==========================================
# common element <version>
#
div {
	k.version.attlist = empty
	k.version =
		## A Version Number for the Image, Consists of Major.Minor.Release 
		element version {
			k.version.attlist &
            text
		}
}

#==========================================
# common element <vmconfig-entry>
#
div {
	k.vmconfig-entry.attlist = empty
	k.vmconfig-entry =
		## An entry for the VM configuration file
		element vmconfig-entry {
			k.vmconfig-entry.attlist &
			text
		}
}

#==========================================
# common element <vmdisk>
#
div {
	k.vmdisk.disktype.attribute =
		## The type of the disk as it is internally handled by the VM
		attribute disktype { text }
	k.vmdisk.controller.attribute =
		## The disk controller used for the VM guest
		attribute controller { "ide" | "scsi" }
	k.vmdisk.id.attribute =
		## The disk ID / device for the VM disk
		attribute id { xsd:nonNegativeInteger }
	k.vmdisk.device.attribute =
		## The disk device to appear in the guest (xen only)
		attribute device { text }
	k.vmdisk.attlist =
		k.vmdisk.disktype.attribute? &
		k.vmdisk.controller.attribute &
		k.vmdisk.id.attribute &
		k.vmdisk.device.attribute?
	k.vmdisk =
		## The VM disk definition.
		element vmdisk {
			k.vmdisk.attlist &
			empty
		}
}

#==========================================
# common element <vmdvd>
#
div {
	k.vmdvd.controller.attribute =
		## The CD/DVD controller used for the VM guest
		attribute controller { "ide" | "scsi" }
	k.vmdvd.id.attribute =
		## The CD/DVD ID for the VM CD rom drive
		attribute id { xsd:nonNegativeInteger }
	k.vmdvd.attlist =
		k.vmdvd.controller.attribute &
		k.vmdvd.id.attribute
	k.vmdvd =
		## The VM CD/DVD drive definition. You can setup either a
		## scsi CD or an ide CD drive
		element vmdvd {
			k.vmdvd.attlist &
			empty
		}
}

#==========================================
# common element <vmnic>
#
div {
	k.vmnic.driver.attribute =
		## The driver used for the VM network interface
		attribute driver { text }
	k.vmnic.interface.attribute =
		## The interface ID for the VM network interface
		attribute interface { text }
	k.vmnic.mode.attribute =
		## The VM network mode
		attribute mode { text }
	k.vmnic.mac.attribute =
		## The VM mac address
		attribute mac { mac-address-type }
	k.vmnic.attlist =
		k.vmnic.driver.attribute? &
		k.vmnic.interface.attribute &
		k.vmnic.mode.attribute? &
		k.vmnic.mac.attribute?
	k.vmnic =
		## The VM network interface definition
		element vmnic {
			k.vmnic.attlist &
			empty
		}
}

#==========================================
# main block: <pxedeploy>
#
div {
	k.pxedeploy.server.attribute =
		## Name or IP Address of server for downloading the data
		attribute server { text }
	k.pxedeploy.blocksize.attribute = 
		## Blocksize value used for atftp downloads
		attribute blocksize { xsd:nonNegativeInteger }
	k.pxedeploy.attlist =
		k.pxedeploy.server.attribute? &
		k.pxedeploy.blocksize.attribute?
	k.pxedeploy =
		## Controls the Image Deploy Process
		[
		db:para [
			"The deploy section is used to allow kiwi to create the\x{a}"~
			"config.<MAC> file required by PXE based network images.\x{a}"~
			"the contents of this file controls the image deploy process."
		]
		]
		element pxedeploy {
			k.pxedeploy.attlist &
			k.timeout? &
			k.kernel? &
			k.initrd? &
			k.partitions? &
			k.union? &
			k.configuration*
		}
}

#==========================================
# main block: <description>
#
div {
	k.description.type.attribute = 
		## Kiwi distinguishes between two basic image description types
		## which uses the same format but one is created and provided by
		## the kiwi developers and the other is created by the users of
		## kiwi. The type=boot specifies a boot image (initrd) which should
		## be provided by the kiwi developers wheras type=system specifies
		## a standard image description created by a kiwi user.
		attribute type { "boot" | "system" }
	k.description.attlist = k.description.type.attribute
	k.description =  
		## A Short Description
		element description {
			k.description.attlist &
			k.author &
			k.contact+ &
			k.specification
		}
}

#==========================================
# main block: <drivers>
#
div {
	k.drivers.type.attribute = attribute type {
		"drivers" | "netdrivers" | "scsidrivers" | "usbdrivers"
	}
	k.drivers.profiles.attribute = k.profiles.attribute
	k.drivers.attlist = 
		k.drivers.type.attribute &
		k.drivers.profiles.attribute?
		
	k.drivers =
		## A Collection of Driver Files 
		element drivers {
			k.drivers.attlist &
			k.file+
		}
}

#==========================================
# main block: <strip>
#
div {
	k.strip.type.attribute = attribute type {
		"delete" | "tools" | "libs"
	}
	k.strip.profiles.attribute = k.profiles.attribute
	k.strip.attlist =
		k.strip.type.attribute &
		k.strip.profiles.attribute?
	k.strip =
		## A Collection of files to strip
		element strip {
			k.strip.attlist &
			k.file+
		}
}

#==========================================
# main block: <instsource>
#
div {
	k.instsource.attlist = empty
	k.instsource =
		## Describe Packages and Metadata
		[
		db:para [
			"The instsource element is used to describe the packages\x{a}"~
			"and the metadata which is required to build an installation\x{a}"~
			"source suitable for Novell SUSE Linux installation media.\x{a}"~
			"From such a source it should be possible to create the\x{a}"~
			"standard SUSE CDs and DVDs as well as use this source as\x{a}"~
			"repository for image building."
		]
		]
		element instsource {
			k.instsource.attlist &
			k.architectures &
			k.productoptions &
			k.instrepo+ &
			k.metadata &
			k.repopackages* &
			k.driverupdate?
		}
}

#==========================================
# main block: <architectures>
#
div {
	k.architectures.attlist = empty
	k.architectures =
		## Describe Packages and Metadata
		[
		db:para [
			"The architectures element contains a list of architectures\x{a}"~
			"for which the installation source is designed. At least one\x{a}"~
			"architecture must be defined. Fallback mecahnisms apply.\x{a}"~
			"Each arch element has an optional attribute <fallback>\x{a}"~
			"which is the next in the chain. An omitted value results in\x{a}"~
			"undefined value thus terminating the chain."
		]
		]
		element architectures {
			k.architectures.attlist &
			k.arch+ &
			k.requiredarch+
		}
}

#==========================================
# main block: <productoptions>
#
div {
	k.productoptions.attlist = empty
	k.productoptions =
		## Describe Packages and Metadata
		[
		db:para [
			"The productoptions element contains a list of options\x{a}"~
			"that influence the instsource creation process in a\x{a}"~
			"general manner. For instance an option could specify\x{a}"~
			"a default medium number for source packages and the like."
		]
		]
		element productoptions {
			k.productoptions.attlist &
			k.productoption* &
			k.productinfo* &
			k.productvar*
		}
}

#==========================================
# main block: <productoption>
#
div {
	k.productoption.attlist = k.name.attribute

	k.productoption =
		## Describe Packages and Metadata
		[
		db:para [
			"The productoption element carries the information for a\x{a}"~
			"product option its name and its fallback (productoptional)."
		]
		]
		element productoption {
			k.productoption.attlist &
			text
			#k.productinfo.text.content	
			#xsd:normalizedString { maxLength = "2048" }
		}
}

#==========================================
# main block: <arch>
#
div {
	k.arch.name.attribute = k.name.attribute
        k.arch.id.attribute = k.id.attribute
        k.arch.fallback.attribute = attribute fallback { xsd:IDREF }

	k.arch.attlist = k.arch.id.attribute &
			 k.arch.name.attribute &
			 k.arch.fallback.attribute?

	k.arch =
		## Describe Packages and Metadata
		[
		db:para [
			"The arch element providdes the information for an arch,\x{a}"~
			"its name and its fallback (optional)."
		]
		]
		element arch {
			k.arch.attlist &
			empty
		}
}

#==========================================
# main block: <requiredarch>
#
div {
        k.requiredarch.ref.attribute = attribute ref { xsd:IDREF }

	k.requiredarch.attlist = k.requiredarch.ref.attribute

	k.requiredarch =
		## Describe Packages and Metadata
		[
		db:para [
			"The requiredarch element defines which  architectures\x{a}"~
			"are the basic required ones for the media."
		]
		]
		element requiredarch {
			k.requiredarch.attlist &
			empty
		}
}

#==========================================
# main block: <productinfo>
#
div {
	k.productinfo.attlist = k.name.attribute 
	k.productinfo =
		## Describe Packages and Metadata
		[
		db:para [
			"The productinfo element contains one particular environment\x{a}"~
			"variable and its value. Shell rules for the names apply.\x{a}"~
			"The value must not exceed a certain length for sanity.\x{a}"~
			"reasons Any funny characters like tabs, line break,\x{a}"~
			"carriage return or combinations are converted to spaces\x{a}"~
			"(one each) which may lead to unexpected contents."
		]
		]
		element productinfo {
			k.productinfo.attlist &
			# text: workaround for the above mentioned problem
			text
			#k.productinfo.text.content	
			#xsd:normalizedString { maxLength = "2048" }
		}
}

#==========================================
# main block: <productvar>
#
div {
	k.productvar.attlist =
		k.name.attribute 
	k.productvar =
		## Describe Packages and Metadata
		[
		db:para [
			"The productinfo element contains one particular environment\x{a}"~
			"variable and its value. Shell rules for the names apply.\x{a}"~
			"The value is used to create the content file."
		]
		]
		element productvar {
			k.productvar.attlist &
			# text: workaround for the above mentioned problem
			text
			#k.productvar	
			#xsd:normalizedString { maxLength = "2048" }
		}
}

#==========================================
# main block: <chroot>
#
div {
	k.chroot.attlist = attribute requires { text } 

	k.chroot =
		## Describe Packages and Metadata
		[
		db:para [
			"The chroot element contains one particular environment\x{a}"~
			"variable and its value. Shell rules for the names apply.\x{a}"~
			"The value must not exceed a certain length for sanity.\x{a}"~
			"reasons Any funny characters like tabs, line break, \x{a}"~
			"carriage return or combinations are converted to spaces\x{a}"~
			"(one each) which may lead to unexpected contents."
		]
		]
		element chroot {
			k.chroot.attlist &
			text
		}
}

#==========================================
# main block: <ec2config>
#
div {
	k.ec2config.attlist = empty
	k.ec2config =
		## Specifies the AWS EC2 configuration section
		[
		db:para [
			"The ec2config element specifies the EC2 image\x{a}"~
			"configuration options."
		]
		]
		element ec2config {
			k.ec2config.attlist &
			k.ec2accountnr? &
			k.ec2certfile? &
			k.ec2privatekeyfile? &
			k.ec2region*
		}
}

#==========================================
# main block: <repopackages>
#
div {
	k.repopackages.attlist = empty
	k.repopackages =  
		## Specifies Packages for Installation Source
		[
		db:para [
			"The repopackages elements specifies a set of packages which\x{a}"~
			"are used for creating a Novell SUSE installation source."
		]
		]
		element repopackages {
			k.repopackages.attlist &
			k.repopackage*
		}
}

#==========================================
# main block: <driverupdate>
#
div {
	k.driverupdate.attlist = empty
	k.driverupdate =
		## Describe Packages and Metadata
		[
		db:para [
			"Creating a driverupdate disk for using updated hardware\x{a}"~
			"drivers on system installation with YaST."
		]
		]
		element driverupdate {
			k.driverupdate.attlist &
			k.target+ &
			k.install? &
			k.modules? &
			k.instsys?
		}
}

#==========================================
# main block: <target>
#
div {
	k.target.arch.attribute = k.arch.attribute
	k.target.attlist = k.target.arch.attribute
	k.target =
		## Describe Packages and Metadata
		[
		db:para [
			"List of update targets: <dist>-<arch>\x{a}"
		]
		]
		element target {
			k.target.attlist &
			text
		}
}

#==========================================
# main block: <install>
#
div {
	k.install.attlist = empty
	k.install =
		## Describe Packages and Metadata
		[
		db:para [
			"List of packages to be copied into the 'install' directory"
		]
		]
		element install {
			k.install.attlist &
			k.repopackage*
		}
}

#==========================================
# main block: <modules>
#
div {
	k.modules.attlist = empty
	k.modules =
		## Describe Packages and Metadata
		[
		db:para [
			"List of packages to be copied into the 'modules' directory"
		]
		]
		element modules {
			k.modules.attlist &
			k.repopackage*
		}
}

#==========================================
# main block: <instsys>
#
div {
	k.instsys.attlist = empty
	k.instsys =
		## Describe Packages and Metadata
		[
		db:para [
			"List of packages to be copied into the 'instsys' directory"
		]
		]
		element instsys {
			k.instsys.attlist &
			k.repopackage*
		}
}

#==========================================
# main block: <oemconfig>
#
div {
	k.oemconfig.attlist = empty
	k.oemconfig =
		## Specifies the OEM configuration section
		[
		db:para [
			"The oemconfig element specifies the OEM image\x{a}"~
			"configuration options which are used to repartition\x{a}"~
			"and setup the system disk"
		]
		]
		element oemconfig {
			k.oemconfig.attlist &
			k.oem-align-partition? &
			k.oem-boot-title? &
			k.oem-bootwait? &
			k.oem-inplace-recovery? &
			k.oem-kiwi-initrd? &
			k.oem-partition-install? &
			k.oem-reboot? &
			k.oem-reboot-interactive? &
			k.oem-recovery? &
			k.oem-recoveryID? &
			k.oem-silent-boot? &
			k.oem-shutdown? &
			k.oem-shutdown-interactive? &
			k.oem-swap? &
			k.oem-swapsize? &
			k.oem-systemsize? &
			k.oem-unattended? &
			k.oem-unattended-id?
		}
}

#==========================================
# main block: <machine>
#
div {
	k.machine.ovftype.attribute =
		## The OVF configuration type
		attribute ovftype { "zvm" | "povervm" | "xen" | "vmware" }
	k.machine.HWversion.attribute =
		## The virtual HW version number for the VM configuration
		attribute HWversion { xsd:integer }
	k.machine.arch.attribute =
		## the VM architecture type
		attribute arch { "ix86" | "x86_64" | "%arch" }
	k.machine.domain.attribute =
		## The domain setup for the VM (xen only)
		attribute domain { "dom0" | "domU" }
	k.machine.guestOS.attribute =
		## the virtual guestOS identification string for the VM
		attribute guestOS { text }
	k.machine.min_memory.attribute =
		## The virtual machine min memory
		attribute min_memory { xsd:nonNegativeInteger }
	k.machine.des_memory.attribute =
		## The virtual machine desired memory
		attribute des_memory { xsd:nonNegativeInteger }
	k.machine.max_memory.attribute =
		## The virtual machine max memory
		attribute max_memory { xsd:nonNegativeInteger }
	k.machine.min_cpu.attribute =
		## The virtual machine min CPU count
		attribute min_cpu { xsd:nonNegativeInteger }
	k.machine.des_cpu.attribute =
		## The virtual machine desired CPU count
		attribute des_cpu { xsd:nonNegativeInteger }
	k.machine.max_cpu.attribute =
		## The virtual machine max CPU count
		attribute max_cpu { xsd:nonNegativeInteger }
	k.machine.memory.attribute =
		## The memory setup for the guest VM. Specify memory in MB
		attribute memory { xsd:nonNegativeInteger }
    k.machine.ncpus.attribute =
        ## The number of virtual cpus for the guest VM
        attribute ncpus { xsd:nonNegativeInteger }
	k.machine.attlist =
		k.machine.min_memory.attribute? &
		k.machine.des_memory.attribute? &
		k.machine.max_memory.attribute? &
		k.machine.min_cpu.attribute? &
		k.machine.des_cpu.attribute? &
		k.machine.max_cpu.attribute? &
		k.machine.ovftype.attribute? &
		k.machine.HWversion.attribute? &
		k.machine.arch.attribute? &
		k.machine.domain.attribute? &
		k.machine.guestOS.attribute? &
		k.machine.memory.attribute? &
		k.machine.ncpus.attribute?
	k.machine =
		## specifies the VM configuration sections
		[
		db:para [
			"The machine element specifies the VM guest\x{a}"~
			"configuration options which are used by the\x{a}"~
			"virtual machine when running the image."
		]
		]
		element machine {
			k.machine.attlist &
			k.vmconfig-entry * &
			k.vmdisk ? &
			k.vmdvd ? &
			k.vmnic *
		}
}

#==========================================
# main block: <packages>
#
div {
	k.packages.type.attribute = attribute type {
		"bootstrap" | "delete" | "image" | "iso" | "oem" | "pxe" |
		"split" | "testsuite" | "vmx"
	}
	k.packages.profiles.attribute = k.profiles.attribute
	k.packages.patternType.attribute =
		## Selection type for patterns. Could be onlyRequired
		## or plusRecommended
		attribute patternType {
			"onlyRequired" | "plusRecommended"
		}
	k.packages.attlist =
		k.packages.type.attribute &
		k.packages.profiles.attribute? &
		k.packages.patternType.attribute?
	k.packages =
		## Specifies Packages/Patterns Used in Different Stages
		[
		db:para [
			"The packages elements specifies a set of packages\x{a}"~
			"and/or patterns which are used in different stages of the\x{a}"~
			"image building process\x{a}"~
			"and also depends of the selected image output type."
		]
		]
		element packages {
			k.packages.attlist &
			k.package* &
			k.opensusepattern* &
			k.rhelgroup* &
			k.opensuseproduct* &
			k.ignore* &
			k.archive*
		}
}

#==========================================
# main block: <preferences>
#
div {
	k.preferences.profiles.attribute = k.profiles.attribute
	k.preferences.attlist =
		k.preferences.profiles.attribute?
	k.preferences =  
		## Configuration Information Needed for Logical Extend
		element preferences {
			k.preferences.attlist &
			k.boot-theme? &
			k.defaultdestination? &
			k.defaultroot? &
			k.hwclock? &
			k.keytable? &
			k.locale? &
			k.packagemanager? &
			k.rpm-check-signatures? &
			k.rpm-excludedocs? &
			k.rpm-force? &
			k.timezone? &
			k.type* &
			k.showlicense* &
			k.version?
		}
}

#==========================================
# main block: <profiles>
#
div {
	k.profiles.attlist = empty
	k.profiles =  
		## Creates Namespace Section for Drivers
		[
		db:para [
			"Namespace section which creates a namespace and the\x{a}"~
			"drivers can bind itself to one of the listed namespaces."
		]
		]
		element profiles {
			k.profiles.attlist &
			k.profile+
		}
}

#==========================================
# main block: <split>
#
div {
	k.split.attlist = empty
	k.split =  
		## Describes Images in Read-Only and Read-Write Portions
		[
		db:para [
			"When the image type split is requested the image will be\x{a}"~
			"splitted into a read-only and a read-write image portion.\x{a}"~
			"Each portion can have different filesystems and the split\x{a}"~
			"section describes which files/directories should go in\x{a}"~
			"what portion."
		]
		]
		element split {
			k.split.attlist &
			k.temporary? &
			k.persistent?
		}
}

#==========================================
# main block: <users>
#
div {
	k.users.group.attribute =
		## Contains the group to which the user belongs
		attribute group { text }
	k.users.id.attribute =
		## Contains the group ID to which the user belongs
		attribute id { xsd:nonNegativeInteger }
	k.users.attlist = k.users.group.attribute
		& k.users.id.attribute ?
	k.users = 
		## A List of Users
		element users {
			k.users.attlist &
			k.user+
		}
}


# vim: set noexpandtab:
