<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                         "http://www.docbook.org/xml/4.5/docbookx.dtd"
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<chapter id="chap.pxe">
 <title>PXE Image / Thin Clients</title><indexterm>
 <primary>KIWI</primary>
 <secondary>PXE image</secondary></indexterm><indexterm>
 <primary>images</primary>
 <secondary>PXE</secondary></indexterm><indexterm>
 <primary>PXE images</primary></indexterm><indexterm>
 <primary>network boot</primary></indexterm>
 <abstract>
  <para>
   PXE is a network boot protocol that is shipped with most BIOS
   implementations. The protocol sends a DHCP request to get an IP
   address. When an IP address is assigned, it uses the TFTP protocol to
   download a Kernel and boot instructions. Contrary to other images built
   with KIWI, a PXE image consists of separate boot and system images, since
   both images need to be made available in different locations on the network
   boot server.
  </para>
 </abstract>

 <tip>
  <title>PXE Image Description Templates</title>
  <para>
   &template_intro;
  </para>
  <para>
   PXE image templates are shipped with the package
   <package>kiwi-desc-netboot</package>. They are installed to
   <filename>/usr/share/kiwi/image/netboot</filename>.
  </para>
 </tip>

 &jeos_tip;
 <sect1 id="sec.pxe.building">
  <title>Building PXE Images</title>

  <para>
   The following example shows how to build a Just enough Operating
   System (JeOS) based on SUSE Linux Enterprise 12:
  </para>
  <screen>kiwi --build suse-SLE12-community-JeOS --add-profile netboot --type pxe -d /tmp/mypxe-result</screen>
  <para>
   This command generates a compressed root file system image which is deployed
   as an overlayfs-based union system. To use the image, all image parts need
   to be copied to a PXE boot server. If you have not set up such a server,
   refer to <xref linkend="app.bootserver"/> for instructions. The following
   example assumes you have created the PXE image on the boot server itself
   (if not, use <command>scp</command> to copy the files on the remote host).
  </para>

  <procedure id="proc.pxe.using">
   <step>
    <para>
     Change into the build directory:
    </para>
    <screen>cd /tmp/mypxe-result</screen>
   </step>
   <step>
    <para>
     Copy the initrd and the kernel to
     <filename class="directory">/srv/tftpboot/boot/initrd</filename>:
    </para>
    <screen>cp initrd-netboot-suse-SLES12.x86_64-2.1.1.gz /srv/tftpboot/boot/initrd
cp initrd-netboot-suse-SLES12.x86_64-2.1.1.kernel /srv/tftpboot/boot/linux</screen>
   </step>
   <step>
    <para>
     Copy the system image and its md5 sum to <filename
     class="directory">/srv/tftpboot/image</filename>:
    </para>
<screen>cp LimeJeOS-SLE12-Community.x86_64-1.13.1 /srv/tftpboot/image
cp LimeJeOS-SLE12-Community.x86_64-1.13.1.md5 /srv/tftpboot/image</screen>
   </step>
   <step>
    <para>
     Copy the image boot configuration to <filename
     class="directory">/srv/tftpboot/KIWI/config.default</filename>. See
     <xref linkend="sec.pxe.files"/> for details.
    </para>
    <screen>cp LimeJeOS-SLE12-Community.x86_64-1.13.1.config \
 /srv/tftpboot/KIWI/config.default</screen>
   </step>
   <step>
    <para>
     Adjust the PXE configuration file. it controls which kernel and initrd is
     loaded and which kernel parameters are set. A template has been installed
     at <filename>/srv/tftpboot/pxelinux.cfg/default</filename> with the
     <package>kiwi-pxeboot</package> package. The minimal configuration
     required to boot the SLE 12 JeOS looks like to following:
    </para>
    <screen>DEFAULT KIWI-Boot

LABEL KIWI-Boot
    kernel boot/linux
    append initrd=boot/initrd
    IPAPPEND 1

LABEL Local-Boot
    localboot 0</screen>


    <remark condition="clarity">
     2015-07-31 - fs: The content above differs from what is installed with
     kiwi-pxeboot.
    </remark>


   </step>
   <step>
    <para>
     Connect the client to the network and boot it.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 id="sec.pxe.files">
  <title>PXE Configuration Files</title>

  <para>
   <remark condition="clarity">
    2015-12-02 - fs: Removed everything concerning hwtype.MAC, since it did
    not seem relevant
   </remark>
   All PXE boot based deployment methods are controlled by configuration files
   located in <filename class="directory">/srv/tftpboot/KIWI</filename> on the
   PXE server. Such a configuration file can either be client-specific
   (<filename>config.<replaceable>MAC_ADDRESS</replaceable></filename>, for
   example <filename>config.00.AB.F3.11.73.C8</filename>),
   group-specific
   (<filename>config.<replaceable>GROUP</replaceable></filename>, see <xref
   linkend="sec.pxe.groups"/> for details) or generic
   (<filename>config.default</filename>).  In an environment with
   heterogeneous clients, this allows to have a default configuration suitable
   for the majority of clients, to have configurations suitable for a group of
   clients (for example machines with similar or identical hardware) and
   individual configurations for selected machines.
  </para>
  <para>
   Configuration files are assigned to a client in the following order, the
   first matching file is used:
  </para>
  <orderedlist>
   <listitem>
    <para>
     <filename>config.<replaceable>MAC_ADDRESS</replaceable></filename>
    </para>
   </listitem>
   <listitem>
    <para>
     <filename>config.<replaceable>GROUP</replaceable></filename>
    </para>
   </listitem>
   <listitem>
    <para>
     <filename>config.default</filename>
    </para>
   </listitem>
  </orderedlist>
  <para>
   When building the OEM image a template configuration file named
   <filename><replaceable>IMAGE_NAME.config</replaceable></filename> (for
   example <filename>LimeJeOS-SLE12.x86_64-1.13.1.config</filename>) is
   generated. Copy this file to
   <filename>/srv/tftpboot/KIWI/config.default</filename> on the PXE
   server and adjust it according to your needs. If you need client- or
   group-specific configuration files, use the final version of
   <filename>config.default</filename> as a template.
  </para>
 </sect1>

  <!--
  <sect2 id="sec.pxe.client-control-file">
   <title>The PXE Client Control File</title>
   <para>
    The netboot client control file is named
   </para>
   <screen>hwtype.<replaceable>MAC_ADDRESS</replaceable></screen>
   <para>
    The control file is primarily used to set up new netboot clients when no
    configuration file corresponding to the client's MAC address
    available. The control file is uploaded to
    <filename>/var/lib/tftpboot/upload</filename>.
   </para>
-->

  <sect1 id="sec.pxe.client-config-file">
   <title>The PXE Client Configuration File Syntax</title>
   <para>
    The configuration file contains data about the image and about
    configuration, synchronization, and partition parameters.
    The configuration file has got the following general format:
   </para>
   <screen>AOEROOT=device
COMBINED_IMAGE=1
CONF="src;dest;srvip;bsize;[hash],...,src;dest;srvip;bsize;[hash]"
DISK="device"
FORCE_KEXEC=1
IMAGE="device;name;version;srvip;bsize;compressed,...,"
KIWI_BOOT_TIMEOUT="seconds"
KIWI_INITRD="path-to-initrd"
KIWI_KERNEL="path-to-kernel"
KIWI_KERNEL_OPTIONS="opt1 opt2 ..."
NBDROOTNBDROOT="ip-address;export-name;device;swap-export-name;swap-device;write-export-name;write-device"
NFSROOT="ip-address;path"
PART="size;id;Mount,...,size;id;Mount"
RAID="raid-level;device1;device2;..."
REBOOT_IMAGE=1
RELOAD_CONFIG=1
RELOAD_IMAGE=1
UNIONFS_CONFIGURATION="rw-partition,compressed-partition,container-fs"</screen>

   <tip>
    <title>Quoting the Values</title>
    <para>
     <filename>config.<replaceable>MAC_ADDRESS</replaceable></filename>
     is sourced by the Bash, so the same quoting rules as for the Bash apply.
    </para>
   </tip>

   <para>
    Not all configuration options need to be specified. The following
    configuration is an example for an image based on a read-write file system
    stored on a local disk:
   </para>
   <screen>DISK="/dev/sda"
PART="5;S;x,x;L;/"
IMAGE="/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096"</screen>

   <para>
    Refer to the following list for details on each configuration option:
   </para>

   <variablelist>
    <varlistentry>
     <term><varname>AOEROOT</varname></term>
     <listitem>
      <para>
       Mount the system image root file system remotely via AoE (ATA over
       Ethernet). This requires a server exporting a block device
       representing the root directory of the system image via the AoE
       subsystem. The block device could be a partition of a real or a
       virtual disk. To use the AoE subsystem it is recommended to
       install the <package>aoetools</package> and <package>vblade</package>
       packages from <ulink
       url="http://download.opensuse.org/repositories/server:/ltsp"/>.
      </para>
      <para>
       When these packages are installed, partitions can be exported with the
       <command>vbladed</command> command. The following example shows how to
       export <filename class="devicefile">/dev/sdb1</filename> via AoE with a
       major value of 0 and minor of 1 on the eth0 interface.:
      </para>
      <screen><command>vbladed</command> 0 1 eth0 /dev/sdb1</screen>
      <para>
       To be able to use the device KIWI needs the information which AoE
       device contains the root file system. In this example this is the device
       <filename class="devicefile">/dev/etherd/e0.1</filename>:
      </para>
      <screen>AOEROOT=/dev/etherd/e0.1</screen>
      <para>
       In case of a compressed read-only image with <systemitem
       class="filesystem">overlayfs</systemitem>, the
       <varname>AOEROOT</varname> variable can also contain a second device
       for the write actions:
      </para>
      <screen>AOEROOT=/dev/etherd/e0.1,/dev/ram1</screen>
      <para>
       Writing to RAM as in the example above, is the default. You also can
       specify another AoE location or a local device for writing the data.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>COMBINED_IMAGE</varname></term>
     <listitem>
      <para>
       If set to a non-empty string, indicates that the boot and the system
       image need to be combined into a single bootable image. The first image
       defines the read-write part and the second image defines the read-only
       part.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>CONF</varname>, <varname>VENDOR_CONF</varname></term>
     <listitem>
      <para>
       Specifies a comma-separated list of source:target configuration file
       names. The <literal>source</literal> corresponds to the path on the
       TFTP server. It is downloaded to <literal>target</literal> on the
       client. The download is only done when the file is missing on the
       client or has a different md5-sum (in case the md5sum hash is supplied
       with <literal>hash</literal>).
      </para>
      <para>
       To achieve this, a list of <varname>CONF</varname> files (and
       <varname>VENDOR_CONF</varname>) files that generated by KIWI and stored
       on the client (<filename>/etc/KIWI/InstalledConfigFiles</filename>) is
       compared to the <varname>CONF</varname> data gathered from the
       configuration file (for example <filename>config.default</filename>),
       if supplied.
      </para>
      <para>
       Configuration files selected for comparison are those with same
       destination path (dest). If the destination path is same for more than
       one configuration file, only the last one is used (and
       <varname>VENDOR_CONF</varname> always take s precedence over
       <varname>CONF</varname>). By comparing configuration file lists present
       in the current <varname>CONF</varname> and
       <varname>VENDOR_CONF</varname> variables and with the local list, the
       following actions can result:
      </para>
      <table id="tab.configuration.files.synchronization">
       <title>Configuration Files Synchronization Possibilities</title>
        <tgroup cols="3">
         <colspec colwidth="1*"/>
         <colspec colwidth="1*"/>
         <colspec colwidth="1*"/>
         <thead>
          <row>
           <entry>
            File from <varname>CONF</varname>, <varname>VENDOR_CONF</varname>
           </entry>
           <entry>
            <filename>InstalledConfigFiles</filename>
           </entry>
           <entry>Action</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry>hash_a</entry>
           <entry>hash_a</entry>
           <entry>nothing, keep</entry>
          </row>
          <row>
           <entry>hash_a</entry>
           <entry>hash_b</entry>
           <entry>download from server</entry>
          </row>
          <row>
           <entry>none</entry>
           <entry>hash</entry>
           <entry>download from server</entry>
          </row>
          <row>
           <entry>hash</entry>
           <entry>none</entry>
           <entry>download from server</entry>
          </row>
          <row>
           <entry>none</entry>
           <entry>none</entry>
           <entry>nothing, keep</entry>
          </row>
          <row>
           <entry>present</entry>
           <entry>not present</entry>
           <entry>download from server (regardless of hash)</entry>
          </row>
          <row>
           <entry>not present</entry>
           <entry>present</entry>
           <entry>delete on client (regardless hash)</entry>
          </row>
         </tbody>
        </tgroup>
      </table>

      <para>
       Note that actual configuration files (or their md5sum hashes) on the
       client machine are not tested&mdash;only data from the list file
       <filename>/etc/KIWI/InstalledConfigFiles</filename> is used to
       determine which files need to be synchronized. This means that actual
       configuration files can be altered or even be deleted without
       triggering any action. On the other hand, if the list file is changed
       or deleted, an action could be triggered although the actual
       configuration files have not changed.
     </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>DISK</varname></term>
     <listitem>
      <para>
       Specifies the storage device. Only to be used together with
       <varname>PART</varname>, for example:
      </para>
      <screen>DISK=/dev/hda</screen>
     </listitem>
    </varlistentry>

<!-- fs 2015-11-30: Debugging only feature
    <varlistentry>
     <term><varname>ERROR_INTERRUPT</varname></term>
     <listitem>
      <para>
       Specifies a message which is displayed during first deployment. Along
       with the message a shell is provided. This functionality should be
       used to send the user a message if it’s clear the boot process will
       fail because the boot environment or something else influences the
       PXE boot process in a bad way.
      </para>
     </listitem>
     </varlistentry>
-->

    <varlistentry>
     <term><varname>FORCE_KEXEC</varname>
     </term>
     <listitem>
      <para>
       During the initial deployment process KIWI checks if the running Kernel
       is the same as the Kernel installed via the system image. If there is a
       mismatch, KIWI activates the installed kernel by calling
       <command>kexec</command>. Kexec is a tool to boot to another kernel
       from the currently running one. The system boots faster, because the
       hardware initialization phase and the boot loader are skipped..
      </para>
      <para>
       If <varname>FORCE_KEXEC</varname> is set to a non-empty string kiwi
       will also perform kexec if the Kernel versions matches.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>IMAGE</varname>
     </term>
     <listitem>
      <para>
       Specifies the image to be downloaded and the device for the root file
       system.
      </para>
      <screen>IMAGE='<replaceable>device</replaceable>;<replaceable>name</replaceable>;<replaceable>version</replaceable>;<replaceable>srvip</replaceable>;<replaceable>bsize</replaceable>;compressed'</screen>
      <para>
       The following parameters are supported:
      </para>
      <variablelist>
       <varlistentry>
        <term><literal>device</literal></term>
        <listitem>
         <remark condition="clarity">
          2015-11-24 - fs: Please check whether the following is correct
         </remark>
         <para>
          The device the root file system should be installed on. Can either
          be a RAM disk (for example <filename
          class="devicefile">/dev/ram1</filename> or a block device (for
          example <filename class="devicefile">/dev/hda2</filename>).
         </para>
         <para>
          When using a RAM disk, note that you cannot use <filename
          class="devicefile">/dev/ram0</filename>, since it is already
          reserved for the initial RAM disk set up by the installation
          system. Use <filename class="devicefile">/dev/ram1</filename>
          instead.
         </para>
         <para>
          When using a block device, always make sure to also create a
          corresponding <envar>PART</envar> entry defining the
          partitioning. Note that a partitioning scheme defined with
          <envar>PART</envar> always defines the first partition as swap and
          the second partition as the root file system. Therefore
          <literal>device</literal> needs to point to the second partition
          (for example <filename class="devicefile">/dev/hda2</filename>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>name</literal></term>
        <listitem>
         <remark condition="clarity">
          2015-11-24 - fs: Is "##.#" used as a wild card for the version string?
         </remark>
         <para>
          File name of the image. Use the character <quote>#</quote> as a wild
          card for the version number, for example
          <literal>LimeJeOS-SLE12-Community.x86_64-#.##.#</literal>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>version</literal></term>
        <listitem>
         <para>
          Version string, for example <literal>1.13.1</literal>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>srvip</literal></term>
        <listitem>
         <para>
          Specifies the server IP address for the TFTP download. Must always
          be indicated, except in <varname>PART</varname>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>bsize</literal></term>
        <listitem>
         <para>
          Specifies the block size for the TFTP download. Must always be
          indicated, except in <varname>PART</varname>. If the block size is
          too small according to the maximum number of data packages (32768),
          linuxrc will automatically calculate a new block size for the
          download.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>compressed</literal></term>
        <listitem>
         <para>
          Specifies if the image file on the TFTP server is compressed and
          handles it accordingly. To specify a compressed image download only
          the keyword <literal>compressed</literal> needs to be added. If
          compressed is not specified the standard download workflow is used.
         </para>
         <para>
          The name of the compressed image needs to contain the suffix <filename
          class="extension">.gz</filename> and the image needs to be
          compressed with the <command>gzip</command> tool.  Using a
          compressed image will automatically <emphasis>deactivate</emphasis>
          the multicast download option of atftp.
         </para>
         <screen>IMAGE='/dev/sda2;suse.i686.gz;1.2.8;192.168.100.2;4096;compressed'</screen>
         <important>
          <title></title>
          <para>
           The download will fail if you specify <literal>compressed</literal>
           and the image is not compressed. It will also fail if you don’t
           specify <literal>compressed</literal> but the image is compressed.
          </para>
         </important>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>KIWI_BOOT_TIMEOUT</varname>
     </term>
     <listitem>
      <para>
       Specifies the number of seconds to wait at the boot loader screen when
       doing a local boot before booting the default boot entry. The default
       is 10.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>KIWI_INITRD</varname>
     </term>
     <listitem>
      <para>
       Specifies the KIWI initrd to be used for a local boot of the system.
       The value must be set to the name of the initrd file which is used via
       PXE network boot. If the standard TFTP setup suggested with the
       kiwi-pxeboot package is used all initrd files reside in <filename
       class="directory">/var/lib/tftpboot/boot/</filename>. However, because
       the TFTP server does a change root (<command>chroot
       /var/lib/tftpboot</command>) you need to specify the initrd file as in
       the following example:
      </para>
      <screen>KIWI_INITRD=/boot/<replaceable>name-of-initrd-file</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>KIWI_KERNEL</varname>
     </term>
     <listitem>
      <para>
       Specifies the Kernel to be used for a local boot of the system The
       same path rules as described for <varname>KIWI_INITRD</varname>
       apply for the kernel setup:
      </para>
      <screen>KIWI_KERNEL=/boot/<replaceable>name-of-kernel-file</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>KIWI_KERNEL_OPTIONS</varname>
     </term>
     <listitem>
      <para>
       Specifies additional command line options to be passed to the Kernel
       when booting from disk. For instance, to enable a splash screen, you
       might use
      </para>
      <screen>KIWI_KERNEL_OPTIONS="vga=0x317 splash=silent"</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>NBDROOT</varname>
     </term>
     <listitem>
      <para>
       Mount the system image root file system remotely via NBD (Network Block
       Device). This requires a server which exports the root directory
       of the system image via a specified export name. The Kernel provides
       the block layer, together with a remote port that uses the nbd-server
       program. For more information on how to set up the server, see
       <command>man 1 nbd-server</command>. The Kernel on the remote client
       can set up a special network block device named <filename
       class="devicefile">/dev/nb0</filename> using the nbd-client
       command. After this device exists, the mount program is used to mount
       the root file system. To allow the KIWI boot image to use that, the
       following information must be provided:
      </para>
<screen>NBDROOT=<replaceable>NBD.Server.IP.address;</replaceable>\
<replaceable>NBD-Export-Name</replaceable>;/dev/<replaceable>NBD-Device</replaceable>;\
<replaceable>NBD-Swap-Export-Name</replaceable>;/dev/<replaceable>NBD-Swap-Device</replaceable>;\
<replaceable>NBD-Write-Export-Name</replaceable>;/dev/<replaceable>NBD-Write-Device</replaceable></screen>
      <para>
       The server IP and the export name are mandatory parameters, all other
       parameters are optional. The default device names are:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         NBD-Device: <filename class="devicefile">/dev/nbd0</filename>,
        </para>
       </listitem>
       <listitem>
        <para>
         NBD-Swap-Device: <filename class="devicefile">/dev/nbd1</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         NBD-Write-Device: <filename class="devicefile">/dev/ram1</filename>
        </para>
       </listitem>
      </itemizedlist>
      <para>
       Defining a swap device is optional. It is only set up if the client
       has less than 48 MB of RAM. The optional NBD-Write-Export-Name and
       NBD-Write-Device define a write copy-on-write (COW) location for the
       root file system. A separate write device is only used together with a
       union setup based on, for example, overlayfs.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>NFSROOT</varname>
     </term>
     <listitem>
      <para>
       Mount the system image root file system remotely via NFS (Network File
       System). This requires a server which exports the root file system of
       the network client in such a way that the client can mount it
       read/write. To do that, the boot image must know the server IP
       address and the path name where the root directory exists on this
       server. The information must be provided like follows:
      </para>
<screen>NFSROOT=<replaceable>NFS.Server.IP.address</replaceable>;<replaceable>/path/to/root/tree</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>PART</varname>
     </term>
     <listitem>
      <para>
       Specifies the partitioning data. Comma-separated blocks contain size,
       partition type and mount point:
      </para>
      <screen>PART='<replaceable>size</replaceable>;<replaceable>type</replaceable>;<replaceable>mountpoint</replaceable>,...,<replaceable>size</replaceable>;<replaceable>type</replaceable>;<replaceable>mountpoint</replaceable>'</screen>
      <para>
       In addition, the following rules apply:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <replaceable>size</replaceable> is measured in megabytes (MB).
        </para>
       </listitem>
       <listitem>
        <para>
         <replaceable>type</replaceable> can be one of the following values:
        </para>
        <simplelist>
         <member>
          <literal>S</literal> or <literal>82</literal>: swap partition
         </member>
         <member>
          <literal>L</literal> or <literal>83</literal>: linux partition
         </member>
         <member>
          <literal>V</literal> or <literal>8e</literal>: LVM partition
         </member>
         <member><literal>fd</literal>: RAID partition</member>
         <member><literal>41</literal>: prep-partition for IBM POWER</member>
        </simplelist>
       </listitem>
       <listitem>
        <para>
         The first element of the list must define the swap partition.
        </para>
        <para>
         The swap partition must not contain a mount point. A lowercase
         letter <literal>x</literal> needs to be set instead.
        </para>
       </listitem>
       <listitem>
        <para>
         The second element of the list must define the root partition.
        </para>
       </listitem>
       <listitem>
        <para>
         If a partition should take all the space left on a disk one can set
         a lower <literal>x</literal> letter as size specification.
        </para>
       </listitem>
      </itemizedlist>
      <para>
       The following example defines a 2 GB swap partition
       (<literal>2000;S;x</literal>) and a root partition occupying the
       remaining space on the disk (<literal>x;L;/</literal>):
      </para>
      <screen>PART='2000;S;x,x;L;/'</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>RAID</varname>
     </term>
     <listitem>
      <para>
       In addition to the <varname>PART</varname> line it is also allowed to
       add a raid array setup. The first parameter of the
       <varname>RAID</varname> line is the raid level. So far only raid1
       (mirroring) is supported. The second and third parameter specifies the
       raid disk devices which make up the array. If a RAID line is present
       all partitions in PART will be created as raid partitions. The first
       raid is named md0 the second one md1 and so on.  It is required to
       specify the correct raid partition in the IMAGE line according to the
       PART setup. A typical raid image setup could look like this:
      </para>
<screen>DISK=/dev/sda
RAID='1;/dev/sda;/dev/sdb'
IMAGE='/dev/md1;LimeJeOS-openSUSE-##.#.i686;1.11.3;192.168.100.2;4096'
PART='5;S;x,2000;L;/'</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>REBOOT_IMAGE</varname></term>
     <listitem>
      <para>
       If set to a non-empty string, this will reboot the system after the
       initial deployment process is done. This means the system is rebooted
       before the system init process is activated. If the machine's default
       boot setup is to boot via PXE it will again boot from the network.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>RELOAD_CONFIG</varname>
     </term>
     <listitem>
      <para>
       If set to a non-empty string, this forces all configuration files to be
       loaded from the server. The primary purpose of this setting is to aid
       debugging. The option only applies to disk-based systems.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>RELOAD_IMAGE</varname>
     </term>
     <listitem>
      <para>
       If set to a non-empty string, this forces the image to be loaded from
       the server even if the image on the disk is up-to-date.  The primary
       purpose of this setting is to aid debugging. The option only applies
       to disk-based systems.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="var.pxe.client-config-file.unionfs">
     <term><varname>UNIONFS_CONFIG</varname>
     </term>
     <listitem>
      <para>
       Netboot images may use overlayfs as a
       container file system in combination with a compressed system image.
       The recommended compressed file system type for the system image is
       <emphasis role="bold">overlayfs</emphasis>.
      </para>
<screen>UNIONFS_CONFIG=/dev/sda2,/dev/sda3,overlayfs</screen>
      <para>
       In this example the first device <filename
       class="devicefile">/dev/sda2</filename> represents the read/write
       file system and the second device <filename
       class="devicefile">/dev/sda3</filename> represents the compressed
       system image file system.
      </para>
      <para>
       The union file system overlayfs is then used to cover the read/write
       layer with the read-only device to one read/write file system. If a
       file on the read-only device is going to be written, the changed inodes
       are part of the read/write file system. Note the device specifications
       in <varname>UNIONFS_CONFIG</varname> must correspond to the
       <varname>IMAGE</varname> and <varname>PART</varname> information. The
       following example should explain the interconnections:
      </para>
<screen>DISK=/dev/sda
IMAGE='/dev/sda3;image/myImage;1.1.1;192.168.1.1;4096'
PART='200;S;x,300;L;/,x;L;x'
UNIONFS_CONFIG=/dev/sda2,/dev/sda3,overlayfs</screen>
      <para>
       As the second element of the PART list must define the root partition
       it is absolutely important that the first device in
       <varname>UNIONFS_CONFIG</varname> matches this device as read/write
       device. The second device of <varname>UNIONFS_CONFIG</varname> needs to
       match the given IMAGE device name.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <sect2 id="sec.pxe.another-user">
    <title>Use a Different Download Protocol</title>
    <para>
     By default all downloads controlled by the KIWI linuxrc code are
     performed by an atftp call using the TFTP protocol. With PXE the download
     protocol is fixed and thus you cannott change the way how the kernel and
     the boot image (initrd) is downloaded. As soon as Linux takes over, the
     download protocols HTTP, HTTPS and FTP are supported too. KIWI uses of
     the <command>curl</command> program to support the additional protocols.
    </para>
    <para>
     To select one of the additional download protocols the following
     kernel parameters need to be specified ion
     <filename>/srv/tftpboot/pxelinux.cfg/default</filename>:
    </para>
    <variablelist>
     <varlistentry>
      <term><literal>kiwiserver</literal></term>
      <listitem>
       <para>
        Name or IP address of the server who implements the protocol
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>kiwiservertype</literal></term>
      <listitem>
       <para>
        Name of the download protocol which could be one of
        <literal>http</literal>, <literal>https</literal> or
        <literal>ftp</literal>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     To set up this parameters edit the file
     <filename>/srv/tftpboot/pxelinux.cfg/default</filename> on your PXE boot
     server and change the append line accordingly. Note that all downloads
     except for kernel and initrd are now controlled by the given server and
     protocol. You need to make sure that this server provides the same
     directory and file structure as initially provided by the
     <package>kiwi-pxeboot</package> package.
    </para>
   </sect2>

   <sect2 id="sec.pxe.ram-only-image">
    <title>RAM Only Image</title><indexterm>
    <primary>KIWI</primary>
    <secondary>RAM only image</secondary></indexterm>
    <para>
     If there is no local or remote storage for mounting the root file system,
     the image can be stored into the main memory of the client. The machine
     needs to be equipped with sufficient memory to host the RAM disk and
     provide enough additional memory for system operation. Set up the machine
     similar to the following example:
    </para>
    <procedure>
     <step>
      <para>
       Use a read-write file system in <filename>config.xml</filename>, for
       example <literal>filesystem="ext3"</literal>
      </para>
     </step>
     <step>
      <para>
       Create <filename>config.<replaceable>MAC</replaceable></filename>
      </para>
      <screen>IMAGE='/dev/ram1;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096'</screen>
     </step>
    </procedure>
   </sect2>

   <sect2 id="sec.pxe.union-image">
    <title>Union Image</title><indexterm>
    <primary>KIWI</primary>
    <secondary>union image</secondary></indexterm>
    <para>
     As shown in <xref linkend="var.pxe.client-config-file.unionfs"/> it is
     possible to use the union file system with overlayfs, to combine
     two file systems into one. In case of thin clients there is often the
     need for a compressed file system because of space limitations. However,
     all supported compressed file systems only allow read-only
     access. Combining a read-only file system with a read-write file system
     is a solution for this problem.  KIWI uses squashfs compressing file
     systems. To create an image with a compressed root file system, make sure
     the file system attribute in <filename>config.xml</filename> contains
     <systemitem class="filesystem">squashfs</systemitem>.
     <remark condition="clarity">
      2015-11-25 - fs: where should this attribute be set? A link to an
      example or an example right here is needed.
     </remark>
    </para>
    <para>
     When an image contains a compressed root file system, it can either be
     downloaded to the local machine or be mounted remotely. The following
     setups can be configured:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <!-- Download Compressed Image to Local Storage, Write to Local Storage-->
       <xref linkend="ex.pxe.union.local.local"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <!-- Download Compressed Image to Local Storage, Write to RAM -->
       <xref linkend="ex.pxe.union.local.ram"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <!-- Mount Compressed Image from Remote, Write to Local Storage -->
       <xref linkend="ex.pxe.union.remote.local"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <!-- Mount Compressed Image from Remote, Write to RAM -->
       <xref linkend="ex.pxe.union.remote.ram"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <!-- Mount Compressed Image from Remote, Write to Remote -->
       <xref linkend="ex.pxe.union.remote.remote"/>
      </para>
     </listitem>
    </itemizedlist>

    <example id="ex.pxe.union.local.local">
     <title>
      Download Compressed Image to Local Storage, Write to Local Storage
     </title>
     <indexterm>
      <primary>union image</primary>
      <secondary>local-local</secondary>
     </indexterm>
     <screen>DISK=/dev/sda
PART='5;S;x,400;L;/,x;L;x'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i386;1.2.8;192.168.100.2;4096'
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,overlayfs
KIWI_INITRD=/boot/initrd</screen>
    </example>

    <example id="ex.pxe.union.local.ram">
     <title>
      Download Compressed Image to Local Storage, Write to RAM
     </title>
     <indexterm>
      <primary>union image</primary>
     <secondary>local-ram</secondary></indexterm>
     <screen>DISK=/dev/sda
PART='5;S;x,400;L;/'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i386;1.2.8;192.168.100.2;4096'
UNIONFS_CONFIG=tmpfs,/dev/sda2,overlayfs</screen>
    </example>

    <example id="ex.pxe.union.remote.local">
     <title>
      Mount Compressed Image from Remote, Write to Local Storage
     </title>
     <indexterm>
      <primary>union image</primary>
      <secondary>remote-local</secondary>
     </indexterm>
     <para>
      Depending on whether the remote image is served via AoE, NBD, or NFS, the
      configuration differs:
     </para>
     <para>
      <emphasis role="bold">AoE</emphasis>
     </para>
     <screen>PART='5;S;x,x;L;x'
AOEROOT=/dev/etherd/e0.1,/dev/sda2
UNIONFS_CONFIG=/dev/sda2,aoe,overlayfs</screen>
     <para>
      <emphasis role="bold">NBD</emphasis>
     </para>
     <screen>PART='5;S;x,x;L;x'
NBDROOT=192.168.100.7;root1;/dev/nbd0;;;;/dev/sda2
UNIONFS_CONFIG=/dev/sda2,nbd,overlayfs</screen>
     <para>
      <emphasis role="bold">NFS</emphasis>
     </para>
     <screen>PART='5;S;x,x;L;x'
NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=/dev/sda2,nfs,overlayfs</screen>
    </example>

    <example id="ex.pxe.union.remote.ram">
     <title>
      Mount Compressed Image from Remote, Write to RAM
     </title>
     <indexterm>
      <primary>union image</primary>
      <secondary>remote-ram</secondary>
     </indexterm>
     <para>
      Depending on whether the remote image is served via AoE, NBD, or NFS, the
      configuration differs:
     </para>
     <para>
      <emphasis role="bold">AoE</emphasis>
     </para>
     <screen>AOEROOT=/dev/etherd/e0.1
UNIONFS_CONFIG=tmpfs,aoe,overlayfs</screen>
     <para>
      <emphasis role="bold">NBD</emphasis>
     </para>
     <screen>NBDROOT=192.168.100.7;root1;/dev/nbd0
UNIONFS_CONFIG=tmpfs,nbd,overlayfs</screen>
     <para>
      <emphasis role="bold">NFS</emphasis>
     </para>
     <screen>NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=tmpfs,nfs,overlayfs</screen>
    </example>

    <example id="ex.pxe.union.remote.remote">
     <title>
      Mount Compressed Image from Remote, Write to Remote
     </title>
     <indexterm>
      <primary>union image</primary>
      <secondary>remote-remote</secondary>
     </indexterm>
     <para>
      <emphasis role="bold">AoE</emphasis>
     </para>
     <screen>AOEROOT=/dev/etherd/e0.1,/dev/etherd/e1.1
UNIONFS_CONFIG=aoe,aoe,overlayfs</screen>
     <para>
      <emphasis role="bold">NBD</emphasis>
     </para>
     <screen>NBDROOT=192.168.100.7;root1;/dev/nbd0;swap1;/dev/nbd1;write1;/dev/nbd2
UNIONFS_CONFIG=nbd,nbd,overlayfs</screen>
     <para>
      <emphasis role="bold">NFS</emphasis>
     </para>
     <screen>NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=/srv/kiwi-read-write-path,nfs,overlayfs</screen>
    </example>

    <tip>
     <title>Check Remote Access</title>
     <para>
      It is recommended to check the accessibility of the read and, if
      applicable, the read-write devices from a client machine in the same
      network. If data can be read from and, if applicable, written to these
      devices, the image should also be able to access these devices when
      booting. If the PXE boot fails, device accessibility problems can be
      ruled out upfront.
     </para>
    </tip>
   </sect2>

   <sect2 id="sec.pxe.split-image">
    <title>Split Image</title><indexterm>
    <primary>KIWI</primary>
    <secondary>split image</secondary></indexterm>
    <para>
     An alternative to a Union Image (see <xref
     linkend="sec.pxe.union-image"/>)is a split image that combines the read
     and read-write partitions with
     the <varname>COMBINED_IMAGE</varname> method. This allows to use
     different file systems without the need for an overlay file system.
    </para>
    <para>
     Edit <filename>config.xml</filename> and add a split type plus a split
     section describing the <sgmltag>temporary</sgmltag> and
    <sgmltag>persistent</sgmltag> parts:
    </para>
    <screen>&lt;type fsreadonly="squashfs"
   image="split" fsreadwrite="ext3" boot="netboot/suse-..."/&gt;
  &lt;split&gt;
    &lt;temporary&gt;
      <sgmltag class="sgmlcomment"> allow RAM read/write access to: </sgmltag>
      &lt;file name="/mnt"/&gt;
      &lt;file name="/mnt/*"/&gt;
    &lt;/temporary&gt;
    &lt;persistent&gt;
      <sgmltag class="sgmlcomment"> allow DISK read/write access to: </sgmltag>
      &lt;file name="/var"/&gt;
      &lt;file name="/var/*"/&gt;
      &lt;file name="/boot"/&gt;
      &lt;file name="/boot/*"/&gt;
      &lt;file name="/etc"/&gt;
      &lt;file name="/etc/*"/&gt;
      &lt;file name="/home"/&gt;
      &lt;file name="/home/*"/&gt;
    &lt;/persistent&gt;
  &lt;/split&gt;
  ...
&lt;/type&gt;</screen>
    <para>
     Create a <filename>config.<replaceable>MAC</replaceable></filename> file
     similar to the following::
    </para>
    <screen>IMAGE='/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096,\
      /dev/sda3;suse-##.#-pxe-client-read-write.i686;1.2.8;192.168.100.2;4096'
PART='200;S;x,500;L;/,x;L'
DISK=/dev/sda
COMBINED_IMAGE=yes
KIWI_INITRD=/boot/initrd</screen>
   </sect2>

   <sect2 id="sec.pxe.remote-root">
    <title>Mounting the Root File System from a Remote Server</title>
    <para>
     Instead of installing the image on a local storage device, it is also
     possible to mount the root file system remotely via AoE, NBD, and NFS.
    </para>

    <example id="ex.pxe.remote-root.aoe">
     <title>Root Tree Over AoE</title>
     <para>
      Use the <command>vbladed</command> command on the remote server to bind
      a block device to an Ethernet interface. The block device can be a disk
      partition or a loop device (losetup) but not a directory. For example:
     </para>
     <screen>vbladed 0 1 eth0 <replaceable>blockdevice</replaceable></screen>
     <para>
      Create a <filename>config.<replaceable>MAC</replaceable></filename>
      pointing to the exported AoE device. For the example above, this would
      be:
     </para>
     <screen>AOEROOT=/dev/etherd/e0.1</screen>
    </example>

    <example id="ex.pxe.root-tree-over-nbd">
     <title>Root Tree Over NBD</title>
     <para>
      Export the KIWI prepared tree on the NBD server and use a
      <filename>config.<replaceable>MAC</replaceable></filename> file similar
      to the following example:
     </para>
     <screen>NBDROOT=192.168.100.7;root1;/dev/nbd0</screen>
    </example>

    <example id="ex.pxe.root-tree-over-nfs">
     <title>Root Tree Over NFS</title>
     <para>
      Export the KIWI prepared tree via NFS and use a
      <filename>config.<replaceable>MAC</replaceable></filename> file similar
      to the following example:
     </para>
<screen>NFSROOT=192.168.100.7;/tmp/kiwi.nfsroot</screen>
    </example>
   </sect2>
  </sect1>

  <sect1 id="sec.pxe.groups">
   <title>Hardware Grouping</title>

   <para>
    As explained in the section <xref linkend="sec.pxe.files"/>, three
    different types of configuration files containing image and deployment
    information exist: generic, client-specific and group-specific. This
    section explains how to set up groups and group-specific configuration
    files.
   </para>
   <para>
    Creating groups is useful if you have a subgroup of identical or similar
    clients that will use the same configuration file in an otherwise
    heterogeneous group of clients. Instead of creating and maintaining
    multiple
    <filename>config.<replaceable>MAC_ADDRESS</replaceable></filename> with
    identical content, you create a single
    <filename>config.<replaceable>GROUP</replaceable></filename> file.
   </para>
   <para>
    To add one or more groups requires to create a group definition file
    (<filename>config.group</filename> defining the groups and the clients
    belonging to each group, and a configuration file
    <filename>config.<replaceable>GROUP</replaceable></filename> for each
    group containing image and deployment information.
   </para>

   <sect2 id="sec.pxe.groups.def_file">
    <title>The Group Definition File</title>
    <para>
     The group definition file defines one or more groups and assigns client
     machines by MAC address to these groups. The file is name
     <filename>config.group</filename> and needs to be placed in <filename
     class="directory">/srv/tftpboot/KIWI/</filename> on the PXE boot server.
    </para>
    <para>
     The following example <filename>config.group</filename> defines three
     groups <replaceable>group1</replaceable>,
     <replaceable>group2</replaceable>, and <replaceable>group3</replaceable>
     and assigns two client machines to each group:
    </para>
    <screen>KIWI_GROUP="<replaceable>group1</replaceable>, <replaceable>group2</replaceable>, <replaceable>group3</replaceable>"

<replaceable>group1</replaceable>_KIWI_MAC_LIST="11:11:11:11:11:11, 00:11:00:11:22:CA"
"<replaceable>group2</replaceable>_KIWI_MAC_LIST="00:22:00:44:00:4D, 99:3F:21:A2:F4:32"
"<replaceable>group3</replaceable>_KIWI_MAC_LIST="00:54:33:FA:44:33, 84:3D:45:2F:5F:33"</screen>
    <para>
     The following parameters can be set in <filename>config.group</filename>:
    </para>

    <variablelist>
     <varlistentry>
      <term><literal>KIWI_GROUP</literal></term>
      <listitem>
       <para>
        Contains a list of groups that should be defined. At least one group
        name needs to be specified. The names are separated by a comma and a
        space. Although there is no limit for the number of groups, it should
        be kept to a minimum for reasonable manageability.
       </para>
       <para>
        Valid group names are made up of uppercase and lowercase letters, and
        may use numeric, and underscore characters. The same rules used to
        define Bash or sh variable names apply. The following example contains
        valid names:
       </para>
       <screen>KIWI_GROUP="group1, group2, group3"</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <literal><replaceable>GROUP_NAME</replaceable>_KIWI_MAC_LIST</literal>
      </term>
      <listitem>
       <para>
        This parameter is used to assign MAC addresses to the groups defined
        with <envar>KIWI_GROUP</envar>. The name of this parameter depends on
        the group it represents. In our example the groups <literal>group1,
        group2, group3</literal> are defined, so the corresponding parameters
        are:
       </para>
       <simplelist>
        <member><literal>group1_KIWI_MAC_LIST</literal></member>
        <member><literal>group2_KIWI_MAC_LIST</literal></member>
        <member><literal>group3_KIWI_MAC_LIST</literal></member>
       </simplelist>
       <para>
        These parameters contain a comma-separated list of MAC addresses that
        should be assigned to the specified group. MAC addresses always need to
        be specified with uppercase letters, otherwise they will not match.
        If the list of addresses is very long (several thousand entries), the
        client's boot process my be slowed down.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>

   <sect2 id="sec.pxe.groups.group_file">
    <title>The Group Configuration File</title>
    <para>
     In addition to the group definition file
     <filename>config.group</filename>, each defined group requires a
     <filename>config.<replaceable>GROUP_NAME</replaceable></filename> file
     containing the image and deployment information. Content-wise this file
     is identical to the <filename>config.default</filename> or
     <filename>config.<replaceable>MAC_ADDRESS</replaceable></filename>. See
     <xref linkend="sec.pxe.client-config-file"/> for details. These files
     need to be placed in <filename
     class="directory">/srv/tftpboot/KIWI/</filename> on the PXE server. For
     our example, the following files would be needed:
    </para>
    <screen>/srv/tftpboot/KIWI/config.group1
/srv/tftpboot/KIWI/config.group2
/srv/tftpboot/KIWI/config.group3</screen>

    <sect3 id="sec.pxe.groups.group_file.overrides">
     <title>Hardware-Specific Configuration Files</title>
     <para>
      Some scenarios may require to provide different system configuration
      files to clients belonging to the same hardware group: If grouping
      clients with similar hardware, but for example different graphic cards,
      it may be necessary to provide graphic card specific configuration
      files. If setting up a PXE server supporting different locations within
      your organization, you may want to deliver country specific
      configurations for the system language and the keyboard layout.
     </para>
     <para>
      The concept is similar to the one used with the group definition a
      configuration files. A list of MAC addresses that will receive
      individual configuration files is specified with two hardware mapping
      element in the group configuration file. A list of system configuration
      files for each hardware mapping element is specified in a hardware
      mapping configuration file.
     </para>
     <para>
      Using hardware specific configuration files within a group is
      optional. It allows to use a single group configuration file, but to
      provide additional configuration files that will override the defaults
      provided by the <literal>CONF</literal> parameter. The same
      functionality could theoretically also be achieved by specifying
      different groups using different CONF parameters, but that would be less
      flexible and produce an unnecessary maintenance overhead.
     </para>
     <sect4 id="sec.pxe.groups.group_file.overrides.hw_element">
      <title>The Hardware Mapping Elements</title>
      <para>
       To use the hardware linking mechanism, two additional elements
       needs to be added to the group details file
       (<filename>config.<replaceable>GROUP_NAME</replaceable></filename>. These
       two elements link hardware specific configurations to the appropriate
       systems by MAC address. A general example would look like this:
     </para>
<screen>HARDWARE_MAP="<replaceable>VENDORNAME_MODEL</replaceable>"
<replaceable>VENDORNAME_MODEL</replaceable>_HARDWARE_MAP="<replaceable>MAC1</replaceable><replaceable>MAC2</replaceable>"</screen>

     <para>
      The following parameters can be set in <filename>config.group</filename>:
     </para>
     <variablelist>
      <varlistentry>
       <term><literal>HARDWARE_MAP</literal></term>
       <listitem>
        <para>
         This element follows the same rules as defined by the KIWI_GROUP
         element. However, this variable will create sub-groups used to ensure
         multiple types of hardware vendors can be used within the same group.
         The name of the group(s) should be clearly defined, and a good
         convention to follow would be to use a combination of the vendor name
         with the model number or type. This would allow for cases where the
         same vendor is used, but differences between alternative models
         requires different maps to be used.
        </para>
        <screen>HARDWARE_MAP="myvendor_foo1000 myvendor_foo2000"</screen>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
       <literal><replaceable>HARDWARE_MAP_NAME</replaceable>_HARDWARE_MAP</literal></term>
       <listitem>
        <para>
         This element behaves identical to the
         <replaceable>GROUP_NAME</replaceable>_KIWI_MAC_LIST element. It lists
         all MAC addresses that need to be linked to a hardware map. Any host
         defined within the list will receive configuration files that have
         been specifically defined in a
         hardware_config.<replaceable>HARDWARE_MAP</replaceable> file (in
         addition to any files defined within a CONF element).
        </para>
        <screen>myvendor_foo1000_HARDWARE_MAP="11:11:11:11:11:11"
myvendor_foo2000_HARDWARE_MAP="00:11:00:11:22:CA"</screen>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect4>
    <sect4 id="sec.pxe.groups.group_file.overrides.hw_config">
     <title>The Hardware Mapping Configuration File</title>
     <para>
      When the hardware map has been defined, the last step is to ensure
      configuration specific elements are linked to the host(s) in question.
      This is done by creating a new
      hardware_config.<replaceable>hardware_map</replaceable> file.  The
      content of the file only contains one element
      <literal>VENDOR_CONF</literal>:
     </para>
<screen>VENDOR_CONF='CONFIGURATIONS/xorg.conf.<replaceable>hardware_name_model</replaceable>;/etc/X11/xorg.conf;192.168.100.2;4096'</screen>
     <para>
      The format of the VENDOR_CONF values is identical to the CONF
      variable used in the standard host and group configurations (see <xref
      linkend="sec.pxe.client-config-file"/>). In addition, files defined
      within this list will over-write any files defined in the group
      configuration, if and only if, the following requirements are met:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        The host is assigned to the current hardware map
       </para>
      </listitem>
      <listitem>
       <para>
        The file is defined within the CONF <emphasis>and</emphasis>
        VENDOR_CONF elements
       </para>
      </listitem>
     </itemizedlist>
     <para>
      NOTE: If a file is not defined in the CONF element, but is defined in
      the VENDOR_CONF element, it is simply downloaded to the host as if it
      was a CONF file. In this case, no overwriting will take place as it is
      considered a new file.
     </para>
    </sect4>
   </sect3>
   <sect3 id="sec.pxe.groups.group_file.overrides.example">
    <title>A Complete Example</title>
    <para>
     The following is an example of a group that is using hardware from
     multiple vendors. For this example, lets assume the group will have 10
     defined hosts, seven are <replaceable>myvendor_foo1000</replaceable> thin
     client, while the remaining three are
     <replaceable>myvendor_foo2000</replaceable> thin clients. We will also
     assume that the differences between the two hardware models are specific
     to the video card and therefore require different X drivers.
    </para>
    <para>
     The following configuration files in <filename>/srv/tftpboot/KIWI</filename>are required:
    </para>
    <screen>config.group<co id="hw_conf.group"/>
config.myvendor<co id="hw_conf.group_config"/>
hardware_config.myvendor_foo2000<co id="hw_conf.hw_details"/>
    </screen>
    <calloutlist>
     <callout arearefs="hw_conf.group">
      <para>
       <xref linkend="ex.pxe.groups.group_file.overrides.example.group"/>
      </para>
     </callout>
     <callout arearefs="hw_conf.group_config">
      <para>
       <xref linkend="ex.pxe.groups.group_file.overrides.example.group_config"/>
      </para>
     </callout>
     <callout arearefs="hw_conf.hw_details">
      <para>
       <xref linkend="ex.pxe.groups.group_file.overrides.example.hw_config"/>
      </para>
     </callout>
    </calloutlist>
    <example id="ex.pxe.groups.group_file.overrides.example.group">
     <title>The Group Definition File <filename>config.group</filename></title>
     <screen>KIWI_GROUP="myvendor"
myvendor_KIWI_MAC_LIST=
  "00:00:00:00:00:01 00:00:00:00:00:02 \
   00:00:00:00:00:03 00:00:00:00:00:04 \
   00:00:00:00:00:05 00:00:00:00:00:06 \
   00:00:00:00:00:07 00:00:00:00:00:08
   00:00:00:00:00:09 00:00:00:00:00:0A"</screen>
     <para>
      The example group definition file contains a single group
      (<literal>myvendor</literal>) containing the ten thin clients.
     </para>
    </example>
    <example id="ex.pxe.groups.group_file.overrides.example.group_config">
     <title>
      The Group Configuration File <filename>config.myvendor</filename>
     </title>
     <screen>KIWI_INITRD=/boot/initrd
KIWI_KERNEL=/boot/linux
DISK=/dev/sda
PART='5;S;x,769;L;/,x;L;x'
IMAGE='/dev/sda2;exmaple-kiosk-opensuse-##.#-pxe-client.i686;0.0.1;192.168.1.2;4096'
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,overlayfs
RELOAD_IMAGE=yes
RELOAD_CONFIG=yes
CONF='prefs.js;/home/kioskuser/.mozilla/firefox/07xvl1ty.default/prefs.js;192.168.1.2;4096,\
xorg.conf;/etc/X11/xorg.conf;192.168.1.2;4096'<co id="hw_conf.group_config.conf"/>
HARDWARE_MAP='myvendor_foo2000'<co id="hw_conf.group_config.hw_map"/>
myvendor_foo2000_HARDWARE_MAP='00:00:00:00:00:02 00:00:00:00:00:03 00:00:00:00:00:04'<co id="hw_conf.group_config.hw_clients"/></screen>
    <para>
     The first seven lines define a standard KIWI configuration, while the
     last three lines set up a hardware-specific configuration.
    </para>
    <calloutlist>
     <callout arearefs="hw_conf.group_config.conf">
      <para>
       Specifies two default configuration files that will be copied to all
       clients defined in this group: <filename>prefs.js</filename> (for
       Mozilla Firefox), and <filename>xorg.conf</filename> (for X Window).
      </para>
     </callout>
     <callout arearefs="hw_conf.group_config.hw_map">
      <para>
       Defines the hardware map(s) (<literal>myvendor_foo2000</literal> in
       this case) that are to be used to provide overrides for the
       configuration files defined in the previous lines.
      </para>
     </callout>
     <callout arearefs="hw_conf.group_config.hw_clients">
      <para>
       Defines the list of hosts (by MAC address) that will receive the
       configuration file overrides (the three myvendor_foo2000 clients).
      </para>
     </callout>
    </calloutlist>
    </example>
    <example id="ex.pxe.groups.group_file.overrides.example.hw_config">
     <title>
      The Hardware Mapping Details File
      <filename>hardware_config.myvendor_foo2000</filename>
     </title>

     <screen>VENDOR_CONF='xorg.conf.myvendor_foo2000;/etc/X11/xorg.conf;192.168.1.2;4096,\
someconfig.cfg;/etc/sysconfig/someconfig.cfg;192.168.1.2;4096'</screen>
    <para>
     When the VENDOR_CONF definition is used, we are telling KIWI that all
     files defined within this element, are specific to the hardware map they
     are linked to. As a result, all files listed here will be transferred to
     a host if, and only if, the host has been linked to the hardware map via
     the myvendor_foo2000_HARDWARE_MAP element. In our example the only
     systems that will receive the xorg.conf.myvendor_foo2000 file will be the
     three myvendor_foo2000 thin clients listed in the hardware map itself.
    </para>
    <para>
     In this VENDOR_CONF element, two files are defined. An override
     <filename>xorg.conf</filename> file and an additional file called
     <filename>someconfig.cfg</filename>.
     <filename>xorg.conf.myvendor_foo2000</filename> will overwrite the
     <filename>xorg.conf</filename> file that was previously transferred via
     the CONF element. In addition to that, <filename>someconfig.cfg</filename>
     will be copied to the three myvendor_foo2000 thin clients.
    </para>
    </example>
    <para>
     As a result of this example, all ten thin clients will receive the
     <filename>prefs.js</filename> file defined in
     <literal>CONF</literal>. The seven myvendor_foo1000 clients will receive the
     <filename>xorg.conf</filename> defined in <literal>CONF</literal>, while
     the three myvendor_foo2000 clients will receive the specific
     <filename>xorg.conf</filename> defined in
     <literal>VENDOR_CONF</literal>. The myvendor_foo2000 clients will also
     get the file <filename>someconfig.cfg</filename>.
    </para>
   </sect3>
  </sect2>
 </sect1>
</chapter>
