<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>openSUSE-KIWI Image System</title><link rel="stylesheet" type="text/css" href="susebooks.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="idm140065377360480"></a>openSUSE-KIWI Image System</h1></div><div><h2 class="subtitle">Cookbook</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Marcus</span> <span class="surname">Schäfer</span></h3><span class="contrib">Project, Design and Implementation</span> <div class="affiliation"><span class="jobtitle">Software Engineer<br></span><span class="orgname">SUSE LINUX Products GmbH<br></span></div><code class="email">&lt;<a class="email" href="mailto:ms@suse.de">ms@suse.de</a>&gt;</code></div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Thomas</span> <span class="surname">Schraitle</span></h3><span class="contrib">Various text improvements, migration to DocBook</span> <div class="affiliation"><span class="jobtitle">Documentation Specialist<br></span><span class="orgname">SUSE LINUX Products GmbH<br></span></div><code class="email">&lt;<a class="email" href="mailto:toms@suse.de">toms@suse.de</a>&gt;</code></div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Robert</span> <span class="surname">Schweikert</span></h3><span class="contrib">Various text improvements, implementation</span> <div class="affiliation"><span class="orgname">SUSE LLC<br></span></div><code class="email">&lt;<a class="email" href="mailto:rjschwei@suse.com">rjschwei@suse.com</a>&gt;</code></div></div></div><div><p class="releaseinfo">KIWI Version 7.03</p></div><div><div class="legalnotice"><a name="idm140065376661008"></a><p class="legalnotice-title"><b>License</b></p><p>Permission is granted to copy, distribute and/or modify this
    document under the terms of the GNU Free Documentation License,
    Version 1.2 or (at your option) version 1.3; with the Invariant
    Section being this copyright notice and license. A copy of the
    license version 1.2 is included in the appendix entitled <span class="quote">“<span class="quote">GNU
      Free Documentation License</span>”</span>.</p><p><span class="trademark">SUSE</span>®, <span class="trademark">openSUSE</span>®, the <span class="trademark">openSUSE</span>® logo, <span class="trademark">Novell</span>®, the <span class="trademark">Novell</span>® logo, the <span class="trademark">N</span>® logo, are registered trademarks
    of Novell, Inc. in the United States and other countries. <span class="trademark">Linux</span>® is a registered trademark of
    Linus Torvalds. All other third party trademarks are the property of
    their respective owners.</p><p>All information found in this book has been compiled with utmost
    attention to detail. However, this does not guarantee complete
    accuracy. Neither Novell, Inc., SUSE Linux Products GmbH, the
    authors, nor the translators shall be held liable for possible
    errors or the consequences thereof.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="part"><a href="#idm140065377416864">I. Concepts and Basics</a></span></dt><dd><dl><dt><span class="chapter"><a href="#chap.introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.introduction.whatiskiwi">1.1. What is KIWI?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.whatdoeskiwido">1.2. What does KIWI do?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.howtousekiwi">1.3. How do I use KIWI?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.installation">2. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.installation.rpminstall">2.1. Installing using Packages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.installation.reops">2.1.1. Package Repositories</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.installation.fromsource">2.2. Running from Source</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.workflow">3. Basic Workflow</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.workflow.introduction">3.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.buildprocess">3.2. Build Process</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootprocess">3.3. Boot Process</a></span></dt><dt><span class="sect1"><a href="#sec.hooks">3.4. Boot Image Hook-Scripts</a></span></dt><dt><span class="sect1"><a href="#sec.bootcustomization">3.5. Boot Image Customization</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootparameters">3.6. Boot Parameters</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">3.7. Common and Distribution Specific Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.caches">4. Image Caches</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.caches.introduction">4.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.caches.example">4.2. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.description">5. KIWI Image Description</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.description.config.xml">5.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">5.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">5.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">5.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">5.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">5.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">5.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">5.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">5.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.appliance">6. Creating Appliances with KIWI</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.appliance.overview">6.1. Overview</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">6.2. The KIWI Model</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.crossplatform">6.3. Cross Platform Appliance Build</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#idm140065370654800">II. Usecases</a></span></dt><dd><dl><dt><span class="chapter"><a href="#chap.maintenance">7. Maintenance of Operating System Images</a></span></dt><dt><span class="chapter"><a href="#chap.migration">8. System Analysis/Migration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.migrate.create-clean-repository">8.1. Create a Clean Repository Set First</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.watch-overlay">8.2. Watch the Custom Files</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.checklist">8.3. Checklist</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.turn-system-into-image">8.4. Turn Into an Image…</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.iso">9. ISO Image / Live System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.iso.building">9.1. Building a live JeOS</a></span></dt><dt><span class="sect1"><a href="#sec.iso.using">9.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.iso.flavours">9.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">9.3.1. Split mode</a></span></dt><dt><span class="sect2"><a href="#sec.iso.hybrid-mode">9.3.2. Hybrid mode</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm140065370543536">9.4. USB stick images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm140065370540736">9.4.1. ISO Hybrid stick</a></span></dt><dt><span class="sect2"><a href="#idm140065370537040">9.4.2. OEM USB stick</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.vmx">10. VMX Image / Virtual Disks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vmx.building">10.1. Building a JeOS disk</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.using">10.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.flavours">10.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.vmx.vmware-support">10.3.1. VMware support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.lvm">10.3.2. LVM Support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.bootpartition">10.3.3. Extra Boot Partition</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.lxc">11. Linux Containers and Docker</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.lxc.building">11.1. Building a docker image</a></span></dt><dt><span class="sect1"><a href="#sec.lxc.using">11.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.lxc.details">11.3. Image Configuration Details</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.vagrant">12. Vagrant boxes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vagrant.building">12.1. Building a Base Box</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.box.details">12.2. Box Configuration Details</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.box.using">12.3. Using the box</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.docker">12.4. Vagrant with Docker</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.pxe">13. PXE Image / Thin Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.pxe.setting-up">13.1. Setting Up the Required Services</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.atftp-server">13.1.1. Atftp Server</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.dhcp-server">13.1.2. DHCP Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.building">13.2. Building a PXE filesystem JeOS</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.using">13.3. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.flavours">13.4. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.client-control-file">13.4.1. The PXE Client Control File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.client-config-file">13.4.2. The PXE Client Configuration File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.another-user">13.4.3. Use Different Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">13.4.4. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">13.4.5. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">13.4.6. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nfs">13.4.7. Root Tree Over NFS</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nbd">13.4.8. Root Tree Over NBD</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-aoe">13.4.9. Root Tree Over AoE</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">13.5. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm140065370084736">13.5.1. The Group Configuration File</a></span></dt><dt><span class="sect2"><a href="#idm140065370066736">13.5.2. The Group Details File</a></span></dt><dt><span class="sect2"><a href="#idm140065370056272">13.5.3.  Using Hardware Mapping to Provide Overrides</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.oem">14. OEM Image / Preload Systems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.oem.building">14.1. Building an OEM System with Installation DVD</a></span></dt><dt><span class="sect1"><a href="#sec.oem.using">14.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">14.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.installation">14.3.1. Specializing the OEM install process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partitioning">14.3.2. Influencing the OEM Partitioning</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">14.3.3. Partition Based Installation</a></span></dt><dt><span class="sect2"><a href="#sec.oem.pxe-based-installation">14.3.4. Network Based Installation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.xen">15. Xen Para- and Full virtual Images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.xen.dom0.building">15.1. Building a Dom0</a></span></dt><dt><span class="sect1"><a href="#sec.xen.dom0.using">15.2. Using the Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.pv.building">15.3. Building a Para Virtual Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.hvm.building">15.4. Building a Full Virtual Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">15.5. Using the Guest Images</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.raid">16. KIWI RAID Support</a></span></dt><dt><span class="chapter"><a href="#chap.partitions">17. KIWI Custom Partitions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#chap.partitions.lvm">17.1. Custom Partitioning via LVM</a></span></dt><dt><span class="sect1"><a href="#chap.partitions.btrfs">17.2. Custom Partitioning via Btrfs</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.encryption">18. KIWI Encryption Support </a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix">A. KIWI Man Pages</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwi">kiwi</a></span><span class="refpurpose"> — Creating Operating System Images</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.config.sh">kiwi::config.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.images.sh">kiwi::images.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwirc">kiwi::kiwirc</a></span><span class="refpurpose"> — Resource file for the Kiwi imaging system</span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>3.1. <a href="#fig.imagecreationarch">Image Creation Architecture</a></dt><dt>3.2. <a href="#fig.imagetypes">Image Types</a></dt><dt>3.3. <a href="#fig.workflow.imagedescriptions">Image Descriptions</a></dt><dt>4.1. <a href="#fig.imagecachingarch">Image Caching Architecture</a></dt><dt>5.1. <a href="#fig.description.imagedescrdir">Image Description Directory</a></dt><dt>7.1. <a href="#fig.maintain">Image Maintenance Scenarios</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>5.1. <a href="#tab.description.supported-types">Supported package manager repo types</a></dt><dt>10.1. <a href="#tab.vmx.supported-disk-formats">Supported Virtual Disk Formats</a></dt><dt>13.1. <a href="#tab.configuration.files.synchronization">Configuration files synchronization possibilities</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>A.1. <a href="#idm140065369529296">Template for config.sh</a></dt><dt>A.2. <a href="#idm140065369404144">Template for images.sh</a></dt><dt>A.3. <a href="#idm140065369334112">Template for .kiwi.rc</a></dt></dl></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="idm140065377416864"></a>Part I. Concepts and Basics</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#chap.introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.introduction.whatiskiwi">1.1. What is KIWI?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.whatdoeskiwido">1.2. What does KIWI do?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.howtousekiwi">1.3. How do I use KIWI?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.installation">2. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.installation.rpminstall">2.1. Installing using Packages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.installation.reops">2.1.1. Package Repositories</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.installation.fromsource">2.2. Running from Source</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.workflow">3. Basic Workflow</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.workflow.introduction">3.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.buildprocess">3.2. Build Process</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootprocess">3.3. Boot Process</a></span></dt><dt><span class="sect1"><a href="#sec.hooks">3.4. Boot Image Hook-Scripts</a></span></dt><dt><span class="sect1"><a href="#sec.bootcustomization">3.5. Boot Image Customization</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootparameters">3.6. Boot Parameters</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">3.7. Common and Distribution Specific Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.caches">4. Image Caches</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.caches.introduction">4.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.caches.example">4.2. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.description">5. KIWI Image Description</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.description.config.xml">5.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">5.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">5.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">5.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">5.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">5.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">5.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">5.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">5.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.appliance">6. Creating Appliances with KIWI</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.appliance.overview">6.1. Overview</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">6.2. The KIWI Model</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.crossplatform">6.3. Cross Platform Appliance Build</a></span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.introduction"></a>Chapter 1. Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.introduction.whatiskiwi">1.1. What is KIWI?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.whatdoeskiwido">1.2. What does KIWI do?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.howtousekiwi">1.3. How do I use KIWI?</a></span></dt></dl></div><a class="indexterm" name="idm140065376272224"></a><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.introduction.whatiskiwi"></a>1.1. What is KIWI?<span class="permalink"><a alt="Permalink" title="1.1. What is KIWI?" href="#sec.introduction.whatiskiwi">¶</a></span></h2></div></div></div><p>KIWI is an image build system for Linux.</p><p>A Linux image may present itself in many different formats,
    for example the <code class="filename">*.iso</code><a class="indexterm" name="idm140065377526592"></a> file you
    download to burn a distribution installation file to optical media is an
    image. A file used by virtualization systems such as KVM, Xen, or VMware
    is an image. The installation of a Linux system on your hard drive can be
    turned into an image using the <span class="command"><strong>dd</strong></span> command.</p><p>Basically, you can think of an image as a Linux system in a file.
    Depending on the type of the image you are dealing with you have different
    options for using the image. For example you can burn an ISO image to
    optical media and then boot your computer from the CD/DVD, or you can run
    a Virtual Machine from the <code class="filename">*.iso</code><a class="indexterm" name="idm140065377522944"></a>
    file (image) stored on your hard drive.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.introduction.whatdoeskiwido"></a>1.2. What does KIWI do?<span class="permalink"><a alt="Permalink" title="1.2. What does KIWI do?" href="#sec.introduction.whatdoeskiwido">¶</a></span></h2></div></div></div><p>KIWI builds images in a variety of formats.</p><p>As an image build tool, KIWI builds images in a relatively large
    number of supported image formats. The details of the image creation
    process are explained in the <a class="xref" href="#chap.workflow" title="Chapter 3. Basic Workflow">Chapter 3, <i>Basic Workflow</i></a> chapter. The
    image format of the image produced by KIWI is defined within a
    configuration file named <code class="filename">config.xml</code>
    or <code class="filename">*.kiwi</code> as described in
    <a class="xref" href="#chap.description" title="Chapter 5. KIWI Image Description">Chapter 5, <i>KIWI Image Description</i></a>.</p><p>Note that not all elements and attributes that may be used in
    the KIWI <code class="filename">config.xml</code> configuration file are listed
    or described in this document. The complete schema documentation
    can be accessed on the web at
    <a class="ulink" href="http://doc.opensuse.org/projects/kiwi/schema-doc/" target="_top">http://doc.opensuse.org/projects/kiwi/schema-doc/</a>, latest
    version, or on your local system using the <code class="filename">
    file:///usr/share/doc/packages/kiwi/schema/kiwi.html</code> path
    as the URL in the browser.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.introduction.howtousekiwi"></a>1.3. How do I use KIWI?<span class="permalink"><a alt="Permalink" title="1.3. How do I use KIWI?" href="#sec.introduction.howtousekiwi">¶</a></span></h2></div></div></div><p>KIWI is a command line tool that is invoked with the
    <span class="command"><strong>kiwi</strong></span> command in your shell. KIWI needs to be executed
    as the <code class="systemitem">root</code><a class="indexterm" name="idm140065377499072"></a> user, as administrative privileges are
    required for many operations that need to take place to create an image.
    Therefore, when using KIWI you need to be aware of what you are doing and
    a certain amount of caution is in order. Running KIWI on your system is
    not inherently dangerous to your system, just keep in mind that you are
    running as the <code class="systemitem">root</code><a class="indexterm" name="idm140065377496752"></a> user.</p><p>An image is created in a two step process as described in the
    <a class="xref" href="#chap.workflow" title="Chapter 3. Basic Workflow">Chapter 3, <i>Basic Workflow</i></a> chapter. Use
    <span class="command"><strong>kiwi --prepare</strong></span> for the first step and
    <span class="command"><strong>kiwi --create</strong></span> for the second step. For user convenience
    KIWI also has the <code class="option">--build</code> that combines the
    <span class="emphasis"><em>prepare</em></span> and <span class="emphasis"><em>create</em></span> steps.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.installation"></a>Chapter 2. Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.installation.rpminstall">2.1. Installing using Packages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.installation.reops">2.1.1. Package Repositories</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.installation.fromsource">2.2. Running from Source</a></span></dt></dl></div><a class="indexterm" name="idm140065377490432"></a><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.installation.rpminstall"></a>2.1. Installing using Packages<span class="permalink"><a alt="Permalink" title="2.1. Installing using Packages" href="#sec.installation.rpminstall">¶</a></span></h2></div></div></div><p>Once you have added the appropriate repositories (more on
      this below) to your system you can search for the kiwi packages through
      the YaST interface or using <span class="command"><strong>zypper</strong></span> as shown
      below.</p><pre class="screen"><span class="command"><strong>zypper</strong></span> se kiwi</pre><p>The list of packages returned by zypper contains the main package,
      simply named <code class="filename">kiwi-</code>, the
      <code class="filename">-doc</code> package containing the documentation files,
      and  the <code class="filename">-desc-</code> packages containing the boot
      descriptions for the various image types. Installing this set of
      packages is sufficient to build your images.</p><p>Adding repositories to your system can be accomplished using the
      YaST interface or the <span class="command"><strong>zypper ar</strong></span> command.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.installation.reops"></a>2.1.1. Package Repositories<span class="permalink"><a alt="Permalink" title="2.1.1. Package Repositories" href="#sec.installation.reops">¶</a></span></h3></div></div></div><p>The simplest and most straight forward way to install KIWI is
        to use the packages that are provided in the Virtualization:Appliances
        project on the web here: <code class="filename">http://download.opensuse.org/repositories/Virtualization:/Appliances/</code></p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.installation.fromsource"></a>2.2. Running from Source<span class="permalink"><a alt="Permalink" title="2.2. Running from Source" href="#sec.installation.fromsource">¶</a></span></h2></div></div></div><p>KIWI is developed and maintained in a git repository on GitHub.
      You can clone the source code using the following command.</p><pre class="screen"><span class="command"><strong>git</strong></span> clone https://github.com/openSUSE/kiwi.git</pre><p>Before running from source you want to verify that all the
      dependencies are satisfied. The best way to accomplish this is to
      install all packages listed as <span class="emphasis"><em>BuildRequires</em></span>
      in the <code class="filename">.spec</code> file found in the
      <code class="filename">rpm</code> directory. Once all dependent packages are
      installed change your working directory to the
      <code class="filename">kiwi</code> directory and run kiwi as follows:
      </p><pre class="screen"><span class="command"><strong>./kiwi</strong></span></pre><p>The KIWI self tests are executed using:</p><pre class="screen"><span class="command"><strong>make</strong></span> test</pre><p>If you want to refresh your source with the latest checked in code
      you can simply pull the latest sources from the GitHub repository
      using the command shown below.</p><pre class="screen"><span class="command"><strong>git</strong></span> pull</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.workflow"></a>Chapter 3. Basic Workflow</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.workflow.introduction">3.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.buildprocess">3.2. Build Process</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootprocess">3.3. Boot Process</a></span></dt><dt><span class="sect1"><a href="#sec.hooks">3.4. Boot Image Hook-Scripts</a></span></dt><dt><span class="sect1"><a href="#sec.bootcustomization">3.5. Boot Image Customization</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootparameters">3.6. Boot Parameters</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">3.7. Common and Distribution Specific Code</a></span></dt></dl></div><a class="indexterm" name="idm140065371663728"></a><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.introduction"></a>3.1. Introduction<span class="permalink"><a alt="Permalink" title="3.1. Introduction" href="#sec.workflow.introduction">¶</a></span></h2></div></div></div><p>KIWI creates images in a two step process, as mentioned previously.
    The first step, the <span class="emphasis"><em>prepare</em></span> operation, generates a
    so called <span class="emphasis"><em>unpacked image</em></span> tree (directory) using
    the information provided in the <code class="filename">config.xml</code>
    configuration file. The <code class="filename">config.xml</code> file is part of the
    <span class="emphasis"><em>configuration directory (tree)</em></span> that describes the
    image to be created by KIWI. The second step, the
    <span class="emphasis"><em>create</em></span> operation, creates the
    <span class="emphasis"><em>packed image</em></span> or <span class="emphasis"><em>image</em></span> in the
    specified format based on the unpacked image and the information
    provided in the <code class="filename">config.xml</code> stored inside of the
    unpacked image below the <code class="filename">image/</code> directory.
    </p><div class="figure"><a name="fig.imagecreationarch"></a><p class="title"><b>Figure 3.1. Image Creation Architecture</b><span class="permalink"><a alt="Permalink" title="Figure 3.1. Image Creation Architecture" href="#fig.imagecreationarch">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/intro.png" alt="Image Creation Architecture"></div></div></div><br class="figure-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">(1) Unpacked Image</span></dt><dd><p>
	Encapsulated system reachable via chroot
       </p></dd><dt><span class="term">(2) Packed Image</span></dt><dd><p>
	Encapsulated system reachable via kernel filesystem/extension drivers
       </p></dd></dl></div><p>Prior to building an image with KIWI it is important to understand
    the composition of an image, the general concepts of Linux,
    including the boot process, and distribution concepts such as package
    management.</p><p>Installation of a Linux system generally occurs by booting a target
    system from an installation source such as an install CD/DVD, a live
    CD/DVD, or entering the PXE boot environment. The installation process is
    often driven by an installer that interacts with the user to collect
    collect information about the installation. This information generally
    includes the <span class="emphasis"><em>software to be installed</em></span>, the 
    <span class="emphasis"><em>timezone</em></span>, system <span class="emphasis"><em>user</em></span> data,
    and other information. Once all the information is collected the installer
    installs the necessary and specified software onto the target system using
    packages from the available software sources (repositories). After the
    installation is complete the system generally reboots and enters a
    configuration procedure upon startup. The configuration may be fully
    automatic or it may include user interaction.</p><p>A system image, or image, is a
    <span class="emphasis"><em>complete installation</em></span> of a Linux system in a
    file. The image represents an operational system and may or may not
    contain the "final" configuration. The behavior of the image upon
    deployment varies depending on image type and image configuration. With
    KIWI it is possible to completely customize the initial start up behavior
    of the image. This may include behavior that allows the image to simply
    be deployed inside an existing virtual environment with no required
    configuration at start up. It is also possible to create images that
    automatically configure themselves in a known target environment. Further,
    the startup of an interactive configuration procedure can be integrated
    into the image to allow the user to configure the image when it is booted
    for the first time. The image configuration possibilities are practically
    unlimited. The image creation process with KIWI is automated and does not
    require any user interaction. The required information for the image
    creation process is provided in the primary configuration file named
    <code class="filename">config.xml</code>. The image can optionally be customized
    using the <code class="filename">config.sh</code> and
    <code class="filename">images.sh</code> scripts. Additional customization can
    be accomplished with the use of an optional
    <span class="emphasis"><em>overlay tree (directory)</em></span> called
    <code class="filename">root</code>. The configuration information is stored
    in the so called <span class="emphasis"><em>image description</em></span> or
    <span class="emphasis"><em>configuration directory (tree)</em></span>.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.buildprocess"></a>3.2. Build Process<span class="permalink"><a alt="Permalink" title="3.2. Build Process" href="#sec.workflow.buildprocess">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065371638064"></a><a class="indexterm" name="idm140065371636672"></a><p>The creation of an image with KIWI is a two step process, the
    first step is called the <span class="emphasis"><em>prepare</em></span> step and it
    must complete successfully before the second step, the
    <span class="emphasis"><em>create</em></span> step can be executed. During the prepare
    step KIWI creates a new root tree or so called
    <span class="emphasis"><em>unpacked image</em></span>. The new root tree is created in a
    directory specified on the command line with the <code class="option">--root</code>
    argument or the value of the <code class="sgmltag-element">defaultroot</code>
    element in the <code class="filename">config.xml</code> file. This directory
    will be the target for any software packages to be installed during the
    image creation process. For package installation KIWI relies on the
    package manager specified with the
    <code class="sgmltag-element">packagemanager</code> element in the
    <code class="filename">config.xml</code> file. KIWI supports the
    <span class="emphasis"><em>smart</em></span>, <span class="emphasis"><em>zypper</em></span>,
    <span class="emphasis"><em>yum</em></span> and <span class="emphasis"><em>apt</em></span> package
    managers. The prepare step executes the following major stages: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Create Target Root Directory. </b><a class="indexterm" name="idm140065371627808"></a>KIWI will exit with an error if the target root tree
          already exists to prevent accidental deletion of an existing
          unpacked image. Using the <code class="option">--force-new-root</code>
          command line argument will force kiwi to delete the existing
          target directory and create a new unpacked image in a new
          directory with the same name.</p></li><li class="listitem"><p><b>Install Packages. </b><a class="indexterm" name="idm140065371624128"></a>Initially KIWI configures the package manager
          (zypper by default) to be used for the image creation to use
          the repositories specified in the configuration file and/or
          specified on the command line. Following the repository setup the
          packages specified in the
          <code class="sgmltag-attribute">bootstrap</code><a class="indexterm" name="idm140065371621664"></a> section are installed
          in a temporary workspace external to the target root tree. This
          establishes the initial environment, to support the completion
          of the process in chroot setting. The essential packages to
          specify as part of the bootstrap environment are the
          <span class="emphasis"><em>filesystem</em></span> and
          <span class="emphasis"><em>glibc-locale</em></span> packages. The dependency chain
          of these two packages is sufficient to populate the bootstrap
          environment with all required software to support the installation
          of packages into the new root tree. The installation of software
          packages through the selected package manager may install packages
          that you do not want in your image. Removing undesired packages
          can be accomplished by specifying the packages you would like to
          remove from the image as children of a
          <code class="sgmltag-element">packages</code> element where the
          value of the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065371617776"></a> attribute
          of the <code class="sgmltag-element">packages</code> element is
          set to <code class="sgmltag-attvalue">delete</code>.</p></li><li class="listitem"><p><b>Apply The Overlay Tree. </b><a class="indexterm" name="idm140065371614240"></a>After the package installation with the package manager is
           complete, KIWI will apply all files and directories present in the
           overlay directory named <span class="emphasis"><em>root</em></span> inside the
           configuration directory to the target root tree. This allows
           you to over write any file that was installed by one of the
           packages installed during the installation phase. Files and
           directories will appear in the unpacked image tree in the same
           location as they are found in the directory named
           <span class="emphasis"><em>root</em></span>.</p></li><li class="listitem"><p><b>Apply Archives. </b><a class="indexterm" name="idm140065371609968"></a>Any archives specified with the
           <code class="sgmltag-element">archive</code> element in the
           <code class="filename">config.xml</code> file are applied in the 
           specified order (top to bottom) after the overlay tree copy
           operation is complete. Archives are unpacked at the top level of
           the new root tree and files will be located according to their
           path in the archive. As with the overlay tree, it is possible to
           over write any file in the target root tree.</p></li><li class="listitem"><p><b>Execute User Defined config.sh Script. </b><a class="indexterm" name="idm140065371605392"></a>At the end of the preparation stage the optional script
          named <code class="filename">config.sh</code> is executed at the root
          level of the target root tree. The primary intended use of this
          script is to complete system configuration such as service
          activation. For detailed description pre-defined configuration
          functions consult the <a class="xref" href="#ref.kiwi.config.sh" title="kiwi::config.sh"><span class="refentrytitle">kiwi::config.sh</span>(1)</a>
          man page.</p></li><li class="listitem"><p><b>Manage The New Root Tree. </b><a class="indexterm" name="idm140065371600960"></a>The unpacked image directory is just a directory, as far as the
          build system is concerned and you can manipulate the content of
          this directory to your liking. Further, as this directory
          represents a system installation you can chroot into this directory
          and run in the chroot environment to make changes. However,
          it is strongly discouraged to apply changes directly to the
          unpacked root, as any changes you apply will be lost when the
          <span class="emphasis"><em>prepare</em></span> step for the image is repeated.
          In addition you may introduce errors into the unpacked root tree
          that may lead to very difficult to track kiwi build issues
          during the <span class="emphasis"><em>create</em></span> step of the image build
          process. The best practice is to apply any necessary changes to
          the configuration directory followed by a new prepare
          operation. If you inspect the created unpacked root tree you will
          find a directory named <code class="filename">image</code><a class="indexterm" name="idm140065371596784"></a>
          at the top level that you would not find on a system installed
          with the distribution installer. This directory contains information
          KIWI requires during the create step, including a copy of the
          <code class="filename">config.xml</code> file. You can make modifications
          to data in this directory to influence the create step, however,
          as mentioned previously this is discouraged and changes will be lost
          once the prepare step is repeated.</p></li></ul></div><p>Successful completion of the <span class="emphasis"><em>prepare</em></span> step
    is a the pre-requisite for the <span class="emphasis"><em>create</em></span> step of the
    image build process. With the successful completion of the image
    preparation the unpacked root tree is considered complete and consistent.
    Creating the packed, or final image requires the execution of the
    <span class="emphasis"><em>create</em></span> step. Multiple images can be created using
    the same unpacked root tree, for example it is possible to create
    a self installing OEM image and a virtual machine image from
    one unpacked root tree, under the condition that both image types
    are specified in the <code class="filename">config.xml</code> when the prepare
    step is executed. During the <span class="emphasis"><em>create</em></span> step the
    following major operations are performed by kiwi:</p><div class="itemizedlist"><a class="indexterm" name="idm140065371590704"></a><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Execute User Defined images.sh Script. </b><a class="indexterm" name="idm140065371588416"></a>At the beginning of the image creation process the optional
          <code class="filename">images.sh</code> script is executed at the top level
          of the unpacked image directory. Unlike the
          <code class="filename">config.sh</code> script, the
          <code class="filename">images.sh</code> script does not have a target use
          case. The script is most often used to remove files that are no
          needed in the final image. For example if an appliance is being
          built that is targeted for specific hardware one can remove all
          unnecessary kernel drivers from the image using this script. 
          Consult the <a class="xref" href="#ref.kiwi.images.sh" title="kiwi::images.sh"><span class="refentrytitle">kiwi::images.sh</span>(1)</a> man page for
          a detailed description of pre-defined functions available in
          the <code class="filename">images.sh</code> script.</p></li><li class="listitem"><p><b>Create Requested Image Type. </b><a class="indexterm" name="idm140065371581824"></a>The image types that can be created from a prepared image tree
          depend on the types specified in the image description
          <code class="filename">config.xml</code> file. The configuration file
          must contain contain at least one
          <code class="sgmltag-element">type</code> element. The figure below
          shows the currently image types:</p><div class="figure"><a name="fig.imagetypes"></a><p class="title"><b>Figure 3.2. Image Types</b><span class="permalink"><a alt="Permalink" title="Figure 3.2. Image Types" href="#fig.imagetypes">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/types.png" alt="Image Types"></div></div></div><br class="figure-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">(1) Live Image</span></dt><dd><p>
	  From CD, DVD or USB stick
	 </p></dd><dt><span class="term">(2) Disk Image</span></dt><dd><p>
	  Virtual system than can be used in VMware, Xen, Amazon Cloud, KVM,
	  etc. virtual environments. Depending on the format a guest
	  configuration file is created.
	 </p></dd><dt><span class="term">(3) OEM Image</span></dt><dd><p>
	  Preload system for install media CD/DVD or USB stick
	 </p></dd><dt><span class="term">(4) PXE Image</span></dt><dd><p>
	  Network boot image. KIWI also provides the bootp environment via the
	  package kiwi-pxeboot.
	 </p></dd></dl></div></li></ul></div><p>Detailed information, including step by step instructions about using
  the <span class="command"><strong>kiwi</strong></span> command and building specific images, as
  well as the configuration of the supported image types is provided
  later.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.bootprocess"></a>3.3. Boot Process<span class="permalink"><a alt="Permalink" title="3.3. Boot Process" href="#sec.workflow.bootprocess">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065371564320"></a><p>Most Linux systems use a special boot image to control
      the system boot process after the system firmware, BIOS or UEFI,
      hands control of the hardware to the operating system. This boot image
      is called the <span class="emphasis"><em>initrd</em></span>. The Linux kernel loads the
      initrd, a compressed cpio initial ramdisk, into RAM and executes
      <span class="emphasis"><em>init</em></span> or, if present, <span class="emphasis"><em>linuxrc</em></span>.
      KIWI creates the boot image automatically depending on the image type 
      as part of the <span class="emphasis"><em>create</em></span>
      step in the image build process. Each image type has a specialized
      image description that describes the boot image. Common functionality is
      shared between the boot images through a set of functions. The boot image
      descriptions follow the same principles as the system image descriptions
      and are provided by KIWI. The boot image descriptions provided by KIWI
      cover almost all use cases and it should not be necessary for the majority
      of KIWI users to implement their own boot descriptions.</p><div class="figure"><a name="fig.workflow.imagedescriptions"></a><p class="title"><b>Figure 3.3. Image Descriptions</b><span class="permalink"><a alt="Permalink" title="Figure 3.3. Image Descriptions" href="#fig.workflow.imagedescriptions">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/activation.png" alt="Image Descriptions"></div></div></div><br class="figure-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">(1) Boot Image</span></dt><dd><p>
      Boot image descriptions are provided by KIWI, use is recommended but not
      required.
     </p></dd><dt><span class="term">(2) System Image</span></dt><dd><p>
      The system image description is created by the KIWI user, or a KIWI
      provided template may be used.
     </p></dd></dl></div><p>The boot image descriptions are stored in the
    <code class="filename">/usr/share/kiwi/image/*boot</code><a class="indexterm" name="idm140065371550688"></a>
    directories. KIWI selects the boot image to build based on the value of
    the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065371549088"></a> attribute of the
    <code class="sgmltag-element">type</code> element. The attribute value is
    expected in the general form of <span class="emphasis"><em>
    <em class="replaceable"><code>boottype</code></em>/<em class="replaceable"><code>distribution</code></em>
    </em></span>. For example to select the OEM boot image for SLES
    version 12 the value of the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065371545632"></a>
    attribute should be <code class="sgmltag-attvalue">oemboot/suse-SLES12</code>.
    The boot image description only represent the initrd and as such serves
    a limited purpose. The system image description created by the person
    building the image is ultimately the image that runs on the target system.
    Boot image descriptions are complete and consistent descriptions that
    allow you to build the boot image outside of the system image build
    process.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.hooks"></a>3.4. Boot Image Hook-Scripts<span class="permalink"><a alt="Permalink" title="3.4. Boot Image Hook-Scripts" href="#sec.hooks">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065371542464"></a><a class="indexterm" name="idm140065371541072"></a><p>All KIWI created boot images contain kiwi boot code that gets
        executed when the image is booted for the first time. This boot
        code is different for the various image types and provides hooks
        to execute user defined custom shell scripts. The shell scripts
        provided by the user may extend the first boot process and are
        expected to exist inside the boot image in a specific location with
        specific names. The naming and timing of the execution of
        the hook scripts is image type dependent and described later.
        The instructions below explain the concepts of hook scripts, which is
        common to all image types, and how to include the scripts
        in the initrd.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>All hook scripts must be located in the <code class="filename">kiwi-hooks</code><a class="indexterm" name="idm140065371537424"></a> directory at the top
          level of the initrd. The best approach to including the hook
          scripts in the initrd is to create an archive of a <code class="filename">kiwi-hooks</code><a class="indexterm" name="idm140065371535504"></a> directory that
          contains the custom boot scripts.
      </p><pre class="screen"><span class="command"><strong>mkdir</strong></span> kiwi-hooks
--&gt; place all scripts inside kiwi-hooks
<span class="command"><strong>tar</strong></span> -cf kiwi-hooks.tgz kiwi-hooks/</pre><p>
          The tarball must be located at the top level of the image
          description directory, this is the same level that contains
          the <code class="filename">config.xml</code> file.</p></li><li class="listitem"><p>Hook scripts are executed using a predetermined name that
            is hard coded into the kiwi boot code. This name is extended
            using the <code class="filename">.sh</code> extension and differs by
            boot image type. Therefore, the boot script naming in the archive
            must be exact. Boot scripts are sourced in the kiwi boot code. This
            provides the hook script access to all variables set in the boot
            environment. This also implies that no separate shell process
            is started and the boot scripts do not have to have the
            executable bit set. Encoding the interpreter location with the
            #! comment is superfluous.</p></li><li class="listitem"><p>Hook scripts are only executed from within kiwi's boot
          code and must therefore be part of the KIWI created boot
          image. Including the content of a tarball in the initrd is
          accomplished by setting the value of the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm140065371527712"></a> attribute of the
            <code class="sgmltag-element">archive</code> element to
            <code class="sgmltag-attvalue">true</code> in the
            <code class="filename">config.xml</code> file as shown below:</p><pre class="screen">&lt;packages type="image"&gt;
  &lt;archive name="kiwi-hooks.tgz" bootinclude="true"/&gt;
&lt;/packages&gt;</pre><p>The concept of including an archive in the boot image follows
          the same concepts described for the system image previously.
          In order to
          use an archive in a pre-built boot image the archive must be
          part of the boot image description in which case it is not
          necessary to set the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm140065371522784"></a> attribute.</p></li></ul></div><p>The following list provides information about the hook names,
      timing of the execution, and the applicable boot image.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>handleSplash. </b>
      This hook is called prior to any dialog/exception message or
      progress dialog. The hook can be used to customize the behavior
      of the splash screen. kiwi automatically hides a plymouth or
      kernel based splash screen if there is only one active console
      </p></li><li class="listitem"><p><b>init. </b>
      This hook is called before udev is started. The hook
      exists only for the <span class="emphasis"><em>pxe</em></span> image type. 
      </p></li><li class="listitem"><p><b>preconfig|postconfig. </b>
      The hooks are called before and after the client configuration
            files (CONF contents) are setup, respectively. The hooks exist
            only for the <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>predownload|postdownload. </b>
      The hooks are called before and after the client image receives
      the root filesystem, respectively. The hooks exist only for
      the <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>preImageDump|postImageDump. </b>
      The hooks are called before and after the install image is
      dumped on the target disk, respectively. The hooks exist only for
      the <span class="emphasis"><em>oem</em></span> image type.
            </p></li><li class="listitem"><p><b>preLoadConfiguration|postLoadConfiguration. </b>
      The hooks are called before and after the client configuration
      file config.MAC is loaded, respectively. The hooks exist only for
            the <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>premount|postmount. </b>
      The hooks are called before and after the client root
      filesystem is mounted, respectively. The hooks exist only for
            the <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>prenetwork|postnetwork. </b>
      The hooks are called before and after the client network
      is setup, respectively. The hooks exist only for
      the <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>prepartition|postpartition. </b>
      The hooks are called before and after the client creates
      the partition table on the target disk, respectively. The hooks
            exist only for the <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>preprobe|postprobe. </b>
      The hooks are called before and after the loading of modules
      not handled by udev, respectively. The hooks exist only for the
      <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>preswap|postswap. </b>
      The hooks are called before and after the creation of the
      swap space, respectively. The hooks exist only for the
            <span class="emphasis"><em>pxe</em></span> image type.
            </p></li><li class="listitem"><p><b>preactivate. </b>
      This hook is called before the root filesystem is moved to /
      The hook exists only for the <span class="emphasis"><em>pxe</em></span>
            image type.
            </p></li><li class="listitem"><p><b>preCallInit. </b>
            This hook is called before the initialization process,
            init or systemd, is started. At call time the root filesystem
            has already been moved to /. The hook exists only for the
            <span class="emphasis"><em>oem</em></span> and <span class="emphasis"><em>vmx</em></span> image types.
            </p></li><li class="listitem"><p><b>preRecovery|postRecovery. </b>
            This hook is called before and after the recovery code is
            processed. At call time of preRecovery the recovery partition is
            not yet mounted. At call time of postRecovery the recovery partition
            is still mounted on <span class="emphasis"><em>/reco-save</em></span>.
            The hook exists only for the <span class="emphasis"><em>oem</em></span> image type.
            </p></li><li class="listitem"><p><b>preRecoverySetup|postRecoverySetup. </b>
            This hook is called before and after the recovery setup is
            processed. At call time of preRecoverySetup the recovery partition
            is not yet mounted. At call time of postRecoverySetup the recovery
            partition is still mounted on <span class="emphasis"><em>/reco-save</em></span>.
            The hook exists only for the <span class="emphasis"><em>oem</em></span> image type.
            </p></li><li class="listitem"><p><b>preException. </b>
      This hook is called before a system error is handled, the
      actual error message is passed as parameter. This hook can be
            used for all image types.
            </p></li><li class="listitem"><p><b>preHWdetect|postHWdetect. </b>
      The hooks are called before and after the install image boot
      code detects the possible target storage device(s).
      The hook exists only for the <span class="emphasis"><em>oem</em></span> image type.
            </p></li><li class="listitem"><p><b>preNetworkRelease. </b>
      This hook is called before the network connection is released.
      The hook exists only for the <span class="emphasis"><em>pxe</em></span> image type.
            </p></li></ul></div><p>The execution of hooks can be globaly deactivated by passing the
      following variable to the kernel commandline:</p><pre class="screen">KIWI_FORBID_HOOKS=1</pre><p>In addition to the hook
      script itself it's also possible to run a post command after the
      hook script was called. This allows to run commands tied to a hook
      script without changing the initrd and thus provides a certain
      flexibility when writing the hook. The post command execution is
      based on variables one can pass to the kernel commandline to
      extend an existing hook script. There are the following rules for
      the processing of these information</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>The hook must activate the command post
              processing. </b> Post hook commands are only processed if the
              corresponding hook script activates this. The variable the
              hook script has to set follows the naming schema:
              KIWI_ALLOW_HOOK_CMD_|HOOKNAME|=1 For example:
              </p><pre class="screen">KIWI_ALLOW_HOOK_CMD_preHWdetect=1</pre><p> If this
              is set as part of the preHWdetect.sh hook script code the
              post command execution is activated </p></li><li class="listitem"><p><b>KIWI_HOOK_CMD_|HOOKNAME|. </b> The variable containing the command to become
              executed must match the following naming schema. For
              example:
              </p><pre class="screen">KIWI_HOOK_CMD_preHWdetect="ls -l"</pre><p> This
              would cause the preHWdetect hook to call <span class="command"><strong>ls
                -l</strong></span> at the end of the hook script code </p></li><li class="listitem"><p><b>KIWI_FORBID_HOOK_CMDS. </b> If this variable is set to something non empty the
              post hook command execution is deactivated however the
              basic hook script invocation is still active unless
              KIWI_FORBID_HOOKS is also set </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.bootcustomization"></a>3.5. Boot Image Customization<span class="permalink"><a alt="Permalink" title="3.5. Boot Image Customization" href="#sec.bootcustomization">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065371462800"></a><a class="indexterm" name="idm140065371461408"></a><p>The KIWI provided boot image descriptions should satisfy the
      requirements for a majority of image builds and the environments in
      which these images are deployed. For the circumstances that require
      customized boot images KIWI provides mechanisms in the system image
      <code class="filename">config.xml</code> file to influence the boot image
      content. Using these mechanisms allows the user to still base the
      boot image on the KIWI provided descriptions rather than defining a
      completely new and custom boot image description. Creating a
      custom boot image that is not based on the KIWI provided descriptions
      is also possible. The following question and answer section provides
      solutions to the most common customization needs fro the initrd
      created by kiwi.
  </p><div class="qandaset"><a name="idm140065371458576"></a><dl><dt>Q: <a href="#idm140065371458080">
      Why is the boot image so big and can I reduce it's size ?
     </a></dt><dt>Q: <a href="#idm140065371450992">
      Can drivers be added to the boot image?
     </a></dt><dt>Q: <a href="#idm140065371441984">
      How to add missing tools/libraries?
     </a></dt><dt>Q: <a href="#idm140065371431200">
      Is it possible to add boot code?
     </a></dt><dt>Q: <a href="#idm140065371428256">
      Is it possible to include completely custom boot code?
     </a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idm140065371458080"></a><a name="idm140065371457824"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Why is the boot image so big and can I reduce it's size ?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
KIWI includes all required tools and libraries to boot the
            image in all circumstances in the target environment for the
            image type. If target environment is well defined it is
            possible to remove data from that is known not to be needed.
            This will decrease the size of the initrd to and decrease
            boot time. Removing files in the boot image is accomplished
            by adding a <code class="sgmltag-element">strip</code> section
            to the system image <code class="filename">config.xml</code> file,
            with the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065371454256"></a> attribute
            set to <code class="sgmltag-attvalue">delete</code>, as shown
            below.
     </p><pre class="screen">&lt;strip type="delete"/&gt;
    &lt;file name="..."/&gt;
&lt;/strip&gt;</pre><p>
            Removing files that are needed my result in an image that
            cannot be booted. </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm140065371450992"></a><a name="idm140065371450736"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Can drivers be added to the boot image?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      KIWI uses a subset of the kernel. Should you encounter
            problems due to a missing driver that is part of the
            "standard" kernel but has not bee included by the kiwi build
            process you can add the driver by adding a <code class="sgmltag-element">drivers</code> section to the system
            image <code class="filename">config.xml</code> file, as shown below.</p><pre class="screen">&lt;drivers&gt;
    &lt;file name="drivers/..."/&gt;
&lt;/drivers&gt;</pre><p>
            If the driver is provided by a package, the package itself
            needs to be specified as part of the <code class="sgmltag-attvalue">image</code> package section and it
            must be marked for boot image inclusion by setting the value
            of the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm140065371445440"></a>
            attribute of the <code class="sgmltag-element">package</code>
            element to <code class="sgmltag-attvalue">true</code>, as
            shown below.</p><pre class="screen">&lt;packages type="image"/&gt;
    &lt;package name="..." bootinclude="true"/&gt;
&lt;/packages&gt;</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idm140065371441984"></a><a name="idm140065371441728"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      How to add missing tools/libraries?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      Additional software can be added to the boot image with the
            use of the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm140065371439840"></a>
            attribute of the <code class="sgmltag-element">package</code>
            element or the <code class="sgmltag-element">archive</code>
            element. At the end of the boot image creation process kiwi
            attempts to reduce the size of the boot image by removing
            files that are not part of a known list of required files,
            any detectable dependencies of the files listed are
            preserved as well. The list of known required files is hard
            coded in the
              <code class="filename">/usr/share/kiwi/modules/KIWIConfig.txt</code>
            file. If you added files to the boot image that are needed
            in your specific use case you need to instruct kiwi to not
            strip the files you have added to the boot image. This is
            accomplished by adding a <code class="sgmltag-element">strip</code> section to the system image
              <code class="filename">config.xml</code> file, with the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065371434544"></a> attribute set to <code class="sgmltag-attvalue">tools</code>, as shown below.</p><pre class="screen">&lt;strip type="tools"/&gt;
    &lt;file name="..."/&gt;
&lt;/strip&gt;</pre><p>The removal/preservation of files is name based and the path
            is immaterial. Therefore, you only have to specify the file
            name that is to be preserved.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm140065371431200"></a><a name="idm140065371430944"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Is it possible to add boot code?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
Yes, as described in the <a class="xref" href="#sec.hooks" title="3.4. Boot Image Hook-Scripts">Section 3.4, “Boot Image Hook-Scripts”</a> section above,
            KIWI supports the execution of boot code at various times for
            various image types using <span class="emphasis"><em>hook</em></span> scripts.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm140065371428256"></a><a name="idm140065371428000"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Is it possible to include completely custom boot code?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      No. In cases where the provided hooks are insufficient and the
            KIWI provided boot code needs to be replaced completed it is
            necessary to create a custom boot image description. In this case,
            all parts of the boot image description must be created by the
            user. It is best to use one of the KIWI provided boot descriptions
            as a template.
     </p></td></tr></tbody></table></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.bootparameters"></a>3.6. Boot Parameters<span class="permalink"><a alt="Permalink" title="3.6. Boot Parameters" href="#sec.workflow.bootparameters">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065371424688"></a><a class="indexterm" name="idm140065371423296"></a><p>A KIWI created initrd based on one of the KIWI provided boot
      image descriptions recognizes kernel parameters that are useful
      for debugging purposes, should the image not boot. These parameters may
      not work if the image contains a custom boot image where the kiwi boot
      code has been replaced, and the parameters are not recognized after
      the initial KIWI created initrd has been replaced by the "regular"
      distribution created initrd after the initial boot of the image.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>kiwidebug=1</code></em></span></dt><dd><p>
If the boot process encounters a fatal error, the
            default behavior is to reboot the system 120 seconds. The
              <span class="quote">“<span class="quote">exception</span>”</span> behavior is changed by setting
            the <code class="option">kiwidebug</code> parameter. With the value of
            the parameter set to 1 the system will enter a limited shell
            environment should a fatal error occur during boot. The
            shell contains the standard basic commands. The
              <code class="filename">/var/log/kiwi.boot</code> boot log file may
            be consulted to develop a better understanding of the boot
            failure. In addition to the spawned shell process kiwi also
            starts the dropbear ssh server if the environment is
            suitable. Support for ssh into the boot image is possible in
            the netboot and oemboot (in PXE boot mode) boot images. For
            isoboot and vmxboot boot images there is no remote login
            support because they don't setup a network. In order to have
            dropbear installed as part of the boot image the following
            needs to be added to the system image configuration:</p><pre class="screen">&lt;packages type="image"/&gt;
    &lt;package name="dropbear" bootinclude="true"/&gt;
&lt;/packages&gt;</pre><p>It's required that the repo setup provides dropbear. Once
            dropbear is there the kiwi boot code will start the service.
            In order to access the boot image via ssh it's required to
            provide a public key on the pxe server in the directory:
              <code class="filename">server-root/KIWI/debug_ssh.pub</code>. kiwi
            only searches for that filename so it's required to name it
              <span class="quote">“<span class="quote">debug_ssh.pub</span>”</span>. Adding more than one public
            key to this file is possible exactly like the common SSH
            file <span class="quote">“<span class="quote">authorized_keys</span>”</span>. The path
              <span class="quote">“<span class="quote">server-root</span>”</span> depends on what server type was
            configured to download the image. By default this is done
            via tftp. In that case the complete path to put the public
            key to is
              <code class="filename">/srv/tftpboot/KIWI/debug_ssh.pub</code>. on
            the pxe server. If ftp or http is used the server-root path
            is different. If a public key was found you can login as
            follows:</p><pre class="screen"><span class="command"><strong>ssh</strong></span> root@&lt;ip&gt;</pre><p>It
            might be useful to have a copy tool like scp or rsync as
            part of the boot image as well. Adding rsync as bootincluded
            package does not increase the size of the initrd much and
            would allow to extract e.g the kiwi boot log as follows:</p><pre class="screen">RSYNC_RSH='ssh -l root'
<span class="command"><strong>rsync</strong></span> -avz &lt;ip&gt;:/var/log/boot.kiwi .</pre></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.common-specific-code"></a>3.7. Common and Distribution Specific Code<span class="permalink"><a alt="Permalink" title="3.7. Common and Distribution Specific Code" href="#sec.workflow.common-specific-code">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065371407936"></a><a class="indexterm" name="idm140065371406544"></a><p>KIWI is designed to be in principal distribution independent and
      the majority of the kiwi implementation follows this design principal.
      However, Linux distributions differ from each other, primarily in the
      package management area as well as the creation and composition of
      the boot image.</p><p>Within the KIWI code base major areas of Linux distribution
      differences are isolated into specific regions of the code. The
      remainder of the code is common and distribution independent.</p><p>KIWI provided functions that are distribution specific contain
      the distribution name as a prefix, such as
      <code class="function">suseStripKernel</code>. Scripts that are part of the boot
      code and are distribution specific are identified by a prefix of
      the distribution name followed by a <span class="quote">“<span class="quote">-</span>”</span>,
      <span class="command"><strong>suse-linuxrc</strong></span> for example. When kiwi creates a boot
      image for a SUSE distribution the <span class="command"><strong>suse-linuxrc</strong></span> file
      from the boot discription is used as the <span class="command"><strong>linuxrc</strong></span>
      file that the Linux kernel calls.</p><p>With this design and implementation t is possible to maintain
      distribution specific code in the same project while also providing
      explicit hints to the user when distribution specific code is being
      used. The implemented SUSE specific code can be used as a guideline
      to support other distributions.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.caches"></a>Chapter 4. Image Caches</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.caches.introduction">4.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.caches.example">4.2. Example</a></span></dt></dl></div><a class="indexterm" name="idm140065371398336"></a><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.caches.introduction"></a>4.1. Introduction<span class="permalink"><a alt="Permalink" title="4.1. Introduction" href="#sec.caches.introduction">¶</a></span></h2></div></div></div><p>
      The process of creating an appliance could take quite some time
      and often the same software is installed over and over again. In
      order to speed up that process kiwi is able to create and re-use
      so called image caches. An image cache in kiwi is a partial root tree
            created from a cache image description.
    </p><div class="figure"><a name="fig.imagecachingarch"></a><p class="title"><b>Figure 4.1. Image Caching Architecture</b><span class="permalink"><a alt="Permalink" title="Figure 4.1. Image Caching Architecture" href="#fig.imagecachingarch">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/cache.png" alt="Image Caching Architecture"></div></div></div><br class="figure-break"><p>
      Before one can use a cache it needs to be created. A cache can be
      created from any standard kiwi image description, including boot image
      descriptions. That means you can
      simply use one of the template or *boot descriptions and create a
      cache from
      it. But it might be more clever to create image descriptions for the
      purpose of caching. Such descriptions could represent a set of patterns
      for example. The less special a cache is the more often it can be re-used
    </p><p>
      Once there are caches in the system kiwi selects the best match and
      mounts the cache in a way that all write actions (copy-on-write cache)
      are redirected to the new root system. That way the cache itself is never changed
      and can be re-used simultaniosly for other build processes. As result
      the build process doesn't start with an empty tree but with a tree
      almost complete. Only the missing parts are now installed and according
      to how much the cache already covered this process can speedup the build
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.caches.example"></a>4.2. Example<span class="permalink"><a alt="Permalink" title="4.2. Example" href="#sec.caches.example">¶</a></span></h2></div></div></div><p>
      Let's say we know that we want to build some images of type 'vmx'
      and based on the SLES 12 JeOS image description. In order to
      create image caches for the system and the boot image the following
      steps needs to be done:
    </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Build the boot image (initrd) cache:</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --init-cache /usr/share/kiwi/image/vmxboot/suse-SLES12</pre></li><li class="step"><p>Build the JeOS image cache:</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --init-cache /usr/share/kiwi/image/suse-SLE12-JeOS/</pre></li></ol></div><p> By default those caches will be created in
      <code class="filename">/var/cache/kiwi-images</code>. To run a build which
      makes use of the cache the following command is used: </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myimage --type vmx \
     --cache /var/cache/kiwi-images</pre><p>
      This call speeds up the build a lot compared to the creation without a
      cache. It's important to understand that a cache based build will
      create a root tree which contains only the differences 
      compared to the used cache. Thus at any time you want
      to create an image out of it you have to make sure that the cache
      exists and is accessible on the system.
    </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.description"></a>Chapter 5. KIWI Image Description</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.description.config.xml">5.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">5.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">5.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">5.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">5.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">5.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">5.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">5.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">5.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm140065371377760"></a><p>In order to be able to create an image with KIWI, a so called
    image description must be created. The image description is
    represented by a directory which has to contain at least one file
    named <code class="filename">config.xml</code> or <code class="filename">*.kiwi</code><a class="indexterm" name="idm140065371374528"></a>. A good start for such a
    description can be found in the examples provided in
      <code class="filename">/usr/share/doc/packages/kiwi/examples</code>. </p><div class="figure"><a name="fig.description.imagedescrdir"></a><p class="title"><b>Figure 5.1. Image Description Directory</b><span class="permalink"><a alt="Permalink" title="Figure 5.1. Image Description Directory" href="#fig.description.imagedescrdir">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="40%"><tr><td><img src="images/description.png" width="100%" alt="Image Description Directory"></td></tr></table></div></div></div><br class="figure-break"><p>The following additional information is optional for the process
    of building an image, but most often mandatory for the functionality
    of the created operating system: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">images.sh</code></span></dt><dd><p> Optional configuration script while creating the packed
          image. This script is called at the beginning of the image
          creation process. It is designed to clean-up the image system.
          Affected are all the programs and files only needed while the
          unpacked image exists. </p></dd><dt><span class="term"><code class="filename">config.sh</code></span></dt><dd><p>Optional configuration script while creating the unpacked
          image. This script is called at the end of the installation,
          but <span class="emphasis"><em>before</em></span> the package scripts have run.
          It is designed to configure the image system, such as the
          activation or deactivation of certain services (<code class="systemitem">insserv</code><a class="indexterm" name="idm140065371361792"></a>). The call is not made
          until after the switch to the image has been made with chroot.
        </p></dd><dt><span class="term"><code class="filename">root</code><a class="indexterm" name="idm140065371359152"></a></span></dt><dd><p>Subdirectory that contains special files, directories, and
          scripts for adapting the image environment
            <span class="emphasis"><em>after</em></span> the installation of all the image
          packages. The entire directory is copied into the root of the
          image tree using <span class="command"><strong>cp</strong></span>
          <code class="option">-a</code>. </p></dd><dt><span class="term"><code class="filename">config-yast-autoyast.xml</code></span></dt><dd><p> Configuration file which has been created by AutoYaST. To
          be able to create such an AutoYaST profile, run: </p><pre class="screen"><span class="command"><strong>yast2</strong></span> autoyast</pre><p>Once you have saved the information from the AutoYaST UI
          as <code class="filename">config-yast-autoyast.xml</code> file in your
          image description directory KIWI will process on the file and
          setup your image as follows: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>While booting the image YaST is started in AutoYaST
              mode automatically </p></li><li class="listitem"><p>The AutoYaST description is parsed and the
              instructions are handled by YaST. In other words the
                <span class="emphasis"><em>system configuration</em></span> is performed
            </p></li><li class="listitem"><p>If the process finished successfully the environment
              is cleaned and AutoYaST won’t be called at next reboot.
            </p></li></ol></div></dd><dt><span class="term"><code class="filename">config-cdroot.tgz</code></span></dt><dd><p> Archive which is used for ISO images only. The data in
          the archive is uncompressed and stored in the CD/DVD root
          directory. This archive can be used, for example, to integrate
          a license file or information directly readable from the CD or
          DVD. </p></dd><dt><span class="term"><code class="filename">config-cdroot.sh</code></span></dt><dd><p>Along with the <code class="filename">config-cdroot.tgz</code> one
          can provide a script which allows to manipulate the extracted
          data. </p></dd><dt><span class="term"><code class="filename">config/</code><a class="indexterm" name="idm140065371341136"></a></span></dt><dd><p>Optional subdirectory that contains Bash scripts that are
          called after the installation of all the image packages,
          primarily in order to remove the parts of a package that are
          not needed for the operating system. The name of the Bash
          script must resemble the package name listed in the
          config.xml. </p></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.description.config.xml"></a>5.1. The config.xml File<span class="permalink"><a alt="Permalink" title="5.1. The config.xml File" href="#sec.description.config.xml">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065371337856"></a><p> The mandatory image definition file is divided into different
      sections which describes information like the image name and type
      as well as the packages and patterns the image should consist of. </p><p>The following information explains the basic structure of the
      XML document. When KIWI is executed, the XML structure is
      validated by the KIWI RELAX NG based schema. For details on
      attributes and values please refer to the schema documentation
      file at
        <code class="filename">/usr/share/doc/packages/kiwi/kiwi.rng.html</code>. </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.image"></a>5.1.1. <code class="sgmltag-element">image</code> Element<span class="permalink"><a alt="Permalink" title="5.1.1. image Element" href="#sec.description.image">¶</a></span></h3></div></div></div><pre class="screen">&lt;image schemaversion="6.2" name="iname"
  displayname="text" 
  kiwirevision="number" 
  id="10 digit number"&gt;
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/image&gt;</pre><p>The image definition starts with an <code class="sgmltag-element">image</code>
        tag and requires the schema format at version 2.0. The attribute
          <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm140065371330400"></a> specifies the name
        of the image which is also used for the filenames created by
        KIWI. Because we don’t want spaces in filenames the <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm140065371328576"></a> attribute must not have any
        spaces in its name. </p><p>The following optional attributes can be inserted in the
          <code class="sgmltag-element">image</code> tag: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">displayname</code><a class="indexterm" name="idm140065371325376"></a></span></dt><dd><p>Allows setup of the boot menu title for the selected
              bootloader. So you can have <span class="emphasis"><em>suse-SLED-foo</em></span>
              as the image name but a different name as the boot display name.
              Spaces are not allowed in the display name because it causes
              problems for some bootloaders and kiwi did not take the effort
              to separate the ones which can display them correctly from the
              ones which can't</p></dd><dt><span class="term"><code class="sgmltag-attribute">kiwirevision</code><a class="indexterm" name="idm140065371321744"></a></span></dt><dd><p>specifies a KIWI git revision number which is known to
              build a working image from this description. If the KIWI
              git revision doesn't match the specified value, the process
              will exit. The currently used git revision can be queried
              by calling <span class="command"><strong>kiwi</strong></span>
              <code class="option">--version</code>. </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="idm140065371317632"></a></span></dt><dd><p> sets an identification number which appears as file
                <code class="filename">/etc/ImageID</code> within the image.
            </p></dd></dl></div><p>Inside the <code class="sgmltag-element">image</code> section the following
        mandatory and optional subelements exists. The simplest image
        description must define the elements
          <code class="sgmltag-element">description</code>,
        <code class="sgmltag-element">preferences</code>, <code class="sgmltag-element">repository</code>
        and <code class="sgmltag-element">packages</code> (at least one of <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065371312064"></a>="<code class="sgmltag-attvalue">bootstrap</code>"). </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.description"></a>5.1.2. <code class="sgmltag-element">description</code> Element<span class="permalink"><a alt="Permalink" title="5.1.2. description Element" href="#sec.description.description">¶</a></span></h3></div></div></div><pre class="screen">&lt;description type="system"&gt;
  &lt;author&gt;an author&lt;/author&gt;
  &lt;contact&gt;mail&lt;/contact&gt;
  &lt;specification&gt;short info&lt;/specification&gt;
&lt;/description&gt;</pre><p>The mandatory <code class="sgmltag-element">description</code> section
        contains information about the creator of this image
        description. The attribute <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065371306864"></a> could be either of the value system which
        indicates this is a system image description or at value boot
        for boot image descriptions. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.profiles"></a>5.1.3. <code class="sgmltag-element">profiles</code> Element<span class="permalink"><a alt="Permalink" title="5.1.3. profiles Element" href="#sec.description.profiles">¶</a></span></h3></div></div></div><pre class="screen">&lt;profiles&gt;
   &lt;profile name="name" description="text"/&gt;
   <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/profiles&gt;</pre><p>The optional <code class="sgmltag-element">profiles</code> section lets you
        maintain one image description while allowing for variation of
        the sections packages and drivers that are included. A separate
        profile element must be specified for each variation. The
          <code class="sgmltag-element">profile</code> child element, which has <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm140065371301152"></a> and <code class="sgmltag-attribute">description</code><a class="indexterm" name="idm140065371299648"></a> attributes, specifies
        an alias name used to mark sections as belonging to a profile,
        and a short description explaining what this profile does. </p><p>To mark a set of packages/drivers as belonging to a profile,
        simply annotate them with the <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm140065371297472"></a> attribute. It is also possible to mark
        sections as belonging to multiple profiles by separating the
        names in the <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm140065371295824"></a>
        attribute with a comma. If a <code class="sgmltag-element">packages</code> or
          <code class="sgmltag-element">drivers</code> tag does not have a <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm140065371293552"></a> attribute, it is assumed
        to be present for all profiles. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.preferences"></a>5.1.4. <code class="sgmltag-element">preferences</code> Element<span class="permalink"><a alt="Permalink" title="5.1.4. preferences Element" href="#sec.description.preferences">¶</a></span></h3></div></div></div><pre class="screen">&lt;preferences profiles="name"&gt;
  &lt;version&gt;1.1.2&lt;/version&gt;
  &lt;packagemanager&gt;zypper&lt;/packagemanager&gt;
  &lt;type image="name" ...&gt;
    &lt;machine|oemconfig|pxedeploy|size|split|systemdisk|vagrantconfig&gt;
  &lt;/type&gt; 
&lt;/preferences&gt;</pre><p>The mandatory <code class="sgmltag-element">preferences</code> section
        contains information about the supported image type(s), the used
        package manager, the version of this image, and optional
        attributes. The image version must be a three-part version
        number of the format: <span class="bold"><strong>Major</strong></span>.<span class="bold"><strong>Minor</strong></span>.<span class="bold"><strong>Release</strong></span>.
        <a class="indexterm" name="idm140065371287376"></a>
        In case of changes to the image description the following rules
        should apply: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>For smaller image modifications that do not add or
            remove any new packages, only the release number is
            incremented. The <code class="filename">config.xml</code> file
            remains unchanged. </p></li><li class="listitem"><p>For image changes that involve the addition or removal
            of packages the minor number is incremented and the release
            number is reset. </p></li><li class="listitem"><p>For image changes that change the size of the image file
            the major number is incremented. </p></li></ul></div><p>By default, KIWI uses the <span class="command"><strong>zypper</strong></span> package
        manager but it is also possible to use the non SUSE native package
        manager called <span class="command"><strong>smart</strong></span>. </p><p>In general the specification of one
          <code class="sgmltag-element">preferences</code> section is sufficient. However,
        it’s possible to specify multiple <code class="sgmltag-element">preferences</code>
        sections and distinguish between the sections via the <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm140065371278448"></a> attribute. Data may also
        be shared between different profiles. Using profiles it is
        possible to, for example, configure specific preferences for OEM
        image generation. Activation of a given
          <code class="sgmltag-element">preferences</code> during image generation is
        triggered by the use of the <code class="option">--add-profile</code>
        command line argument.</p><p>For each <code class="sgmltag-element">preferences</code> block at least one
          <code class="sgmltag-element">type</code> element must be defined. It is
        possible to specify multiple <code class="sgmltag-element">type</code> elements in
        any <code class="sgmltag-element">preferences</code> block. To set a given
          <code class="sgmltag-element">type</code> description as the default image use
        the boolean attribute <code class="sgmltag-attribute">primary</code><a class="indexterm" name="idm140065371273392"></a> and set its value to <code class="sgmltag-attvalue">true</code>. The image type to be created
        is determined by the value of the <code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371271168"></a> attribute. The following list describes the
        supported types and possible values of the image attribute: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371268768"></a>="<code class="sgmltag-attvalue">lxc|docker</code>"</span></dt><dd><p>Use the lxc or docker image type to build a linux container image
              For additional information refer to the <a class="xref" href="#chap.lxc" title="Chapter 11. Linux Containers and Docker">Chapter 11, <i>Linux Containers and Docker</i></a>
              chapter.</p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371264592"></a>="<code class="sgmltag-attvalue">[filesystem]</code>"</span></dt><dd><p>Use one of the following image types to build a plain
              filesystem image. This will create a file containing the
              data in the specified filesystem and you can loop mount
              the image to view the contents e.g image="ext3":</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ext2</p></li><li class="listitem"><p>ext3</p></li><li class="listitem"><p>ext4</p></li><li class="listitem"><p>btrfs</p></li><li class="listitem"><p>squashfs</p></li><li class="listitem"><p>xfs</p></li></ul></div></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371255440"></a>="<code class="sgmltag-attvalue">tbz</code>"</span></dt><dd><p>Use the tbz image type to just pack the unpacked image tree
              into a tarball.</p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371251792"></a>="<code class="sgmltag-attvalue">cpio</code>"</span></dt><dd><p>Use the cpio image type to specify the generation of a
              boot image (initrd). When generating a boot image, it is
              possible to specify a specific boot profile and boot
              kernel using the optional <code class="sgmltag-attribute">bootprofile</code><a class="indexterm" name="idm140065371248768"></a>="<code class="sgmltag-attvalue">default</code>" and <code class="sgmltag-attribute">bootkernel</code><a class="indexterm" name="idm140065371246640"></a>="<code class="sgmltag-attvalue">std</code>" attributes. </p><p>A boot image should group the various supported
              kernels into profiles. If the user chooses not to use the
              profiles supplied by KIWI, it is required that one profile
              named std be created. This profile will be used if no
              other bootkernel is specified. Further it is required to
              create a profile named default. This profile is used when
              no bootprofile is specified. </p><p>It is recommended that special configurations that
              omit drivers, use special drivers and/or special packages
              be specified as profiles. </p><p>The bootprofile and bootkernel attribute are respected
              within the definition of a system image. Us the attribute
              and value <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065371242560"></a>="<code class="sgmltag-attvalue">system</code>" of the <code class="sgmltag-element">description</code>
              element to specify the creation of a system image. The
              values of the bootprofile and bootkernel attributes are
              used by KIWI when generating the boot image. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371239072"></a>="<code class="sgmltag-attvalue">iso</code>"</span></dt><dd><p>Specify the key-value pair <code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371236304"></a>="<code class="sgmltag-attvalue">iso</code>" to generate a live system suitable for
              deployment on optical media (CD or DVD). Use the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065371234048"></a>="<code class="sgmltag-attvalue">isoboot/suse-*</code>" attribute
              when generating this image type to select the appropriate
              boot image for optical media. In addition the optional
                <code class="sgmltag-attribute">flags</code><a class="indexterm" name="idm140065371231728"></a> attribute may
              be set to the following values with the effects described
              below:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attvalue">seed</code></span></dt><dd><p>Creates a btrfs based compressed read-only
                    filesystem which allows write operations into a btrfs
                    seed device. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">overlay</code></span></dt><dd><p>Creates a squashfs based compressed read-only
                    filesystem which is combined with a write space via
                    the overlayfs filesystem. overlayfs is part of the
                    kernel since version 3.7</p></dd><dt><span class="term"><code class="sgmltag-attvalue">compressed</code></span></dt><dd><p>Creates a split ext3 plus squashfs filesystem and
                    combines them via a symlink system to a complete system
                    it is recommended to specify a <code class="sgmltag-element">split</code>
                    section as a child of this type element.     
                  </p></dd></dl></div><p>If the flags attribute is not used the filesystem
              will be squashfs compressed for /bin /boot /lib /lib64 /opt /sbin
              and /usr. The rest of the filesystem is packed into a tmpfs
              and linked via symbolic links 
            </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371221584"></a>="<code class="sgmltag-attvalue">oem</code>"</span></dt><dd><p>Use this type to create a virtual disk system suitable
              in a preload setting. In addition specify the attributes
                <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="idm140065371218656"></a>, and
                <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065371217152"></a>="<code class="sgmltag-attvalue">oemboot/suse-*</code>" to control
              the filesystem used for the virtual and to specify the
              proper boot image. Using the optional <code class="sgmltag-attribute">format</code><a class="indexterm" name="idm140065371214880"></a> attribute and
              setting, the value to iso or usb will create self
              installing images suitable for optical media or a USB
              stick, respectively. Booting from the media will deploy
              the OEM preload image onto the selected storage device of
              the system. It is also possible to configure the system to
              use logical volumes. Use the optional <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="idm140065371212944"></a> attribute and specify
              the logical volume configuration with the
                <code class="sgmltag-element">systemdisk</code> child element. The default
              volume group name is kiwiVG. Further configuration of the
              image is performed using the appropriate
                <code class="sgmltag-element">*config</code> child block. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371209600"></a>="<code class="sgmltag-attvalue">pxe</code>"</span></dt><dd><p>Creating a network boot image is supported by KIWI
              with the image="pxe" type. When specifying the creation of
              a network boot image use the <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="idm140065371206656"></a> and boot="netboot/suse-*"
              attributes to specify the filesystem of the image and the
              proper boot image. To compress the image file set the
                <code class="sgmltag-attribute">compressed</code><a class="indexterm" name="idm140065371204960"></a> boolean
              attribute to true. This setting will compress the image
              file and has no influence on the filesystem used within
              the image. The compression is often use to support better
              transfer times when the pxe image is pushed to the boot
              server over a network connection. The pxe image layout is
              controlled by using the <code class="sgmltag-element">pxedeploy</code> child
              element. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371201888"></a>="<code class="sgmltag-attvalue">split</code>"</span></dt><dd><p>The split image support allows the creation of an
              image as split files. Using this technique one can assign
              different filesystems and different read-write properties
              to the different sections of the image. The
                <code class="sgmltag-element">oem</code>, <code class="sgmltag-element">pxe</code>,
                <code class="sgmltag-element">usb</code>, and <code class="sgmltag-element">vmx</code> types
              can be created as a split system image. Use the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065371197216"></a>="<code class="sgmltag-attvalue">oem|netboot|usb|vmx/suse-*</code>"
              attribute to select the underlying type of the split
              image. The attributes <code class="sgmltag-attribute">fsreadwrite</code><a class="indexterm" name="idm140065371194960"></a>, <code class="sgmltag-attribute">fsreadonly</code><a class="indexterm" name="idm140065371193456"></a> are used to control the
              read-write properties of the filesystem specified as the
              attributes value. Use the appropriate
                <code class="sgmltag-element">*config</code> child block to specify the
              properties of the underlying image. For example when
              building a OEM based split image use the
                <code class="sgmltag-element">oemconfig</code> child section. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371190064"></a>="<code class="sgmltag-attvalue">vmx</code>"</span></dt><dd><p>Creation of a virtual disk system is enabled with the
              vmx value of the image attribute. Set the filesystem of
              the virtual disk with the filesystem attribute and select
              the appropriate boot image by setting <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065371187024"></a>="<code class="sgmltag-attvalue">vmxboot/suse-*</code>" The optional
              format attribute is used to specify one of the
              virtualization formats supported by QEMU, such as vmdk
              (also the VMware format) or qcow2. For the virtual disk
              image the optional vga attribute may be used to configure
              the kernel framebuffer device. Acceptable values can be
              found in the Linux kernel documentation for the
              framebuffer device (see
                <code class="filename">Documentation/fb/vesafb.txt</code>). KIWI
              also supports the selection of the bootloader for the
              virtual disk according to the rules indicated for the USB
              system. Last but not least the virtual disk system may
              also be created with a LVM based layout by using the
                <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="idm140065371182992"></a> attribute. The
              previously indicated rules apply. Use the
                <code class="sgmltag-element">machine</code> child element to specify
              appropriate configuration of the virtual disk system.
            </p></dd></dl></div><p>Within the type section, there could be other optional
    attributes which are either universally valid or can be used
    for different image types in the same way. The following list
        explains these attributes: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">kernelcmdline</code><a class="indexterm" name="idm140065371179088"></a></span></dt><dd><p>Specifies additional kernel parameters.
          The following example disables kernel messages:
          <code class="literal">kernelcmdline="quiet"</code></p></dd><dt><span class="term"><code class="sgmltag-attribute">mdraid</code><a class="indexterm" name="idm140065371175680"></a></span></dt><dd><p>For disk based image types, aka oem and vmx,
          mdraid activates the creation of a software raid image.
          The raid inside the image is created in degraded mode
          because at creation time we only know about one disk.
          It's in the hand of the user to add devices to the raid
          after the image runs on the target machine. The value
          for mdraid can be either <span class="emphasis"><em>mirroring</em></span>
          or <span class="emphasis"><em>striping</em></span>, which means the raid
          level is set to RAID1 (mirroring) or
          RAID0 (striping).</p></dd></dl></div><p>Within the preferences section, there are the following
        optional elements: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">showlicense</code><a class="indexterm" name="idm140065371170832"></a></span></dt><dd><p>
               Specifies the base name of a license file which is displayed in oem
               images before the installation happens. It's possible to add more showlicense
               sections to display more licenses one after the other. If no such element
               is specified the default 'license' and 'EULA' files are searched. The
               search algorithm will append the .txt or .locale.txt suffix to the license
               name to form the license file name. You should make sure that you license
               files contains this suffix.
            </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-check-signatures</code><a class="indexterm" name="idm140065371167440"></a></span></dt><dd><p>Specifies whether RPM should check the package
              signature or not </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-excludedocs</code><a class="indexterm" name="idm140065371164560"></a></span></dt><dd><p> Specifies whether RPM should skip installing package
              documentation </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-force</code><a class="indexterm" name="idm140065371161680"></a></span></dt><dd><p>Specifies whether RPM should be called with
                <code class="option">--force</code>
            </p></dd><dt><span class="term"><code class="sgmltag-attribute">keytable</code><a class="indexterm" name="idm140065371158432"></a></span></dt><dd><p>Specifies the name of the console keymap to use. The
              value corresponds to a map file in
                <code class="filename">/usr/share/kbd/keymaps</code>. The
                <code class="varname">KEYTABLE</code> variable in
                <code class="filename">/etc/sysconfig/keyboard</code> file is set
              according to the keyboard mapping. </p></dd><dt><span class="term"><code class="sgmltag-attribute">timezone</code><a class="indexterm" name="idm140065371153808"></a></span></dt><dd><p>Specifies the time zone. Available time zones are
              located in the <code class="filename">/usr/share/zoneinfo</code><a class="indexterm" name="idm140065371151456"></a> directory. Specify the
              attribute value relative to <code class="filename">/usr/share/zoneinfo</code><a class="indexterm" name="idm140065371149632"></a>. For example, specify
              Europe/Berlin for
                <code class="filename">/usr/share/zoneinfo/Europe/Berlin</code>.
              KIWI uses this value to configure the timezone in
                <code class="filename">/etc/localtime</code> for the image. </p></dd><dt><span class="term"><code class="sgmltag-attribute">locale</code><a class="indexterm" name="idm140065371145936"></a></span></dt><dd><p> Specifies the name of the UTF-8 locale to use, which
              defines the contents of the <code class="envar">RC_LANG</code><a class="indexterm" name="idm140065371144048"></a> system
              environment variable in
                <code class="filename">/etc/sysconfig/language</code>. Please
              note only UTF-8 locales are supported here which also
              means that the encoding must <span class="emphasis"><em>not</em></span> be
              part of the locale information. The KIWI schema validates
              the locale string according to the following
                pattern:<code class="literal">[a-z]{2}_[A-Z]{2}(,[a-z]{2}_[A-Z]{2})*</code>.
              This means you have to specify the locale like the
              following example: en_US or en_US,de_DE </p></dd><dt><span class="term"><code class="sgmltag-attribute">bootsplash-theme</code><a class="indexterm" name="idm140065371139600"></a></span></dt><dd><p>Specifies the name of the bootsplash theme to use </p></dd><dt><span class="term"><code class="sgmltag-attribute">bootloader-theme</code><a class="indexterm" name="idm140065371136816"></a></span></dt><dd><p>Specifies the name of the gfxboot theme to use </p></dd><dt><span class="term"><code class="sgmltag-attribute">defaultdestination</code><a class="indexterm" name="idm140065371134032"></a></span></dt><dd><p>Used if the <code class="option">--destdir</code> option is not
              specified when calling KIWI</p></dd><dt><span class="term"><code class="sgmltag-attribute">defaultroot</code><a class="indexterm" name="idm140065371130784"></a></span></dt><dd><p>Used if the option <code class="option">--root</code> is not
              specified when calling KIWI </p></dd></dl></div><p>The <code class="sgmltag-element">type</code> element may contain child
        elements to provide specific configuration information for the
        given type. The following lists the supported child elements: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-element">systemdisk</code></span></dt><dd><p>Using the optional systemdisk section it is possible to
              create a LVM (Logical Volume Management) based storage
              layout. By default, the volume group is named
              <span class="emphasis"><em>kiwiVG</em></span>. It
              is possible to change the name of the group by setting the
              <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm140065371124672"></a> attribute
              to the desired name. Individual volumes within the volume
              group are specified using the
              <code class="sgmltag-element">volume</code> element. </p><p>The following example shows the creation of a volume
              named <span class="italic">usr</span> and a volume
              named <span class="italic">var</span> inside the volume
              group systemVG.</p><pre class="screen"> &lt;systemdisk name="systemVG"&gt; 
  &lt;volume name="usr" freespace="100M"/&gt; 
  &lt;volume name="var" size="200M"/&gt; 
&lt;/systemdisk&gt;</pre><p>The optional attribute
              <code class="sgmltag-attribute">freespace</code><a class="indexterm" name="idm140065371119440"></a> controls the
              amount of unused space available after software has been
              installed in the given volume. By default the available space
              of a created volume is between 10% and 20%. Using the optional
              <code class="sgmltag-attribute">size</code><a class="indexterm" name="idm140065371117664"></a> attribute the
              absolute size of the given volume is specified. The
              <code class="sgmltag-attribute">size</code><a class="indexterm" name="idm140065371116048"></a> attribute takes
              precedence over the
              <code class="sgmltag-attribute">freespace</code><a class="indexterm" name="idm140065371114464"></a> attribute. If
              the specified size is insufficient, based on the estimated
              software install size for the given volume, the specified
              value will be ignored and a volume with default settings will
              be created. This implies that the volume will be 80% to 90%
              full. </p></dd><dt><span class="term"><code class="sgmltag-element">oemconfig</code></span></dt><dd><p>By default, the oemboot process will create or modify
              a swap, and <code class="filename">/</code> partition. It is possible to
              influence the behavior by the <code class="filename">oem-*</code>
              elements explained below.</p><pre class="screen">&lt;oemconfig&gt;
   &lt;oem-systemsize&gt;2000&lt;/oem-systemsize&gt;
   &lt;oem-... &gt; 
&lt;/oemconfig&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-boot-title&gt;</code>text<code class="sgmltag-endtag">&lt;/oem-boot-title&gt;</code></span></dt><dd><p>By default, the string <span class="phrase">OEM</span> will be used as the boot manager
                    menu entry when KIWI creates the GRUB configuration
                    during deployment. The
                      <code class="sgmltag-element">oem-boot-title</code> element allows
                    you to set a custom name for the grub menu entry.
                    This value is represented by the
                      <code class="varname">kiwi_oemtitle</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-bootwait&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-bootwait&gt;</code></span></dt><dd><p>Specify if the system should wait for user interaction
                    priot to  continuing the boot process after the oem image
                    has been dumped to the designated storage device (default
                    value is false). This value is represented by the
                    <code class="varname">kiwi_oembootwait</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-inplace-recovery&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-inplace-recovery&gt;</code></span></dt><dd><p>Specify if the recovery archive is stored as part of
                    the image or if the archive is to be created at the time
                    the image is deployed to the target storage device.
                    <code class="varname">kiwi_oemrecoveryInPlace</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-kiwi-initrd&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-kiwi-initrd&gt;</code></span></dt><dd><p>If this element is set to true (default value is
                    false) the oemboot boot image (initrd) will
                      <span class="emphasis"><em>not</em></span> be replaced by the system
                    (mkinitrd) created initrd. This option is useful
                    when the system is installed on removable storage
                    such as a USB stick or a portable external drive.
                    For movable devices it is potentially necessary to
                    detect the storage location during every boot. This
                    detection process is part of the oemboot boot image.
                    This value is represented by the
                    <code class="varname">kiwi_oemkboot</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-partition-install&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-partition-install&gt;</code></span></dt><dd><p>Specify if the image is to be installed into a
                      free partition on the target storage device. By default
                      the value is false and Kiwi installs images to a
                      target device which causes data loss on the device. With
                      <code class="sgmltag-element">oem-partition-install</code>
                      set to true any other settings that have influence on
                      the partition table, such as
                      <code class="sgmltag-element">oem-swap</code> are ignored.
                      This value is represented by the
                      <code class="varname">kiwi_oempartition_install</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-reboot&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-reboot&gt;</code></span></dt><dd><p>Specify if the system is to be rebooted after
                    the oem image has been deployed to the designated
                    storage device (default value is false). This value
                    is represented by the <code class="varname">kiwi_oemreboot</code>
                    variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-reboot-interactive&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-reboot-interactive&gt;</code></span></dt><dd><p>Specify if the system is to be rebooted after
                    the oem image has been deployed to the designated
                    storage device (default value is false). Prior to
                    reboot a message is posted and must be acknowledged
                    by the user in order for the system to reboot. This value
                    is represented by the
                    <code class="varname">kiwi_oemrebootinteractive</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-recovery&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-recovery&gt;</code></span></dt><dd><p>If this element is set to true (default value is
                    false), KIWI will create a recovery archive from the
                    prepared root tree. The archive will appear as
                      <code class="filename">/recovery.tar.bz2</code> in the
                    image file. During first boot of the image a single
                    recovery partition will be created and the recovery
                    archive will be moved to the recovery partition. An
                    additional boot menu entry is created that when
                    selected restores the original root tree on the
                    system. The user information on the <code class="filename">/home</code><a class="indexterm" name="idm140065371078768"></a> partition or in
                    the <code class="filename">/home</code><a class="indexterm" name="idm140065371077024"></a>
                    directory is not affected by the recovery process.
                    This value is represented by the kiwi_oemrecovery
                    variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-recoveryID&gt;</code>partition-id<code class="sgmltag-endtag">&lt;/oem-recoveryID&gt;</code></span></dt><dd><p>Specify the partition type for the recovery
                    partition. The default is to create a Linux
                    partition (id = 83). This value is represented by
                    the <code class="varname">kiwi_oemrecoveryID</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-silent-boot&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-silent-boot&gt;</code></span></dt><dd><p>Specify if the system should boot in silent mode
                    after the oem image has been deployed to the designated
                    storage device (default value is false). This value
                    is represented by the <code class="varname">kiwi_oemsilentboot</code>
                    variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-shutdown&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-shutdown&gt;</code></span></dt><dd><p>Specify if the system is to be powered down after
                    the oem image has been deployed to the designated
                    storage device (default value is false). This value
                    is represented by the <code class="varname">kiwi_oemshutdown</code>
                    variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-shutdown-interactive&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-shutdown-interactive&gt;</code></span></dt><dd><p>Specify if the system is to be powered down after
                    the oem image has been deployed to the designated
                    storage device (default value is false). Prior to
                    shutdown a message is posted and must be acknowledged
                    by the user in order for the system to power off. This
                    value is represented by the
                    <code class="varname">kiwi_oemshutdowninteractive</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-swap&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-swap&gt;</code></span></dt><dd><p>Specify if a swap partition should be created.
                    The creation of a swap partition is the default
                    behavior. This value is represented by the
                      <code class="varname">kiwi_oemswap</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-swapsize&gt;</code>number in MB<code class="sgmltag-endtag">&lt;/oem-swapsize&gt;</code></span></dt><dd><p>Set the size of the swap partition. If a swap
                    partition is to be created and the size of the swap
                    partition is not specified with this optional
                    element, KIWI will calculate the size of the swap
                    partition and create a swap partition equal to two
                    times the RAM installed on the system at initial
                    boot time. This value is represented by the
                      <code class="varname">kiwi_oemswapMB</code> variable in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-systemsize&gt;</code>number in MB<code class="sgmltag-endtag">&lt;/oem-systemsize&gt;</code></span></dt><dd><p>Set the size the operating system is allowed to
          consume on the target disk. The size limit does not
          include any consideration for swap space or a
          recovery partition.
          In a setup <span class="emphasis"><em>without</em></span> a
          <code class="sgmltag-element">systemdisk</code> element
          this value specifies the size of the root partition.
          In a setup <span class="emphasis"><em>including</em></span>
          a <code class="sgmltag-element">systemdisk</code> element
          this value specifies the size of the LVM partition which
          contains all specified volumes. Thus, the sum of all
          specified volume sizes plus the sum of the specified
          freespace for each volume must be smaller or equal
          to the size specified with the
          <code class="sgmltag-element">oem-systemsize</code>.
          This value is represented by the variable
          <code class="varname">kiwi_oemrootMB</code> in the initrd</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-unattended&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-unattended&gt;</code></span></dt><dd><p>The installation of the image to the target system
                      occurs automatically without requiering user
                      interaction. If multiple possible target devices are
                      discovered the image is deployed to the first device.
                      <code class="varname">kiwi_oemunattended</code> in the initrd</p></dd></dl></div></dd><dt><span class="term"><code class="sgmltag-element">pxedeploy</code></span></dt><dd><p>Information contained in the optional
                <code class="sgmltag-element">pxedeploy</code> section is only considered
              if the <code class="sgmltag-attribute">image</code><a class="indexterm" name="idm140065371043792"></a>
              attribute of the <code class="sgmltag-element">type</code> element is set to
                <code class="sgmltag-attvalue">pxe</code>. In order to use
              a PXE image it is necessary to create a network boot
              infrastructure. Creation of the network boot
              infrastructure is simplified by the KIWI provided package
                <span class="package">kiwi-pxeboot</span>. This package configures
              the basic PXE boot environment as expected by KIWI pxe
              images. The <span class="package">kiwi-pxeboot</span> package
              creates a directory structure in
                <code class="filename">/srv/tftpboot</code>. Files created by the
              KIWI create step need to be copied to the
                <code class="filename">/srv/tftpboot</code> directory structure.
              For additional details about the PXE image please refer
              to the PXE Image chapter later in this document. </p><p>In addition to the image files it is necessary that
              information be provided about the client setup. This
              information, such as the image to be used or the
              partitioning, is contained in a file with the name
                  <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
              in the directory <code class="filename">/srv/tftpboot/KIWI</code>.
              The content of this file is created automatically by KIWI
              if the pxedeploy section is provided in the image
              description. A pxedeploy section is outlined below: </p><pre class="screen">&lt;pxedeploy server="IP" blocksize="4096"&gt;
   &lt;timeout&gt;seconds&lt;/timeout&gt;
   &lt;kernel&gt;kernel-file&lt;/kernel&gt;
   &lt;initrd&gt;initrd-file&lt;/initrd&gt; 
   &lt;partitions device="/dev/sda"&gt; 
     &lt;partition type="swap" number="1" size="MB"/&gt; 
     &lt;partition type="L" number="2" size="MB"
              mountpoint="/" target="true"/&gt; 
     &lt;partition type="fd"  number="3"/&gt; 
   &lt;/partitions&gt; 
   &lt;union ro="dev" rw="dev" type="clicfs"/&gt; 
   &lt;configuration source="/KIWI/../file" dest="/../file" arch="..."/&gt;
   &lt;configuration .../&gt; 
&lt;/pxedeploy&gt; </pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The <code class="sgmltag-attribute">server</code><a class="indexterm" name="idm140065371033824"></a>
                  attribute is used to specify the IP address of the PXE
                  server. The <code class="sgmltag-attribute">blocksize</code><a class="indexterm" name="idm140065371032192"></a> attributes specifies the
                  blocksize for the image download. Other protocols are
                  supported by KIWI but require the
                    <em class="parameter"><code>kiwiserver</code></em> and
                    <em class="parameter"><code>kiwiservertype</code></em> kernel
                  parameters to be set when the client boots. </p></li><li class="listitem"><p>The value of the optional
                    <code class="sgmltag-element">timeout</code> element specifies the
                  grub timeout in seconds to be used when the KIWI
                  initrd configures and installs the grub boot loader on
                  the client machine after the first deployment to allow
                  standalone boot. </p></li><li class="listitem"><p>Passing kernel parameters is possible with the use
                  of the optional <code class="sgmltag-attribute">kernelcmdline</code><a class="indexterm" name="idm140065371026864"></a> attribute in the
                    <code class="sgmltag-element">type</code> section. The value of this
                  attribute is a string specifying the settings to be
                  passed to the kernel by the GRUB bootloader. The KIWI
                  initrd includes these kernel options when installing
                  grub for standalone boot </p></li><li class="listitem"><p>The optional <code class="sgmltag-element">kernel</code> and
                    <code class="sgmltag-element">initrd</code> elements are used to
                  specify the file names for the kernel and initrd on
                  the boot server respectively. When using a special
                  boot method not supported by the distribution’s
                  standard mkinitrd, it is imperative that the KIWI
                  initrd remains on the PXE server and also be used for
                  local boot. If the configured image uses the
                    <code class="sgmltag-element">split</code> type or the
                    <code class="sgmltag-element">pxedeploy</code> section includes any
                  union information the kernel and initrd elements must
                  be used. </p></li><li class="listitem"><p>The <code class="sgmltag-element">partitions</code> section is
                  required if the system image is to be installed on a
                  disk or other permanent storage device. Each partition
                  is specified with one partition child element. The
                  mandatory type attribute specifies the partition type
                  id.</p><p>The required <code class="sgmltag-attribute">number</code><a class="indexterm" name="idm140065371019424"></a> attribute provides the number
                  of the partition to be created. The size of the
                  partition may be specified with the optional size
                  attribute. The optional mountpoint attribute provides
                  the value for the mount point of the partition. The
                  optional boolean target attribute identifies the
                  partition as the system image target partition. KIWI
                  always generates the swap partition as the first
                  partition of the netboot boot image. By default, the
                  second partition is used for the system image. Use the
                  boolean <code class="sgmltag-attribute">target</code><a class="indexterm" name="idm140065371017216"></a>
                  attribute to change this behavior. Providing the value
                  image for the <code class="sgmltag-attribute">size</code><a class="indexterm" name="idm140065371015584"></a> attribute triggers KIWI into
                  calculating the required size for this partition. The
                  calculated size is sufficient for the created image.
                  </p></li><li class="listitem"><p>If the system image is based on a read-only
                  filesystem such as squashfs and should be mounted in
                  read-write mode use the optional union element. The
                  type attribute is used to specify one of the supported
                  overlay filesystem <code class="systemitem">clicfs</code><a class="indexterm" name="idm140065371012560"></a>
                  Use the ro
                  attribute to point to the read only device and the rw
                  attribute to point to the read-write device. </p></li><li class="listitem"><p>The optional <code class="sgmltag-element">configuration</code>
                  element is used to integrate a network client’s
                  configuration files that are stored on the server. The
                  source attribute specifies the path on the server for
                  the file to be downloaded. The dest attribute
                  specifies destination of the downloaded file on the
                  network client starting at the root (/) of the
                  filesystem. Multiple configuration elements may be
                  specified such that multiple files can be transferred
                  to the network client. In addition configuration files
                  can be bound to a specific client architecture by
                  setting the optional arch attribute. To specify
                  multiple architectures use a comma separated string.
                </p></li></ul></div></dd><dt><span class="term"><code class="sgmltag-element">size</code></span></dt><dd><p>Use the size element to specify the image size in
              Megabytes or Gigabytes. The unit attribute specifies
              whether the given value will be interpreted as Megabytes
                (<code class="sgmltag-attribute">unit</code><a class="indexterm" name="idm140065371005744"></a>="<code class="sgmltag-attvalue">M</code>") or Gigabytes (<code class="sgmltag-attribute">unit</code><a class="indexterm" name="idm140065371003616"></a>="<code class="sgmltag-attvalue">G</code>"). The optional boolean
              attribute additive specifies whether or not the given size
              should be added to the size of the generated image or not. </p><p>In the event of a size specification that is too small
              for the generated image, KIWI will expand the size
              automatically unless the image size exceeds the specified
              size by 100 MB or more. In this case KIWI will generate an
              error and exit. </p><p>Should the given size exceed the necessary size for
              the image KIWI will not alter the image size as the free
              space might be required for proper execution of components
              within the image. </p><p>If the size element is not used, KIWI will create an
              image containing approximately 30 % free space. </p><pre class="screen">&lt;size unit="M"&gt;1000&lt;/size&gt;</pre></dd><dt><span class="term"><code class="sgmltag-element">split</code></span></dt><dd><p>For images of type split or iso the information
              provided in the optional <code class="sgmltag-element">split</code> section
              is considered if the compressed attribute is set to
              true. With the configuration in this block it is possible
              to determine which files are writable and whether these
              files should be persistently writable or temporarily. Note
              that for ISO images only temporary write access is
              possible. </p><p>When processing the provided configuration KIWI
              distinguishes between directories and files. For example,
              providing <code class="filename">/etc</code><a class="indexterm" name="idm140065370994720"></a> as
              the value of the name attribute indicates that the
                <code class="filename">/etc</code><a class="indexterm" name="idm140065370992880"></a> directory
              should be writable. However, this does not include any of
              the files or sub-directories within <code class="filename">/etc</code><a class="indexterm" name="idm140065370990992"></a>. The content of /etc
              is populated as symbolic links to the read-only files. The
              advantage of setting only a directory to read-write access
              is that any newly created files will be stored on the disk
              instead of in <code class="systemitem">tmpfs</code><a class="indexterm" name="idm140065370988960"></a>. Creating read-write access to a
              directory and it’s files requires two specifications as
              shown below. </p><pre class="screen">&lt;split&gt; 
  &lt;temporary&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- read/write access to --&gt;</code>
    &lt;file name="/var"/&gt; 
    &lt;file name="/var/*"/&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- but not on this file: --&gt;</code>
    &lt;except name="/etc/shadow"/&gt; 
  &lt;/temporary&gt;
  &lt;persistent&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- persistent read/write access to: --&gt;</code>
    &lt;file name="/etc"/&gt; 
    &lt;file name="/etc/*"/&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- but not on this file: --&gt;</code>
    &lt;except name="/etc/passwd"/&gt; 
  &lt;/persistent&gt;
&lt;/split&gt;</pre><p>Use the except element to specify exceptions to
              previously configured rules. </p></dd><dt><span class="term"><code class="sgmltag-element">machine</code></span></dt><dd><p>The optional machine section serves to specify
              information about a VM guest machine. Using the data
              provided in this section, KIWI will create a guest
              configuration file required to run the image on the target
              machine. </p><p>If the target is a VMware virtual machine indicated by
              the format attribute set to vmdk, KIWI creates a VMware
              configuration file. If the target is a Xen virtual machine
              indicated by the domain attribute in the machine section
              KIWI will create a Xen guest config file. </p><p>The sample block below shows the general outline of
              the information that can be specified to generate the
              configuration file </p><pre class="screen">&lt;machine arch="arch" memory="MB"
  HWversion="number" guestOS="suse|sles"
  domain="dom0|domU"/&gt; 
   &lt;vmconfig-entry&gt;Entry_for_VM_config_file&lt;\vmconfig-entry&gt;
   &lt;vmconfig-entry .../&gt;
   &lt;vmnic driver="name" interface="number" mode="mode"/&gt; 
   &lt;vmnic ...&gt;
   &lt;vmdisk controller="ide|scsi" id="number"/&gt; 
   &lt;vmdvd  controller="ide|scsi" id="number"/&gt; 
&lt;/machine&gt; </pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">arch</code><a class="indexterm" name="idm140065370978080"></a></span></dt><dd><p> The virtualized architecture. Supported values
                    are <code class="sgmltag-attvalue">ix86</code> or
                      <code class="sgmltag-attvalue">x86_64</code>. The
                    default value is <code class="sgmltag-attvalue">ix86</code>. </p></dd><dt><span class="term"><code class="sgmltag-attribute">memory</code><a class="indexterm" name="idm140065370973328"></a></span></dt><dd><p> The mandatory <code class="sgmltag-attribute">memory</code><a class="indexterm" name="idm140065370971312"></a> attribute specifies how much
                    memory in MB should be allocated for the virtual
                    machine </p></dd><dt><span class="term"><code class="sgmltag-attribute">HWversion</code><a class="indexterm" name="idm140065370968896"></a></span></dt><dd><p> The VMware hardware version number, the default
                    value is <code class="sgmltag-attvalue">3</code>.
                  </p></dd><dt><span class="term"><code class="sgmltag-attribute">guestOS</code><a class="indexterm" name="idm140065370965392"></a></span></dt><dd><p> The guest OS identifier. For the ix86
                    architecture the default value is suse and for the
                    x86_64 architecture suse-64 is the default. At this
                    point only the SUSE and SLES guestOS types are
                    supported. </p></dd><dt><span class="term"><code class="sgmltag-attribute">domain</code><a class="indexterm" name="idm140065370962304"></a></span></dt><dd><p> The Xen domain setup. This could be either a
                    dom0 which is the host machine hosting the guests
                    and therefore doesn’t require a configuration file,
                    or it could be set to domU which indicates this is a
                    guest and also requires a guest configuration which
                    is created by KIWI. </p></dd></dl></div><p>Use the <code class="sgmltag-element">vmconfig-entry</code>
              element to create entries in the virtual machine's configuration
              file; .vmx for VMware images and .xenconfig for Xen images.
              You may specify as many configuration options as desired. The
              value of the <code class="sgmltag-element">vmconfig-entry</code>
              element is expected to be specified in the syntax required by
              the VM configuration file to be written. The value is free
              format text and is not validated by Kiwi in any way. The entry
              is written to the VM configuration file verbatime.</p><p>Use the <code class="sgmltag-element">vmdisk</code> element
              to setup the virtual main storage device.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm140065370955072"></a></span></dt><dd><p> Supported values for the mandatory <code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm140065370953056"></a> attribute
                    are <code class="sgmltag-attvalue">ide</code> and
                      <code class="sgmltag-attvalue">scsi</code>. </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="idm140065370949536"></a></span></dt><dd><p>The mandatory <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm140065370947520"></a> attribute specifies the disk id. If
                    only one disk is set the id value should be set to
                    0. </p></dd><dt><span class="term"><code class="sgmltag-attribute">device</code><a class="indexterm" name="idm140065370945104"></a></span></dt><dd><p> The device attribute specifies the disk that
                    should appear in the para virtual instance.
                    Therefore only relevant for Xen </p></dd></dl></div><p>Use the <code class="sgmltag-element">vmdvd</code> element
              to setup a virtual optical drive (CD/DVD) connection</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm140065370940656"></a></span></dt><dd><p> Supported values for the mandatory <code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm140065370938640"></a> attribute
                    are <code class="sgmltag-attvalue">ide</code> and
                      <code class="sgmltag-attvalue">scsi</code>. </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="idm140065370935120"></a></span></dt><dd><p>The mandatory <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm140065370933104"></a> attribute specifies the disk id. If
                    only one disk is set the id value should be set to
                    0. </p></dd></dl></div><p>Use the <code class="sgmltag-element">vmnic</code> element
              to setup the virtual network interface. Multiple
              <code class="sgmltag-element">vmnic</code> child elements may be
              specified to setup multiple virtual network interfaces.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">driver</code><a class="indexterm" name="idm140065370928464"></a></span></dt><dd><p> The mandatory <code class="sgmltag-attribute">driver</code><a class="indexterm" name="idm140065370926448"></a> attribute specifies the driver
                    to be used for the virtual network card. The
                    supported values are <code class="sgmltag-attvalue">e100</code>, <code class="sgmltag-attvalue">vlance</code>, and <code class="sgmltag-attvalue">vmxnet</code>. If the vmxnet driver is
                    specified the vmware tools must be installed in the
                    image. </p></dd><dt><span class="term"><code class="sgmltag-attribute">interface</code><a class="indexterm" name="idm140065370922000"></a></span></dt><dd><p> The mandatory <code class="sgmltag-attribute">interface</code><a class="indexterm" name="idm140065370919984"></a> attribute specifies the
                    interface number. If only one interface is set the
                    value should be set to 0. </p></dd><dt><span class="term"><code class="sgmltag-attribute">mode</code><a class="indexterm" name="idm140065370917552"></a></span></dt><dd><p> The network mode used to communicate outside
                    the VM. In many cases the bridged mode is used.
                  </p></dd></dl></div></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.users"></a>5.1.5. <code class="sgmltag-element">users</code> Element<span class="permalink"><a alt="Permalink" title="5.1.5. users Element" href="#sec.description.users">¶</a></span></h3></div></div></div><pre class="screen">&lt;users group="group_name" id="number"&gt; 
  &lt;user home="dir" id="number" name="user" password="..."
        pwdformat="encrypted|plain" realname="string" shell="path"/&gt;
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/users&gt;</pre><p>The optional <code class="sgmltag-element">users</code> element lists the users belonging to the
        group specified with the <code class="sgmltag-attribute">group</code><a class="indexterm" name="idm140065370910832"></a> attribute. At least one user
        child element must be specified as part of the <code class="sgmltag-element">users</code> element.
        Multiple users elements may be specified. </p><p>The attributes <code class="sgmltag-attribute">home</code><a class="indexterm" name="idm140065370908384"></a>,
          <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm140065370906880"></a>, <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm140065370905376"></a>, <code class="sgmltag-attribute">pwd</code><a class="indexterm" name="idm140065370903872"></a>, <code class="sgmltag-attribute">realname</code><a class="indexterm" name="idm140065370902368"></a>,
        and <code class="sgmltag-attribute">shell</code><a class="indexterm" name="idm140065370900864"></a> specify the
        created users home directory, the user name, the user’s
        password, the user’s real name, and the user’s login shell,
        respectively. By default, the value of the password attribute is
        expected to be an encrypted string. An encrypted password can be
        created using <span class="command"><strong>kiwi</strong></span>
        <code class="option">--createpassword</code>. It is also possible to
        specify the password as a non encrypted string by using the
        pwdformat attribute and setting it’s value to
          <span class="quote">“<span class="quote">plain</span>”</span>. KIWI will then encrypt the password
        prior to the user being added to the system. </p><p>All specified users and groups will be created if they do
        not already exist. By default, the defined users will be part of
        the group specified with the group attribute of the users
        element and the default group called <span class="quote">“<span class="quote">users</span>”</span>. If it
        is desired to have the specified users to only be part of the
        given group it is necessary to specify the <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm140065370895696"></a> attribute. It is recommended to
        use a group id greater than 100. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.drivers"></a>5.1.6. <code class="sgmltag-element">drivers</code> Element<span class="permalink"><a alt="Permalink" title="5.1.6. drivers Element" href="#sec.description.drivers">¶</a></span></h3></div></div></div><pre class="screen">&lt;drivers profiles="name"&gt; 
  &lt;file name="filename"/&gt; 
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code> 
&lt;/drivers&gt;</pre><p>The optional <code class="sgmltag-element">drivers</code> element is only
        useful for boot images (initrd). As a boot image doesn’t need to
        contain the complete kernel one can save a lot of space if only
        the required drivers are part of the image. Therefore the
        drivers section exists. If present only the drivers which
        matches the file names or glob patterns will be included into
        the boot image. Each file is specified relative to the
        <code class="filename">/lib/modules/<em class="replaceable"><code>Version</code></em>/kernel</code><a class="indexterm" name="idm140065370889264"></a> directory.</p><p>According to the <code class="sgmltag-element">driver</code> element the
        specified files are searched in the corresponding directory. The
        information about the driver names is provided as environment
        variable named like the value of the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065370886768"></a> attribute and is processed by the function
          <code class="function">suseStripKernel</code>. According to this along
        with a boot image description a script called
          <span class="command"><strong>images.sh</strong></span> must exist which calls this
        function in order to allow the driver information to have any
        effect. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.repository"></a>5.1.7. <code class="sgmltag-element">repository</code> Element<span class="permalink"><a alt="Permalink" title="5.1.7. repository Element" href="#sec.description.repository">¶</a></span></h3></div></div></div><pre class="screen">&lt;repository type="type" alias="name" imageinclude="true|false"
              password="password" priority="number" status="replaceable"
              username="user-name"&gt; &lt;source path="URL"/&gt;
&lt;/repository&gt;</pre><p>The mandatory <code class="sgmltag-element">repository</code> element
        specifies the location and type of a repository to be used by the 
        package manager as a package installation source. The mandatory
        <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065370880352"></a> attribute
        specifies the repository type. A specified repository can only be
        accessed by the chosen package manager if the given type is supported
        by the specified package manager. KIWI supports smart or zypper as
        package managers, specified with the <code class="sgmltag-element">
        packagemanager</code> element. The default package manager is
        zypper. The following table shows the possible 
        supported repository types for each package manager:</p><div class="table"><a name="tab.description.supported-types"></a><p class="title"><b>Table 5.1. Supported package manager repo types</b><span class="permalink"><a alt="Permalink" title="Table 5.1. Supported package manager repo types" href="#tab.description.supported-types">¶</a></span></p><div class="table-contents"><table summary="Supported package manager repo types" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Type</th><th>smart</th><th>zypper</th><th>apt</th><th>yum</th></tr></thead><tbody><tr><td>apt-deb</td><td>yes</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>rpm-dir</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>rpm-md</td><td>yes</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>yast2</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr></tbody></table></div></div><br class="table-break"><p>The <code class="sgmltag-element">repository</code> element
        has the following optional attributes: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">alias</code><a class="indexterm" name="idm140065370861968"></a>="<code class="sgmltag-attvalue">name</code>"</span></dt><dd><p>Specifies an alternative name for the configured
              repository. If the attribute is not specified KIWI will generate
              an alias name by replacing any <span class="quote">“<span class="quote">/</span>”</span> in the given 
              repository location with an <span class="quote">“<span class="quote">_</span>”</span>. It is helpful to
              set an alias name if the repository path is insufficient in
              expressing the purpose of the contained packages.</p></dd><dt><span class="term"><code class="sgmltag-attribute">imageinclude</code><a class="indexterm" name="idm140065370857216"></a>="<code class="sgmltag-attvalue">true|false</code>"</span></dt><dd><p>Specifies whether the given repository should be configured
              as a repository in the image or not. The default behavior is
              that repositories used to build an image are not configured
              as a repository inside the image. This feature allows you to
              change the behavior by setting the value to <code class="sgmltag-attvalue">true</code>. The repository is configured
              in the image according to the source path as specified with the
              <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm140065370853328"></a> attribute of the
              <code class="sgmltag-element">source</code> element. Therefore,
              if the path is not a fully qualified URL, you may need to adjust
              the repository file in the image to accomodate the expected
              location. It is recommended that you use the
              <code class="sgmltag-attribute">alias</code><a class="indexterm" name="idm140065370850944"></a> attribute in
              combination with the
              <code class="sgmltag-attribute">imageinclude</code><a class="indexterm" name="idm140065370849360"></a> attribute to
              avoid having unpredictable random names assigned to the
              repository you wish to include in the image. This also
              facilitates modification of the "baseurl" entry in the .repo
              file from the config.sh script if you need to make adjustments
              to the path.</p></dd><dt><span class="term"><code class="sgmltag-attribute">password</code><a class="indexterm" name="idm140065370846736"></a>="<code class="sgmltag-attvalue">string</code>"</span></dt><dd><p>Specifies a password for the given repository. The
               <code class="sgmltag-attribute">password</code><a class="indexterm" name="idm140065370843888"></a> attribute must
               be used in combination with the <code class="sgmltag-attribute">
               username</code><a class="indexterm" name="idm140065370842304"></a> attribute. Dependent on the
               repository location this information may not be used.
             </p></dd><dt><span class="term"><code class="sgmltag-attribute">prefer-license</code><a class="indexterm" name="idm140065370839904"></a>="<code class="sgmltag-attvalue">true|false</code>"</span></dt><dd><p>The repository providing this attribute will be used
        primarly to install the license tarball if found on that
        repository. If no repository with a prefered license attribute
        exists, the search happens over all repositories. It's not
        guaranteed in that case that the search order follows the
        repository order like they are written into the XML
        description.</p></dd><dt><span class="term"><code class="sgmltag-attribute">priority</code><a class="indexterm" name="idm140065370835552"></a>="<code class="sgmltag-attvalue">number</code>"</span></dt><dd><p>Specifies the repository priority for this given repository.
              Priority values are treated differently by different package
              managers. Repository priorities allow the package management
              system to disambiguate packages that may be contained in more
              than one of the configured repositories. The smart package
              manager treats packages from repositories with the 
              <span class="emphasis"><em>highest</em></span> priority number as preferable to
              packages from a repository with a lower priority number.
              The value 0 means <span class="quote">“<span class="quote">no priority is set</span>”</span>. The
              zypper package manager prefers packages from a repository with 
              a <span class="emphasis"><em>lower</em></span> priority over packages from
              a repository with higher priority values. The value 99 means
              <span class="quote">“<span class="quote">no priority is set</span>”</span>.</p></dd><dt><span class="term"><code class="sgmltag-attribute">status</code><a class="indexterm" name="idm140065370829616"></a>="<code class="sgmltag-attvalue">replaceable</code>"</span></dt><dd><p>This attribute should only be applied in the context of a
              boot image description. Setting the <code class="sgmltag-attribute">
              status</code><a class="indexterm" name="idm140065370826720"></a> to <code class="sgmltag-attvalue">replaceable
              </code> indicates that the specified repository my be
              replaced by the repositories specified in the image description.
              This is important as the KIWI generated boot image, if required,
              should be created based on packages from the same repositories
              used to build the system image.
            </p></dd><dt><span class="term"><code class="sgmltag-attribute">username</code><a class="indexterm" name="idm140065370823472"></a>="<code class="sgmltag-attvalue">name</code>"</span></dt><dd><p>Specifies a user name for the given repository. The
               <code class="sgmltag-attribute">username</code><a class="indexterm" name="idm140065370820624"></a> attribute must
               be used in combination with the <code class="sgmltag-attribute">
               password</code><a class="indexterm" name="idm140065370819040"></a> attribute. Dependent on the
               repository location this information may not be used.
             </p></dd></dl></div><p>When specifying an https location for a repository it is
        generally necessary to include the <span class="quote">“<span class="quote">openssl-certs</span>”</span> and
        <span class="quote">“<span class="quote">cracklib-dict-full</span>”</span> packages in the 
        <code class="sgmltag-attvalue">bootstrap</code> section of the
        image configuration.</p><p>The location of a repository is specified by the 
        <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm140065370814672"></a> attribute of the
        mandatory <code class="sgmltag-element">source</code> child element.
        The location specification may include the
        <code class="systemitem">%arch</code><a class="indexterm" name="idm140065370812208"></a> macro which will expand
        to the architecture of the image building host. The value for the 
        <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm140065370810576"></a> attribute may begin with
        any of the following location indicators:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="uri">dir:///local/path</code></span></dt><dd><p>An absolute path to a directory accessible through the
              local file system. The <span class="quote">“<span class="quote">dir://</span>”</span> prefix may
              be omitted.</p></dd><dt><span class="term"><code class="uri">ftp://<em class="replaceable"><code>URL</code></em></code></span></dt><dd><p>A ftp protocol based network location. </p></dd><dt><span class="term"><code class="uri">http://<em class="replaceable"><code>URL</code></em></code></span></dt><dd><p>A http protocol based network location. </p></dd><dt><span class="term"><code class="uri">https://<em class="replaceable"><code>URL</code></em></code></span></dt><dd><p>A https protocol based network location. See the comment
              above about the handling of certificates and additional
              package requirements in the <code class="sgmltag-attvalue">bootstrap
              </code> section of the image configuration.</p></dd><dt><span class="term"><code class="uri">iso://<em class="replaceable"><code>path/to/isofile</code></em></code></span></dt><dd><p>An absolute path to an .iso file accessible via the local
              file system. KIWI will loop mount the the .iso file to a
              KIWI created directory with a generated name. The generated path
              is provided to the specified package manager as a repository
              location.</p><p>Using multiple .iso files from the same SLE product, requires
              that all .iso files are located in the same directory. Only
              the first .iso file is to be specified as a repository in
              the <code class="filename">config.xml</code>. The first .iso file
              contains all information necessary for the package manager to
              locate packages that are contained in other .iso files of the
              same product. Attempting to use multiple .iso files
              in a series as standalone repositories will result in an
              error.</p></dd><dt><span class="term"><code class="uri">obs://$dir1/$dir2</code></span></dt><dd><p>A special network location used with the http protocol.
                The values of <code class="varname">$dir1</code> and 
                <code class="varname">$dir2</code> represent the project location in the 
                openSUSE build service. The location is evaluated as
                <code class="uri">this://repos/$dir1/$dir2</code>.</p><p>The <span class="quote">“<span class="quote">obs://</span>”</span> prefix is also valid as part
              of the value for the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065370792496"></a>
              attribute of the <code class="sgmltag-element">type</code>. If
              used with the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm140065370790368"></a>
              attribute it is evaluated as
              <code class="uri">this://images/$dir1/$dir2</code>.
            </p></dd><dt><span class="term"><code class="uri">opensuse://<em class="replaceable"><code>PROJECTNAME</code></em></code></span></dt><dd><p>A special network location used with the http protocol. The
              given <em class="replaceable"><code>PROJECTNAME</code></em> specifies a
              project in the openSUSE buildservice. The repository is a
              repository of type <code class="sgmltag-attvalue">rpm-md</code>.
              For example: <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm140065370785248"></a>=
              <code class="sgmltag-attvalue">"opensuse://openSUSE:10.3/standard"
              </code>. </p></dd><dt><span class="term"><code class="uri">plain://<em class="replaceable"><code>URI</code></em></code></span></dt><dd><p>A plain resource string. Everything following 'plain://'
             will be forwarded to the package manager without further
             modification. This type of location specification is useful when
             KIWI does not support a specific URI but the specified package
             manager does.
            </p></dd><dt><span class="term"><code class="uri">smb://<em class="replaceable"><code>Samba share pathname</code></em></code></span></dt><dd><p>A path to a samba share using the cifs protocol. KIWI
              creates a mount point and mounts the share including username
              and password, if specified. Access to the smb share from within
              the new root tree is provided via a cifs mount. Therefore, 
              the package providing the cifs tools must be included in the
              package list for the <code class="sgmltag-attvalue">bootstrap
              </code> section of the image configuration. At the time of
              this writing the package providing the cifs tools is called
              <span class="emphasis"><em>cifs-utils</em></span>. If any packages provided by the
              Samba share are used as part of the boot image the cifs tools
              must also be included in the boot image. This is accomplished
              with the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm140065370777136"></a>
              attribute of the <code class="sgmltag-element">package</code>
              element. This is shown in the example below:</p><pre class="screen">&lt;packages type="bootstrap"&gt;
  &lt;package name="cifs-utils" bootinclude="true"/&gt;
  &lt;/packages&gt;</pre></dd><dt><span class="term"><code class="uri">this://<em class="replaceable"><code>PATH</code></em></code></span></dt><dd><p><em class="replaceable"><code>PATH</code></em> is the relative location to
              the image description directory for the curent image.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.packages"></a>5.1.8. <code class="sgmltag-element">packages</code> Element<span class="permalink"><a alt="Permalink" title="5.1.8. packages Element" href="#sec.description.packages">¶</a></span></h3></div></div></div><pre class="screen">&lt;packages type="type" profiles="name" patternType="type"
   &lt;package name="name" arch="arch"/&gt; 
   &lt;package name="name" replaces="name"/&gt;
   &lt;package name="name" bootinclude="true" bootdelete="true"/&gt; 
   &lt;archive name="name" bootinclude="true"/&gt; 
   &lt;package .../&gt; 
   &lt;namedCollection name="name"/&gt; 
   &lt;namedCollection .../&gt;
   &lt;opensuseProduct name="name"/&gt; 
   &lt;opensuseProduct .../&gt; 
   &lt;ignore name="name"/&gt; 
   &lt;ignore .../&gt;
&lt;/packages&gt;</pre><p>The mandatory <code class="sgmltag-element">packages</code> element specifies
        the list of packages (element <code class="sgmltag-element">package</code>) and
        patterns (element <code class="sgmltag-element">namedCollection</code>) to be used
        with the image. The value of the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065370767232"></a> attribute specifies how the packages and
        patterns listed are handled, supported values are as follows: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attvalue">bootstrap</code></span></dt><dd><p>Bootstrap packages, list of packages for the new
              operating system root tree. The packages list the required
              components to support a chroot environment in the new
              system root tree, such as glibc. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">delete</code></span></dt><dd><p>Delete packages, list of packages to be deleted from
              the image being created. </p><p>When using the delete type only
                <code class="sgmltag-element">package</code> elements are considered, all
              other specifications such as
                <code class="sgmltag-element">namedCollection</code> are ignored. The
              given package names are stored in the
                $<code class="envar">delete</code><a class="indexterm" name="idm140065370760304"></a> environment variable of the
                <code class="filename">/.profile</code> file created by KIWI. The
              list of package names is returned by the
                <code class="function">baseGetPackagesForDeletion</code>
              function. This list can then be used to delete the
              packages ignoring requirements or dependencies. This can
              be accomplished in the <span class="command"><strong>config.sh</strong></span> or
                <span class="command"><strong>images.sh</strong></span> script by calling the following
              helper function: </p><pre class="screen"><span class="command"><strong>suseRemovePackagesMarkedForDeletion</strong></span></pre><p>Note, that the delete value is indiscriminate of the
              image type being built. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">image</code></span></dt><dd><p>Image packages, list of packages to be installed in
              the image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">iso</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building an ISO image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">oem</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building an OEM image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">pxe</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building an PXE image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">vmx</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building a vmx virtual image of any format.
            </p></dd></dl></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.descriptions.using-patterns"></a>5.1.8.1. Using Patterns<span class="permalink"><a alt="Permalink" title="5.1.8.1. Using Patterns" href="#sec.descriptions.using-patterns">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370743376"></a><p> Using a pattern name allows you to considerably shorten
          the list of specified packages in the <code class="filename">config.xml</code>
          file. A named pattern, specified with the <code class="sgmltag-element">namedCollection</code> element is a
          representation of a predefined list of packages. Specifying a
          pattern will install all packages listed in the named pattern to be
          installed in the image. Support for patterns is distribution specific
          and available with SLES, openSUSE, CentOS and RHEL. The
          optional <code class="sgmltag-attribute">patternType</code><a class="indexterm" name="idm140065370739504"></a> attribute
          on the 
          <code class="sgmltag-element">packages</code> element allows you to
          control the installation of dependent packages in the image.
          You may assigne one of the following values to the
          <code class="sgmltag-attribute">patternType</code><a class="indexterm" name="idm140065370737200"></a> attribute:
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">onlyRequired</code><a class="indexterm" name="idm140065370734928"></a></span></dt><dd><p>Incorporates only patterns and packages that
               the specifeid patterns and packages require. This is
               a "hard dependency" only resolution.
              </p></dd><dt><span class="term"><code class="sgmltag-attribute">plusRecommended</code><a class="indexterm" name="idm140065370731952"></a></span></dt><dd><p>Incorporates patterns and packages that are required
               and recommended by the specified patterns and packages
               in <code class="filename">config.xml</code>.
              </p></dd></dl></div><p>By default, only required patterns and packages are installed.
          KIWI depends on the package manager to resolve the specified list
          of patterns and packages against the specified repositories and
          complete the installation. Note that not all supported package
          managers support the use of named patterns, thus the value of the
          <code class="sgmltag-element">packageManager</code> element
          determines whether you are able to use named patterns or not.
          Should the list of specified packages result in a conflict the
          image creation process will stop and the information provided by
          the package manager will be captured in the build log and will be
          displayed in the terminal window where KIWI was started. The
          <code class="sgmltag-element">ignore</code> element may be of use
          in resolving such conflicts. However, the <code class="sgmltag-element">ignore</code> element is limited to effect
          packages named explicitely. Packages installed in the image through
          a named pattern are not effected by the <code class="sgmltag-element">ignore</code> element setting. THerefore,
          package conflicts created by packages within named patterns cannot
          be resolved using the ignore mechanism. Further, if a package is
          specified to be ignored, but is required by another package, then
          the required package is installed in the image via the automatic
          dependency resolution by the package manager in use.
        </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.architecture-restrictions"></a>5.1.8.2. Architecture Restrictions<span class="permalink"><a alt="Permalink" title="5.1.8.2. Architecture Restrictions" href="#sec.description.architecture-restrictions">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370723776"></a><p> To restrict a package to a specific architecture, use the
          arch attribute to specify a comma separated list of allowed
          architectures. Such a package is only installed if the build
          systems architecture (<span class="command"><strong>uname</strong></span>
          <code class="option">-m</code>) matches one of the specified values of
          the arch attribute. </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.packages.to.become.included"></a>5.1.8.3. Packages to Become Included Into the Boot Image<span class="permalink"><a alt="Permalink" title="5.1.8.3. Packages to Become Included Into the Boot Image" href="#sec.description.packages.to.become.included">¶</a></span></h4></div></div></div><p> The optional attributes bootinclude and bootdelete can be
          used to mark a package inside the system image description to
          become part of the corresponding boot image (initrd). This
          feature is most often used to specify bootsplash and/or
          graphics boot related packages inside the system image
          description but they are required to be part of the boot image
          as the data is used at boot time of the image.</p><p>Packages included into the boot image with the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm140065370718032"></a> are still included into
          the system image as well. If packages should only be included into
          the boot image, but not the system image, they need to be added to
          the <code class="sgmltag-element">packages</code> section of
          <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065370715696"></a>=<code class="sgmltag-attvalue">delete</code>.</p><p>If the
          bootdelete attribute is specified along with the bootinclude
          attribute this means that the selected package will be marked
          as a <span class="quote">“<span class="quote">to become deleted</span>”</span> package and is removed
          by the contents of the <span class="command"><strong>images.sh</strong></span> script of
          the corresponding boot image description.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.data.not.available"></a>5.1.8.4. Data not Available as Packages to Become Included<span class="permalink"><a alt="Permalink" title="5.1.8.4. Data not Available as Packages to Become Included" href="#sec.description.data.not.available">¶</a></span></h4></div></div></div><p> With the optional <code class="sgmltag-element">archive</code> element it’s
          possible to include any kind of data into the image. The
          archive elements expects the name of a tarball which must
          exist as part of the system image description. KIWI then picks
          up the tarball and installs it into the image. If the
          bootinclude attribute is set along with the archive element
          the data will also become installed into the boot image.
        </p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.appliance"></a>Chapter 6. Creating Appliances with KIWI</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.appliance.overview">6.1. Overview</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">6.2. The KIWI Model</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.crossplatform">6.3. Cross Platform Appliance Build</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.appliance.overview"></a>6.1. Overview<span class="permalink"><a alt="Permalink" title="6.1. Overview" href="#sec.appliance.overview">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065370707520"></a><p>Traditionally, computing functions such as word processing or
      e-mail handling are delivered as software applications. These
      applications are targeted to run on a computer with an installed
      general purpose operating system. Applications often have a
      specialized installer that must be run by the consumer (whether home
      computer user or an administrator in an IT department of a company) to
      install the application on the computer in question. For installation
      of an application on multiple computers the installation program must
      often be run on each computer where the application is to be installed.
      In most cases a given application uses only a small part of the
      capabilities provided by the general purpose operating system running
      on a computer. Additionally if an application needs special settings
      to be applied to the general purpose operating system, these often
      have to be set by the consumer after the installation is complete.
      These settings are often documented in an installation guide that
      consumers may or may not read. Last but not least, running a general
      purpose operating system to support an application that only requires
      a small part of the functionality provided by the general purpose OS
      is a waste of computing resources.</p><p>An appliance is the combination of the parts of a general
      purpose OS needed by a given application and the application itself,
      bundled and delivered as one unit. This unit may be delivered in
      a variety of formats, for example a ready to run virtual machine or
      a self installing system on optical media or a USB stick.</p><p>Compared to the traditional model of application delivery the
      appliance model has a number of advantages. The consumer no longer
      has to install a general purpose OS and the application in separate
      steps. The application is part of the appliance and the appliance
      provider, as the application expert, takes care of the application
      "installation". Further, the appliance provider takes care of any
      OS tuning that may benefit the application. Last but not least, the
      reduced size of the OS does not only consume fewer resources than
      a full blow "regular" install of a general purpose OS, but it also
      provides a reduced footprint for potential security exposure. From the
      application providers point of view there may be an opportunity to
      drop the implementation and maintenance of a specialized installer
      as the application installation no longer has to be "consumer friendly".
      </p><p>The traditional software delivery model certainly has it's place.
      However, for many purposes appliances present a more convenient
      mechanism for consumers.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.appliance.kiwi-model"></a>6.2. The KIWI Model<span class="permalink"><a alt="Permalink" title="6.2. The KIWI Model" href="#sec.appliance.kiwi-model">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065370700704"></a><p> With KIWI we started to use a different model. Instead of
      installing firewall software on top of a general purpose
      computer/operating system, the designers/engineers built images
      that are designed specifically for the task. These are so called
      appliances. When building appliances with KIWI the following
      proceeding has proven to work reliably. Nevertheless the following
      is just a recommendation and can be adapted to special needs and
      environments. </p><div class="procedure"><a name="proc.appliance.general-building"></a><ol class="procedure" type="1"><li class="step"><p>Choose an appropriate image description
          template from the provided KIWI examples. Add or adapt
          repositories, package names or both, according to the distribution
          you want to build an image for.</p></li><li class="step"><p>Allow the image to create an in-place git repository to
          allow tracking of non-binary changes. This is done by adding
          the following line into your <span class="command"><strong>config.sh</strong></span> script:</p><pre class="screen">baseSetupPlainTextGITRepository</pre></li><li class="step"><p>Decide for a testing environment. In my opinion a real
          hardware based test machine which allows to boot from USB is a
          good and fast approach. All template images provided by us
          contains an hybrid iso type setup which is suitable for this
          environment.
        </p></li><li class="step"><p>Build the live stick appliance by calling
          </p><pre class="screen"><span class="command"><strong>kiwi</strong></span><code class="option">--build template-name</code></pre><p>
          After successful creation of the
          image files find an USB stick which is able to store your
          appliance and plug it into a free USB port on your image build
          machine. The deployment of the generated hybrid iso file can be
          performed from any
          OS including Windows as long as a tool to dump data onto a disk
          device exists and is used.
        </p></li><li class="step"><p>Plug in the stick on your test machine and boot it.
        </p></li><li class="step"><p>After your test system has successfully booted from stick
          login into your appliance and start to tweak the system
          according to your needs. This includes all actions required to
          make the appliance work as you wish. Before you start take
          care for the following: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Create an initial package list. This can be done by
              calling: </p><pre class="screen"><span class="command"><strong>rpm</strong></span> -qa | <span class="command"><strong>sort</strong></span> &gt; /tmp/deployPackages</pre></li><li class="listitem"><p>Check the output of the command <span class="command"><strong>git</strong></span> <code class="option">status</code> and include
              everything which is unknown to git and surely will not be
              changed by you and will not become part of the image
              description overlay files to the <code class="filename">/.gitignore</code> files </p></li></ul></div><p>After the initial package list exists and the git
          repository is clean you can start to configure the system. You
          never should install additional software just by installing an
          unmanaged archive or build and install from source. It’s very
          hard to find out what binary files had been installed and it’s
          also not architecture safe. If there is really no other way
          for the software to become part of the image you should
          address this issue directly in your image description and the
            <span class="command"><strong>config.sh</strong></span> script but not after the
          initial deployment has happened. </p></li><li class="step"><p>As soon as your system works as expected your new
          appliance is ready to enter the final stage. At this point you
          have done several changes to the system but they are all
          tracked and should now become part of your image description.
          To include the changes into your image description the
          following process should be used: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Check the differences between the currently installed
              packages and the initial deployment list. This can be done
              by calling:</p><pre class="screen"><span class="command"><strong>rpm</strong></span> -qa | <span class="command"><strong>sort</strong></span> &gt; /tmp/appliancePackages
<span class="command"><strong>diff</strong></span> -u /tmp/deployPackages /tmp/appliancePackages</pre><p>Add those packages which are labeled with (+) to the
                <code class="sgmltag-starttag">&lt;packages
                type="image"&gt;</code> section of your config.xml file
              and remove those packages which has been removed (−)
              appropriately. If there are packages which has been
              removed against the will of the package manager make sure
              you address the uninstallation of these packages in your
                <span class="command"><strong>config.sh</strong></span> script. If you have
              installed packages from repositories which are not part of
              your <code class="filename">config.xml</code> file you should also
              add these repositories in order to allow KIWI to install
              the packages </p></li><li class="listitem"><p>Check the differences made in the configuration files.
              This can be easily done by calling: </p><pre class="screen"><span class="command"><strong>git</strong></span> diff &gt;/tmp/appliancePatch</pre><p>The created patch should become part of your image
              description and you should make sure the patch is applied
              when preparing the image. According to this the command: </p><pre class="screen"><span class="command"><strong>patch</strong></span> -p0 &lt; appliancePatch</pre><p>needs to be added as part of your
                <span class="command"><strong>config.sh</strong></span> script. </p></li><li class="listitem"><p>Check for new non binary files added. This can be done
              by calling: </p><pre class="screen"><span class="command"><strong>git</strong></span> status</pre><p>All files not under version control so far will be
              listed by the command above. Check the contents of this
              list make sure to add all files which are not created
              automatically to become part of your image description. To
              do this simply clone (copy) these files with respect to
              the filesystem structure as overlay files in your image
              description <code class="filename">root/</code><a class="indexterm" name="idm140065370663616"></a>
              directory. </p></li></ul></div></li><li class="step"><p> All your valuable work is now stored in one image
          description and can be re-used in all KIWI supported image
          types. </p></li></ol></div><p>Congratulation! To make sure the appliance works as expected
      prepare a new image tree and create an image from the new tree. If
      you like you can deactivate the creation of the git repository
      which will save you some space on the filesystem. If this
      appliance is a server I recommend to leave the repository because
      it allows you to keep track of changes during the live time of
      this appliance. </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.appliance.crossplatform"></a>6.3. Cross Platform Appliance Build<span class="permalink"><a alt="Permalink" title="6.3. Cross Platform Appliance Build" href="#sec.appliance.crossplatform">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065370658960"></a><p>Building appliances for one processor architecture on another
      processor architecture is in general not possible with KIWI. The
      exception is that it is possible to build 32 bit (ix86) appliances on a
      64 bit system running on the x86-64 architecture. This cross-platform
      limitation is based on the requirement that KIWI be able to execute
      installed software inside the unpacked image tree. If the software
      installed inside the unpacked image tree does not run on the
      architecture of the build platform then KIWI cannot build the
      appliance.</p><p>While KIWI has the <code class="option">--target-arch</code> command line
      argument to instruct the package manager <span class="emphasis"><em>zypper</em></span>
      to install packages for the specified architecture, this option
      is not intended to support cross-platform appliance builds.</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="idm140065370654800"></a>Part II. Usecases</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#chap.maintenance">7. Maintenance of Operating System Images</a></span></dt><dt><span class="chapter"><a href="#chap.migration">8. System Analysis/Migration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.migrate.create-clean-repository">8.1. Create a Clean Repository Set First</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.watch-overlay">8.2. Watch the Custom Files</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.checklist">8.3. Checklist</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.turn-system-into-image">8.4. Turn Into an Image…</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.iso">9. ISO Image / Live System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.iso.building">9.1. Building a live JeOS</a></span></dt><dt><span class="sect1"><a href="#sec.iso.using">9.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.iso.flavours">9.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">9.3.1. Split mode</a></span></dt><dt><span class="sect2"><a href="#sec.iso.hybrid-mode">9.3.2. Hybrid mode</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm140065370543536">9.4. USB stick images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm140065370540736">9.4.1. ISO Hybrid stick</a></span></dt><dt><span class="sect2"><a href="#idm140065370537040">9.4.2. OEM USB stick</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.vmx">10. VMX Image / Virtual Disks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vmx.building">10.1. Building a JeOS disk</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.using">10.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.flavours">10.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.vmx.vmware-support">10.3.1. VMware support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.lvm">10.3.2. LVM Support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.bootpartition">10.3.3. Extra Boot Partition</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.lxc">11. Linux Containers and Docker</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.lxc.building">11.1. Building a docker image</a></span></dt><dt><span class="sect1"><a href="#sec.lxc.using">11.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.lxc.details">11.3. Image Configuration Details</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.vagrant">12. Vagrant boxes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vagrant.building">12.1. Building a Base Box</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.box.details">12.2. Box Configuration Details</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.box.using">12.3. Using the box</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.docker">12.4. Vagrant with Docker</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.pxe">13. PXE Image / Thin Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.pxe.setting-up">13.1. Setting Up the Required Services</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.atftp-server">13.1.1. Atftp Server</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.dhcp-server">13.1.2. DHCP Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.building">13.2. Building a PXE filesystem JeOS</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.using">13.3. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.flavours">13.4. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.client-control-file">13.4.1. The PXE Client Control File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.client-config-file">13.4.2. The PXE Client Configuration File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.another-user">13.4.3. Use Different Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">13.4.4. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">13.4.5. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">13.4.6. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nfs">13.4.7. Root Tree Over NFS</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nbd">13.4.8. Root Tree Over NBD</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-aoe">13.4.9. Root Tree Over AoE</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">13.5. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm140065370084736">13.5.1. The Group Configuration File</a></span></dt><dt><span class="sect2"><a href="#idm140065370066736">13.5.2. The Group Details File</a></span></dt><dt><span class="sect2"><a href="#idm140065370056272">13.5.3.  Using Hardware Mapping to Provide Overrides</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.oem">14. OEM Image / Preload Systems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.oem.building">14.1. Building an OEM System with Installation DVD</a></span></dt><dt><span class="sect1"><a href="#sec.oem.using">14.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">14.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.installation">14.3.1. Specializing the OEM install process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partitioning">14.3.2. Influencing the OEM Partitioning</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">14.3.3. Partition Based Installation</a></span></dt><dt><span class="sect2"><a href="#sec.oem.pxe-based-installation">14.3.4. Network Based Installation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.xen">15. Xen Para- and Full virtual Images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.xen.dom0.building">15.1. Building a Dom0</a></span></dt><dt><span class="sect1"><a href="#sec.xen.dom0.using">15.2. Using the Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.pv.building">15.3. Building a Para Virtual Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.hvm.building">15.4. Building a Full Virtual Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">15.5. Using the Guest Images</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.raid">16. KIWI RAID Support</a></span></dt><dt><span class="chapter"><a href="#chap.partitions">17. KIWI Custom Partitions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#chap.partitions.lvm">17.1. Custom Partitioning via LVM</a></span></dt><dt><span class="sect1"><a href="#chap.partitions.btrfs">17.2. Custom Partitioning via Btrfs</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.encryption">18. KIWI Encryption Support </a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.maintenance"></a>Chapter 7. Maintenance of Operating System Images</h2></div></div></div><a class="indexterm" name="idm140065370653280"></a><p>
    Creating an image often results in an appliance solution for a
    customer and gives you the freedom of a working solution at that
    time. But software develops and you don’t want your solution to
    become outdated. Because of this together with an image people
    always should think of <span class="emphasis"><em>image-maintenance</em></span>. The
    following paragraph just reflects ideas how to maintain images
    created by KIWI:
   </p><div class="figure"><a name="fig.maintain"></a><p class="title"><b>Figure 7.1. Image Maintenance Scenarios</b><span class="permalink"><a alt="Permalink" title="Figure 7.1. Image Maintenance Scenarios" href="#fig.maintain">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/maintain.png" alt="Image Maintenance Scenarios"></div></div></div><br class="figure-break"><table border="0" summary="Simple list" class="simplelist"><tr><td>
    (1) Image Description as part of a versioning system like Git, Subversion,
    etc. to track changes
   </td></tr><tr><td>
    (2) Software package source changes
   </td></tr><tr><td>
    (3) Faster, because already prepared; cannot handle image description
    changes; requires free space to store <code class="filename">/tmp/myOSImage</code>
   </td></tr><tr><td>
    (4) Image Description changes
   </td></tr><tr><td>
    (5) Covers all possible changes, does not require storage for prepared
    trees, slower, because KIWI prepare runs again
   </td></tr></table><p>The picture in <a class="xref" href="#fig.maintain" title="Figure 7.1. Image Maintenance Scenarios">Figure 7.1</a> shows two possible
    scenarios which requires an image to become updated. The first
    reason for updating an image are changes to the software, for
    example a new kernel should be used. If this change doesn’t require
    additional software or changes in the configuration the update can
    be done by KIWI itself using its <code class="option">--upgrade</code> option.
    In combination with <code class="option">--upgrade</code> KIWI allows to add
    an additional repository which may be needed if the updated software
    is not part of the original repository. An important thing to know
    is that this additional repository is <span class="emphasis"><em>not</em></span>
    stored into the original <code class="filename">config.xml</code> file of the
    image description. </p><p>Another reason for updating an image beside software updates are
    configuration changes or enhancements, for example an image should
    have replaced its browser with another better browser or a new
    service like apache should be enabled. In principle it’s possible to
    do all those changes manually within the unpacked image root tree but
    concerning maintenance this would be a nightmare. Why, because it
    will leave the system in an unversioned condition. Nobody knows what
    has changed since the very first preparation of this image. So in
    short:</p><a class="indexterm" name="idm140065370636768"></a><div class="blockquote"><blockquote class="blockquote"><p>Don’t modify the unpacked image root tree manually!</p></blockquote></div><p>Changes to the image configuration should be done within the
    image description. The image description itself should be part of a
    versioning system like git. All changes can be tracked down
    then and maybe more important can be assigned to product tags and
    branches. As a consequence an image must be prepared from scratch
    and the old unpacked image root tree could be removed. </p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.migration"></a>Chapter 8. System Analysis/Migration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.migrate.create-clean-repository">8.1. Create a Clean Repository Set First</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.watch-overlay">8.2. Watch the Custom Files</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.checklist">8.3. Checklist</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.turn-system-into-image">8.4. Turn Into an Image…</a></span></dt></dl></div><a class="indexterm" name="idm140065370632672"></a><p>KIWI provides a module which allows you to analyse
    the running system and create a report and an image description
  representing the current state of the machine. Among others this allows
    you to clone your currently running system into an image. The
    process has the following limitations at the moment: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Works for SUSE systems only (with zypper on board) </p></li><li class="listitem"><p>The process works semi automatically which means depending
        on the complexity of the system some manual postprocessing might
        be necessary </p></li></ul></div><p>When calling KIWI’s analysis mode it will try to find the base
    version of your operating system and uses the currently active
    repositories specified in the zypper database to match the software
    which exists in terms of packages and patterns. The result is a list
    of packages and patterns which represents your system so far. Of
    course there are normally some data which doesn’t belong to any
    package. These are for example configurations or user data. KIWI
    collects all this information and provides it as custom data. In
    addition kiwi offers different data visualisations e.g unmanaged
    binary data. Along with the software analysis kiwi also checks
    for enabled systemd services, augeas configuration inventory and more.
    The process will not go beyond the scope of local filesystems.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.create-clean-repository"></a>8.1. Create a Clean Repository Set First<span class="permalink"><a alt="Permalink" title="8.1. Create a Clean Repository Set First" href="#sec.migrate.create-clean-repository">¶</a></span></h2></div></div></div><p> When starting with the analysis it is useful to let kiwi
      know about all the repositories from which packages has been
      installed to the system. In a first step call: </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --describe workstation </pre><p>This will create an HTML report where you can check which
      packages and patterns could be assigned to the given base
      repository. In almost all cases there will be information about
      packages which couldn’t be assigned. You should go to that list
      and think of the repository which contains that packages (Packman,
      etc). If something is missing add it either to the zypper list on
      your system or use the KIWI options <code class="option">--add-repo</code> …
        <code class="option">--add-repotype</code>. </p><p>Continue calling the following command only if your list is
      clean and no skipped packages are used except you know
      that this package can’t be provided or is not worth to become part
      of the description. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --describe workstation --nofiles [--skip package ... ]</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.watch-overlay"></a>8.2. Watch the Custom Files<span class="permalink"><a alt="Permalink" title="8.2. Watch the Custom Files" href="#sec.migrate.watch-overlay">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065370618496"></a><a class="indexterm" name="idm140065370617104"></a><p>Several reasons could lead to unmanaged data. In most cases
      these are user data like pictures, movies but also database
      files and external party software not installed as a package
      belongs to it. It's up to the user to decide if these data
      needs to be part of the description or not. Along with this
      important custom data there are unfortunately also a bunch of
      other custom data due to packaging inconsistencies or left
      over data as result of an upgrade process. These data taints
      your system and you are doing good in removing it.
      The quality of the description depends on how well the custom
      data tree is handled and how clean the system was when the
      analysis was started. Those data which should become part of
      the image description needs to be moved from the
      <code class="filename">/var/cache/kiwi/describe/worksation/custom</code> directory
      to the <code class="filename">/var/cache/kiwi/describe/worksation/root</code> directory</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.checklist"></a>8.3. Checklist<span class="permalink"><a alt="Permalink" title="8.3. Checklist" href="#sec.migrate.checklist">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065370612592"></a><a class="indexterm" name="idm140065370611200"></a><p> After that you should walk through the following check list </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Change author and contact in <code class="filename">config.xml</code>
        </p></li><li class="listitem"><p>Set appropriate name for your image in
            <code class="filename">config.xml</code>. </p></li><li class="listitem"><p>Add/modify default type (oem) set in <code class="filename">config.xml</code> if needed
        </p></li><li class="listitem"><p>If you want to access any remote filesystem it’s a good
          idea to let AutoYaST add them on first boot of the system
        </p></li><li class="listitem"><p>Check your network setup in
            <code class="filename">/etc/sysconfig/network</code>. Is this setup
          still possible in the cloned environment? Make sure you check
          for the MAC address of the card first. </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.turn-system-into-image"></a>8.4. Turn Into an Image…<span class="permalink"><a alt="Permalink" title="8.4. Turn Into an Image…" href="#sec.migrate.turn-system-into-image">¶</a></span></h2></div></div></div><p>After the process has finished you should check the size of
      the image description. The description itself shouldn’t be that
      big. The size of a migrated image description mainly depends on
      how many overlay files exists in the <code class="filename">root/</code><a class="indexterm" name="idm140065370600048"></a> directory. You should make sure to maintain
      only required overlay files. Now let’s try to create a clone image
      from the description. By default an OEM image which is a virtual
      disk which is able to run on real hardware too is created. On
      success you will also find a ISO file which is an installable
      version of the OEM image. If you burn the ISO on a DVD you can use
      that DVD to install your cloned image on another computer. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build /var/cache/kiwi/describe/workstation -d /tmp/myResult</pre><p>If everything worked well you can test the created OEM image
      in any full virtual operating system environment like Qemu or
        <span class="trademark">VMware</span>™. Once created the image
      description can serve for all image types KIWI supports. </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.iso"></a>Chapter 9. ISO Image / Live System</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.iso.building">9.1. Building a live JeOS</a></span></dt><dt><span class="sect1"><a href="#sec.iso.using">9.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.iso.flavours">9.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">9.3.1. Split mode</a></span></dt><dt><span class="sect2"><a href="#sec.iso.hybrid-mode">9.3.2. Hybrid mode</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm140065370543536">9.4. USB stick images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm140065370540736">9.4.1. ISO Hybrid stick</a></span></dt><dt><span class="sect2"><a href="#idm140065370537040">9.4.2. OEM USB stick</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm140065370594512"></a><a class="indexterm" name="idm140065370593120"></a><a class="indexterm" name="idm140065370591728"></a><p>A live system image is an operating System on CD or DVD. In
    principle one can treat the CD/DVD as the hard disk of the system
    with the restriction that you can’t write data on it. So as soon as
    the media is plugged into the computer, the machine is able to boot
    from that media. After some time one can login to the system and
    work with it like on any other system. By default All write actions
    takes place in RAM space and therefore all changes will be lost
    as soon as the computer shuts down.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.building"></a>9.1. Building a live JeOS<span class="permalink"><a alt="Permalink" title="9.1. Building a live JeOS" href="#sec.iso.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12.</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myiso-result --type iso</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.using"></a>9.2. Using the Image<span class="permalink"><a alt="Permalink" title="9.2. Using the Image" href="#sec.iso.using">¶</a></span></h2></div></div></div><p>There are two ways to use the generated ISO image: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Burn the <code class="filename">.iso</code><a class="indexterm" name="idm140065370584032"></a> file
          on a CD or DVD with your preferred burn program. Plug in the
          CD or DVD into a test computer and (re)boot the machine. Make
          sure the computer boot from the CD drive as first boot device.
        </p></li><li class="listitem"><p>Use a virtualization system to test the image directly.
          Testing an iso can be done with any full virtual system for
          example:</p><pre class="screen"><span class="command"><strong>qemu</strong></span> -cdrom /tmp/myiso-result/LimeJeOS-SLE12.x86_64-1.13.1.iso</pre></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.flavours"></a>9.3. Flavours<span class="permalink"><a alt="Permalink" title="9.3. Flavours" href="#sec.iso.flavours">¶</a></span></h2></div></div></div><p>
    KIWI supports different filesystems and boot methods along
    with the ISO image type. The provided example by default uses an
    <code class="systemitem">overlayfs</code><a class="indexterm" name="idm140065370578112"></a> based compressed
    root filesystem. overlayfs allows to combine two filesystems into
    one. The root filesystem exists as compressed squashfs filesystem
    and all write operations are redirected in RAM or in a persistent
    area on a disk. The result is a full writable live-system.

    The flags attribute in <code class="filename">config.xml</code> exists to be
    able to have the following alternative solutions:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">flags</code><a class="indexterm" name="idm140065370574784"></a>="<code class="sgmltag-attvalue">compressed</code>"</span></dt><dd><p> Does filesystem compression with squashfs, but don’t
            use an overlay filesystem for write support. A symbolic link
            list is used instead and thus a split element is required in
            <code class="filename">config.xml</code>. See the split mode
            section below for details. </p></dd><dt><span class="term"><code class="sgmltag-attribute">flags</code><a class="indexterm" name="idm140065370570096"></a>="<code class="sgmltag-attvalue">seed</code>"</span></dt><dd><p> Creates a <code class="systemitem">btrfs</code><a class="indexterm" name="idm140065370567088"></a> image and allows write operations
            into a cow (seed) file. In case of an ISO the seed device is created
            on a ramdisk.</p></dd><dt><span class="term">Flags Not Set</span></dt><dd><p>If no <code class="sgmltag-attribute">flags</code><a class="indexterm" name="idm140065370563888"></a>
            attribute is set no compressed filesystem, no overlay
            filesystem will be used. The root tree will be directly part
            of the ISO filesystem and the paths:
              <code class="filename">/bin</code>, <code class="filename">/boot</code>,
              <code class="filename">/lib</code>, <code class="filename">/lib64</code>,
              <code class="filename">/opt</code>, <code class="filename">/sbin</code>, and
              <code class="filename">/usr</code> will be read-only. </p></dd></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.split-mode"></a>9.3.1. Split mode<span class="permalink"><a alt="Permalink" title="9.3.1. Split mode" href="#sec.iso.split-mode">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370556896"></a><a class="indexterm" name="idm140065370555504"></a><p>If no overlay filesystem is in use but the image filesystem
        is based on a compressed filesystem KIWI allows to setup which
        files and directories should be writable in a so called split
        section. In order to allow to login into the system, at least
        the <code class="filename">/var</code><a class="indexterm" name="idm140065370552816"></a> directory should
        be writable. This is because the PAM authentication requires
        to be able to report any login attempt to
          <code class="filename">/var/log/messages</code> which therefore needs
        to be writable. The following split section can be used if the
        flag compressed is used: </p><pre class="screen">&lt;split&gt; 
  &lt;persistent&gt; 
     &lt;file name="/var"/&gt;
     &lt;file name="/var/*"/&gt; 
     &lt;file name="/boot"/&gt; 
     &lt;file name="/boot/*"/&gt; 
     &lt;file name="/etc"/&gt; 
     &lt;file name="/etc/*"/&gt; 
     &lt;file name="/home"/&gt; 
     &lt;file name="/home/*"/&gt;
     &lt;file name="/tmp"/&gt;
     &lt;file name="/tmp/*"/&gt;
  &lt;/persistent&gt; 
&lt;/split&gt;</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.hybrid-mode"></a>9.3.2. Hybrid mode<span class="permalink"><a alt="Permalink" title="9.3.2. Hybrid mode" href="#sec.iso.hybrid-mode">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370548480"></a><a class="indexterm" name="idm140065370547088"></a><p>
      A hybrid image is a iso image including a partition table and can
      therefore be attached as a CD/DVD <span class="emphasis"><em>and</em></span> as a
      normal disk to the system. This has the advantage that a hybrid
      iso live system can be burned to a CD/DVD as well as uploaded to
      a USB stick. In order to activate the hybrid feature the hybrid
      flag must be set to true as indicated below. 
    </p><pre class="screen">&lt;type image="iso" ... hybrid="true"/&gt;</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm140065370543536"></a>9.4. USB stick images<span class="permalink"><a alt="Permalink" title="9.4. USB stick images" href="#idm140065370543536">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065370542896"></a><p>
    kiwi supports two types of USB stick images. The first type which
    are the hybrid ISO images and basically the same as the live ISO images
    and the second type which are the OEM virtual disk images.
    The deployment of both types can be performed from any OS including
    Windows as long as a tool to dump data onto a disk device exists
    and is used.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm140065370540736"></a>9.4.1. ISO Hybrid stick<span class="permalink"><a alt="Permalink" title="9.4.1. ISO Hybrid stick" href="#idm140065370540736">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370540096"></a><p>
      As indicated above a hybrid iso image also works as USB stick image.
      If a hybrid iso is used like a disk image on a writable medium
      like a USB stick it's possible to write into a persistent area on
      the stick instead of the RAM. kiwi will create an additional ext2
      partition to store that information on the disk if the attribute
      hybridpersistent is set to true.
    </p><pre class="screen">&lt;type image="iso" ... hybridpersistent="true"/&gt;</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm140065370537040"></a>9.4.2. OEM USB stick<span class="permalink"><a alt="Permalink" title="9.4.2. OEM USB stick" href="#idm140065370537040">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370536400"></a><p> In contrast to the hybrid iso image it's also possible to
        create a oem virtual disk image which is dumped on the stick.
        The big advantage with this approach is, that it's possible to
        create a stick which contains a live OS but also a data
        partition for custom data. The data partition is a fat partition
        also recognized by the Windows operating system. In order to
        create such a Windows friendly stick one has to pass the option
          <code class="option">--fat-storage &lt;size-in-MB&gt;</code>.</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create ... --fat-storage 500</pre><p>If this option is set kiwi will use the syslinux bootloader for
        the image as well as the first partition as fat partition of the
        specified size. The live OS itself will live in a LVM which
        allows easy manipulation of the logical root volume. For further
        information about the OEM image type please refer to the OEM
        chapter <a class="xref" href="#chap.oem" title="Chapter 14. OEM Image / Preload Systems">Chapter 14, <i>OEM Image / Preload Systems</i></a>
      </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm140065370531344"></a>9.4.2.1. OEM compressed / readonly USB stick<span class="permalink"><a alt="Permalink" title="9.4.2.1. OEM compressed / readonly USB stick" href="#idm140065370531344">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370530704"></a><p> If a compressed filesystem type like overlayfs is used for the
          image root directory it's also possible to allow persistent
          writing on the USB stick or alternatively disallow that and
          let all write actions perfom in RAM only. kiwi provides the
          type attribute ramonly for this purpose. So in order to create
          a read-only oem stick with compressed root filesystem the
          following type section is required:</p><pre class="screen">&lt;type image="oem" filesystem="overlayfs" ramonly="true"/&gt;</pre></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.vmx"></a>Chapter 10. VMX Image / Virtual Disks</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.vmx.building">10.1. Building a JeOS disk</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.using">10.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.flavours">10.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.vmx.vmware-support">10.3.1. VMware support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.lvm">10.3.2. LVM Support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.bootpartition">10.3.3. Extra Boot Partition</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm140065370526304"></a><a class="indexterm" name="idm140065370524912"></a><a class="indexterm" name="idm140065370523520"></a><p>A VMX image is a virtual disk image for use in full
    virtualization systems like Qemu or VMware. The image is a file
    containing the system represented by the configured packages in
    <code class="filename">config.xml</code> as well as partition data and bootloader
    information. The size of this virtual disk can be specified by using
    the size element
    in the <code class="filename">config.xml</code> file or by adding the
      <code class="option">--bootvm-disksize</code> command line argument.
    The virtual disk cannot expand to a different disk geometry.
    Be aware if you dump/copy the disk with another disk geometry,
    please refer to the <a class="xref" href="#chap.oem" title="Chapter 14. OEM Image / Preload Systems">Chapter 14, <i>OEM Image / Preload Systems</i></a> for additional details.
  </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.building"></a>10.1. Building a JeOS disk<span class="permalink"><a alt="Permalink" title="10.1. Building a JeOS disk" href="#sec.vmx.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12. The
      JeOS system is based on the sles-Minimal pattern
    </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myvm-result --type vmx</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.using"></a>10.2. Using the Image<span class="permalink"><a alt="Permalink" title="10.2. Using the Image" href="#sec.vmx.using">¶</a></span></h2></div></div></div><p>The generated virtual disk image serves as the hard disk of
      the selected virtualization system (QEMU, VMware, etc.). The
      virtual hard disk format differs across virtualization
      environments. Some virtualization environments support multiple
      virtual disk formats. Using the QEMU virtualization environment
      test the created image with the following command: </p><pre class="screen"><span class="command"><strong>qemu</strong></span> /tmp/myvm-result/LimeJeOS-SLE12.x86_64-1.13.1.raw -m 1024 </pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.flavours"></a>10.3. Flavours<span class="permalink"><a alt="Permalink" title="10.3. Flavours" href="#sec.vmx.flavours">¶</a></span></h2></div></div></div><p>KIWI always generates a file in the <code class="filename">.raw</code><a class="indexterm" name="idm140065370511936"></a> format. The .raw file is a
      disk image with a structure equivalent to the structure of a
      physical hard disk. Individual virtualization systems have
      specific formats to facilitate improved I/O performance to the
      virtual disk, represented by the image file, or additional
      specified virtual hard disk files. KIWI will generate a specific
      format when the format attribute of the type element is added. </p><pre class="screen">&lt;type image="vmx"... format="name"/&gt;</pre><p>The following table lists the supported virtual disk
      formats:</p><div class="table"><a name="tab.vmx.supported-disk-formats"></a><p class="title"><b>Table 10.1. Supported Virtual Disk Formats</b><span class="permalink"><a alt="Permalink" title="Table 10.1. Supported Virtual Disk Formats" href="#tab.vmx.supported-disk-formats">¶</a></span></p><div class="table-contents"><a class="indexterm" name="idm140065370508304"></a><a class="indexterm" name="idm140065370506912"></a><table summary="Supported Virtual Disk Formats" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>vmdk</td><td>Disk format for VMware</td></tr><tr><td>vhd|vhd-fixed</td><td>Disk format for Microsoft HyperV</td></tr><tr><td>ovf|ova</td><td>Open Virtual Format requires VMware's ovftool</td></tr><tr><td>qcow2</td><td>QEMU virtual disk format</td></tr><tr><td>vdi</td><td>Disk format for VirtualBox</td></tr><tr><td>vagrant</td><td>Vagrant Box Format</td></tr><tr><td>gce</td><td>Google Cloud Format</td></tr></tbody></table></div></div><br class="table-break"><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.vmx.vmware-support"></a>10.3.1. VMware support<span class="permalink"><a alt="Permalink" title="10.3.1. VMware support" href="#sec.vmx.vmware-support">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370493296"></a><a class="indexterm" name="idm140065370491904"></a><p>A VMware image is accompanied by a guest configuration file.
        This file includes information about the hardware to be
        represented to the guest image by the VMware virtualization
        environment as well as specification of resources such as
        memory.</p><p>Within the <code class="filename">config.xml</code> file it is
        possible to specify the VMware configuration settings. In
        addition it is possible to include selected packages in the
        created image that are specific to the VM image generation. The
        following <span class="emphasis"><em>machine</em></span> section snippet provides
        general guidance on the VMware guest config which is defined
        below the <span class="emphasis"><em>type</em></span> section in the
        <code class="filename">config.xml</code>.</p><pre class="screen">&lt;machine memory="512"&gt; 
    &lt;vmdisk controller="ide" id="0"/&gt; 
&lt;/machine&gt;</pre><p>Given the specification above KIWI will create a VMware
        guest configuration specifying the availability of 512 MB
        of RAM and an IDE disk controller interface for the VM guest.
        For additional information about the configuration settings
        please refer to the <span class="emphasis"><em>machine</em></span> section. </p><p>The guest configuration can be loaded through VMware user
        interface and may be modified through the GUI. The configuration
        file has the <code class="filename">.vmx</code><a class="indexterm" name="idm140065370484128"></a>
        extension as shown in the example below. </p><pre class="screen">/tmp/myvm-result/LimeJeOS-SLE12.x86_64-1.13.1.vmx</pre><p>Using the <code class="sgmltag-attribute">format</code><a class="indexterm" name="idm140065370481616"></a>="<code class="sgmltag-attvalue">vmdk</code>"
        attribute of the <code class="sgmltag-starttag">&lt;type&gt;</code> start
        tag will create the VMware formatted disk image (<code class="filename">.vmdk</code><a class="indexterm" name="idm140065370478544"></a> file) and the required
        VMware guest configuration (<code class="filename">.vmx</code><a class="indexterm" name="idm140065370476720"></a>) file. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.vmx.lvm"></a>10.3.2. LVM Support<span class="permalink"><a alt="Permalink" title="10.3.2. LVM Support" href="#sec.vmx.lvm">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370474576"></a><p>
        Support for LVM has been added for all image types which are
        disk based. In order to use LVM for the vmx type just add the
        <code class="option">--lvm</code> option as part of the KIWI create/build step
        or add the attribute lvm="true" as part of the type section in
        your <code class="filename">config.xml</code> file. When using modern
        filesystems like btrfs, zfs kiwi also supports using their native
        volume management system. For more information how to setup
        custom partitions/volumes,
        see <a class="xref" href="#chap.partitions" title="Chapter 17. KIWI Custom Partitions">Chapter 17, <i>KIWI Custom Partitions</i></a> for a detailed explanation.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.vmx.bootpartition"></a>10.3.3. Extra Boot Partition<span class="permalink"><a alt="Permalink" title="10.3.3. Extra Boot Partition" href="#sec.vmx.bootpartition">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370469760"></a><p>
        By default kiwi decides itself for using an extra boot partition or not.
        This basically depends on the selected root filesystem and the
        capabilities of the bootloader to directly read data from it. By
        default kiwi will choose the save default even if the bootloader is
        able to read from e.g btrfs directly the default is still to use
        a simple ext filesystem for the /boot data. However it's possible
        to specify what kiwi should do with the two attributes
        <code class="sgmltag-attribute">bootpartition</code><a class="indexterm" name="idm140065370467072"></a>="<code class="sgmltag-attvalue">true|false</code>" and
        <code class="sgmltag-attribute">bootfilesystem</code><a class="indexterm" name="idm140065370464944"></a>="<code class="sgmltag-attvalue">ext2|ext3|ext4|fat32|fat16</code>".
        A runtime check at build time will prove if the combination of
        attributes is technically possible.
      </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.lxc"></a>Chapter 11. Linux Containers and Docker</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.lxc.building">11.1. Building a docker image</a></span></dt><dt><span class="sect1"><a href="#sec.lxc.using">11.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.lxc.details">11.3. Image Configuration Details</a></span></dt></dl></div><a class="indexterm" name="idm140065370461776"></a><a class="indexterm" name="idm140065370460384"></a><a class="indexterm" name="idm140065370458992"></a><a class="indexterm" name="idm140065370457600"></a><p><a class="ulink" href="http://lxc.sourceforge.net/" target="_top">
      <em class="citetitle">Linux Containers (LXC)</em></a> provide operating
       system-level virtualization, utilizing
      <a class="ulink" href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt" target="_top">
        <em class="citetitle">Control Groups (cgroups)</em></a>. The
      virtualization is similar to technologies in OpenVZ, Linux-VServer,
      FreeBSD jails, AIX Workload Partitions, and Solaris Containers. The
      network and process space of the container is separated from the
      host resources using namespaces. Kernel space information is mounted
      into the container root filesystem using the <code class="filename">fstab</code>
      file in the configuration directory. The container root filesystem
      provides the new user space on top of the running kernel of the host.
      A Linux container has two components: the container root file system
      stored in
      <code class="filename">/var/lib/lxc/<em class="replaceable"><code>CONTAINER_NAME</code></em></code><a class="indexterm" name="idm140065370451920"></a>
      and the container configuration stored in
      <code class="filename">/etc/lxc/<em class="replaceable"><code>CONTAINER_NAME</code></em></code><a class="indexterm" name="idm140065370449920"></a>.
      The kiwi created container image is packaged in a tarball containing
      the root filesystem and the configuration. The tarball is expected
      to be inflated at the root level (/) of the target system that
      functions as host.</p><p>Docker is a shipping container system for code that can run virtually
    everywhere. Basically is an extension of LXC’s capabilities. As Docker is 
    based on LXC, a Docker container does not include a separate operating 
    system.
    It relies on the functionality provided by the underlying infrastructure.
    As such, it can package the application and all its dependencies
    in a virtual container which can be run on any Linux server.
  </p><p>On top of LXC, Docker makes it possible to deploy portable containers 
    across machines, shift focus on application rather than machines,
    includes versioning capabilities for tracking successive versions
    of a container, allows re-use of containers as a base for other
    specialized components, and much more. Find more information about
    Docker on its homepage at <a class="ulink" href="http://www.docker.io" target="_top">http://www.docker.io</a>.
  </p><p>When building a docker image with kiwi <span class="emphasis"><em>never</em></span>
    unpack the Docker tarball! If you unpack the tarball it
    will overwrite data on the host system.
    Use the <span class="command"><strong>docker</strong></span> command instead.
  </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.lxc.building"></a>11.1. Building a docker image<span class="permalink"><a alt="Permalink" title="11.1. Building a docker image" href="#sec.lxc.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS --add-profile docker --type docker -d /tmp/my-container</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.lxc.using"></a>11.2. Using the Image<span class="permalink"><a alt="Permalink" title="11.2. Using the Image" href="#sec.lxc.using">¶</a></span></h2></div></div></div><p>The created container is packaged in a tarball in the destination
      directory, <code class="filename">my-container</code><a class="indexterm" name="idm140065370439376"></a>
      and named <code class="filename">LimeJeOS-SLE12-docker.x86_64-1.13.1.tar.xz</code>
      In order to use this image with docker it must be imported via the
      <span class="command"><strong>docker</strong></span> command. The following requires to have
      docker installed and dockerd running.
    </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/my-container
<span class="command"><strong>cat</strong></span> LimeJeOS-SLE12-docker.x86_64-1.13.1.tar.xz |\
<span class="command"><strong>docker</strong></span> import - sle12-jeos:new</pre><p>Once imported, a container instance can be started as follows:</p><pre class="screen"><span class="command"><strong>docker</strong></span> run --privileged=true -t -i sle12-jeos:new /bin/bash</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.lxc.details"></a>11.3. Image Configuration Details<span class="permalink"><a alt="Permalink" title="11.3. Image Configuration Details" href="#sec.lxc.details">¶</a></span></h2></div></div></div><p>The configuration for a container does not need to contain a kernel
      package. The container represents the user space that runs on top
      of the kernel of the container host system.</p><p>The container itself must contain the Linux user space container
      tools.
    </p><p>Configure the network configuration for the container using the
      <code class="sgmltag-element">vmnic</code> element.
      The  <code class="sgmltag-attribute">mode</code><a class="indexterm" name="idm140065370429296"></a>
      attribute indicates the network mode, <span class="emphasis"><em>veth</em></span>
      by default. While it is possible to configure multiple network
      interfaces in the <code class="filename">config.xml</code> file, the written
      container configuration will only reflect the information configured
      for the first <code class="sgmltag-element">vmnic</code>
      element found in the <code class="filename">config.xml</code> file. The
      configuration for the container expects that the host has a configured
      network bridge with the name <span class="emphasis"><em>br0</em></span>.
      For complex network setup implementations it is necessary to edit the
      config file.
    </p><p>The generated configuration file restricts the device access
      of the container according to a generally accepted best practice
      security  model. The device access permissions may be modified by
      editing the <code class="filename">config</code> file for the container.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.vagrant"></a>Chapter 12. Vagrant boxes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.vagrant.building">12.1. Building a Base Box</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.box.details">12.2. Box Configuration Details</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.box.using">12.3. Using the box</a></span></dt><dt><span class="sect1"><a href="#sec.vagrant.docker">12.4. Vagrant with Docker</a></span></dt></dl></div><a class="indexterm" name="idm140065370422640"></a><a class="indexterm" name="idm140065370421248"></a><a class="indexterm" name="idm140065370419856"></a><p>
    <a class="ulink" href="http://vagrantup.com" target="_top">Vagrant</a>
    is a nice framework to implement consistent processing/testing work
    environments based on virtualisation technologies. In order to run
    a system vagrant needs so called boxes. A box is a tarball containing
    a virtual disk image and some metadata. If you need customized boxes
    you need to create them somehow. There is e.g.
    <a class="ulink" href="https://github.com/jedi4ever/veewee" target="_top">veewee</a>
    which builds boxes based on
    <code class="literal">autoyast</code>
    , and Vagrant itself provides
    <a class="ulink" href="http://packer.io" target="_top">Packer</a>
    . Both tools are based on the official distribution media (DVDs). If
    such media does not exist for reasons like the distro is still under
    development or you want to use a collection of your own repositories,
    the kiwi way of building images is helpful. In addition you can use the
    kiwi image description as source for the
    <a class="ulink" href="http://openbuildservice.org/" target="_top">Open Build Service</a>
    which then allows building and maintaining boxes in the Build Service
    as a plus.
  </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vagrant.building"></a>12.1. Building a Base Box<span class="permalink"><a alt="Permalink" title="12.1. Building a Base Box" href="#sec.vagrant.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12.</p><pre class="programlisting">
 $ kiwi --build suse-SLE12-JeOS --add-profile vagrant --type vmx -d /tmp/my-box
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vagrant.box.details"></a>12.2. Box Configuration Details<span class="permalink"><a alt="Permalink" title="12.2. Box Configuration Details" href="#sec.vagrant.box.details">¶</a></span></h2></div></div></div><p>
      The result in <code class="literal">/tmp/my-box</code> provides among other
      files the <code class="literal">.box</code> and the <code class="literal">.json</code>
      files which are needed in order to add and run the box in vagrant. The
      <code class="literal">.box</code> file is a tarball containing the actual virtual
      disk image for the selected virtualisation provider which is in our
      case a <code class="literal">.qcow2</code> image for use with
      <code class="literal">libvirt</code> and some metadata which mostly duplicates
      the information from the <code class="literal">.json</code>
      file to have it packaged in one place too.
    </p><p>
      The actual system inside of the virtual disk has to fulfill
      <a class="ulink" href="http://docs.vagrantup.com/v2/boxes/base.html" target="_top">some
      requirements which are documented on the vagrant pages</a>
      . The kiwi template description already cared for this
      requirements which were:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          mandatory packages:
          <code class="literal">sudo</code>
          ,
          <code class="literal">openssh</code>
          and
          <code class="literal">rsync</code>
        </p></li><li class="listitem"><p>
          users
          <code class="literal">root</code>
          and
          <code class="literal">vagrant</code>
          both configured to use
          <code class="literal">vagrant</code>
          as password
        </p></li><li class="listitem"><p>
          integration of
          <code class="literal">vagrant</code>
          <code class="literal">ssh</code>
          pubkey from here: https://github.com/mitchellh/vagrant/tree/master/keys
        </p></li><li class="listitem"><p>
          setup of
          <code class="literal">sshd</code>
          with
          <code class="literal">UseDNS</code>
          set to no
        </p></li><li class="listitem"><p>
          auto start of
          <code class="literal">sshd</code>
          at boot time
        </p></li><li class="listitem"><p>
          <code class="literal">sudo</code>
          configured to allow passwordless root permissions for
          <code class="literal">vagrant</code>
          user
        </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vagrant.box.using"></a>12.3. Using the box<span class="permalink"><a alt="Permalink" title="12.3. Using the box" href="#sec.vagrant.box.using">¶</a></span></h2></div></div></div><p>
      This requires a correct vagrant installation on your machine including
      a running <code class="literal">libvirtd</code>
      and an up and running libvirt default network.
    </p><p>
      In order to add the box this can be done in two ways. First the
      traditional way by just using the
      <code class="literal">.box</code>
      file and providing a name at the commandline:
    </p><pre class="programlisting">
 $ cd /tmp/my-box

 $ vagrant box add my-box LimeJeOS-SLE12.x86_64-1.13.1.libvirt.box
</pre><p>
      Or secondly if you want the box to have metadata similar to the
      boxes downloaded from https://vagrantcloud.com/ (e.g. a version
      number), then instead of the above call:
    </p><pre class="programlisting">
 $ cd /tmp/my-box

 $ vagrant box add LimeJeOS-SLE12.x86_64-1.13.1.libvirt.json
</pre><p>
      With either method, you can now boot the box:
    </p><pre class="programlisting">
 $ cd /tmp/my-box

 $ vagrant init my-box

 $ vagrant up --provider libvirt

 $ vagrant ssh

 This is the Lime-JeOS SLE12 Linux System...
 vagrant@linux:~&gt;
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vagrant.docker"></a>12.4. Vagrant with Docker<span class="permalink"><a alt="Permalink" title="12.4. Vagrant with Docker" href="#sec.vagrant.docker">¶</a></span></h2></div></div></div><p>
      While it is required to build a specific disk image format for the
      libvirt, VMware or VirtualBox providers in vagrant, a docker base box
      would just be a tarball whose contents must match the vagrant box
      requirements listed above. Therefore building a docker base box for
      vagrant in kiwi is not different from just building a docker image
      as described in <a class="xref" href="#chap.lxc" title="Chapter 11. Linux Containers and Docker">Chapter 11, <i>Linux Containers and Docker</i></a>
    </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.pxe"></a>Chapter 13. PXE Image / Thin Clients</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.pxe.setting-up">13.1. Setting Up the Required Services</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.atftp-server">13.1.1. Atftp Server</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.dhcp-server">13.1.2. DHCP Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.building">13.2. Building a PXE filesystem JeOS</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.using">13.3. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.flavours">13.4. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.client-control-file">13.4.1. The PXE Client Control File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.client-config-file">13.4.2. The PXE Client Configuration File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.another-user">13.4.3. Use Different Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">13.4.4. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">13.4.5. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">13.4.6. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nfs">13.4.7. Root Tree Over NFS</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nbd">13.4.8. Root Tree Over NBD</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-aoe">13.4.9. Root Tree Over AoE</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">13.5. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm140065370084736">13.5.1. The Group Configuration File</a></span></dt><dt><span class="sect2"><a href="#idm140065370066736">13.5.2. The Group Details File</a></span></dt><dt><span class="sect2"><a href="#idm140065370056272">13.5.3.  Using Hardware Mapping to Provide Overrides</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm140065370381104"></a><a class="indexterm" name="idm140065370379712"></a><a class="indexterm" name="idm140065370378320"></a><a class="indexterm" name="idm140065370377312"></a><p>PXE is a boot protocol implemented in most BIOS implementations 
    which makes it so interesting. The protocol
    sends DHCP requests to assign an IP address and after that it uses
    tftp to download kernel and boot instructions.
  </p><p>
    A PXE image consists of a boot image and a system image like all
    other image types too. But with a PXE image the image files are
    available separately and needs to be copied at specific locations of
    a network boot server.
  </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.setting-up"></a>13.1. Setting Up the Required Services<span class="permalink"><a alt="Permalink" title="13.1. Setting Up the Required Services" href="#sec.pxe.setting-up">¶</a></span></h2></div></div></div><p>Before you start to build PXE images with KIWI, setup the boot
      server. The boot server requires the services atftp and DHCP to
      run. </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.atftp-server"></a>13.1.1. Atftp Server<span class="permalink"><a alt="Permalink" title="13.1.1. Atftp Server" href="#sec.pxe.atftp-server">¶</a></span></h3></div></div></div><p>In order to setup the <code class="systemitem">atftp</code><a class="indexterm" name="idm140065370371728"></a> server the following steps are required </p><div class="procedure"><a name="proc.pxe.atftp-server-setup"></a><ol class="procedure" type="1"><li class="step"><p>Install the packages <span class="package">atftp</span> and
              <span class="package">kiwi-pxeboot</span>. </p></li><li class="step"><p>Edit the file
            <code class="filename">/etc/sysconfig/atftpd</code>. Set or modify
            the following variables: </p><pre class="screen">ATFTPD_OPTIONS="--daemon --no-multicast"
ATFTPD_DIRECTORY="/srv/tftpboot"</pre></li><li class="step"><p>Run <code class="systemitem">atftpd</code><a class="indexterm" name="idm140065370364480"></a> by
            calling the command:</p><pre class="screen"><span class="command"><strong>rcatftpd</strong></span> start</pre></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.dhcp-server"></a>13.1.2. DHCP Server<span class="permalink"><a alt="Permalink" title="13.1.2. DHCP Server" href="#sec.pxe.dhcp-server">¶</a></span></h3></div></div></div><p> In contrast to the atftp server setup the following DHCP
        server setup can only serve as an example. Depending on your
        network structure, the IP addresses, ranges and domain settings
        needs to be adapted in order to allow the DHCP server to work
        within your network. If you already have a DHCP server running
        in your network, make sure that the filename and next-server
        information is provided by your server. The following steps
        describe how to setup a new DHCP server instance: </p><div class="procedure"><a name="proc.pxe.dhcp-server-setup"></a><ol class="procedure" type="1"><li class="step"><p>Install the package <span class="package">dhcp-server</span>.
          </p></li><li class="step"><p>Create the file <code class="filename">/etc/dhcpd.conf</code> and include the
            following statements: </p><pre class="screen">option domain-name "example.org";
option domain-name-servers 192.168.100.2;
option broadcast-address 192.168.100.255;
option routers 192.168.100.2;
option subnet-mask 255.255.255.0;
default-lease-time 600;
max-lease-time 7200;
ddns-update-style none; ddns-updates off;
log-facility local7;

subnet 192.168.100.0 netmask 255.255.255.0 {
   filename "pxelinux.0";
   next-server 192.168.100.2;
   range dynamic-bootp 192.168.100.5 192.168.100.20;
}</pre></li><li class="step"><p>Edit the file <code class="filename">/etc/sysconfig/dhcpd</code>
            and setup the network interface the server should listen on: </p><pre class="screen">DHCPD_INTERFACE="eth0"</pre></li><li class="step"><p>Run the <code class="systemitem">dhcp</code><a class="indexterm" name="idm140065370351584"></a> server by calling:</p><pre class="screen"><span class="command"><strong>rcdhcpd</strong></span> start</pre></li></ol></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.building"></a>13.2. Building a PXE filesystem JeOS<span class="permalink"><a alt="Permalink" title="13.2. Building a PXE filesystem JeOS" href="#sec.pxe.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12. It creates a
    compressed root filesystem image which is deployed as overlayfs
    based union system. Please kiwi also supports deployment of
    oem disk images via PXE. This is different from the filesystem
    deployment method. For details refer to to the OEM
    chapter <a class="xref" href="#chap.oem" title="Chapter 14. OEM Image / Preload Systems">Chapter 14, <i>OEM Image / Preload Systems</i></a></p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS --add-profile netboot --type pxe -d /tmp/mypxe-result</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.using"></a>13.3. Using the Image<span class="permalink"><a alt="Permalink" title="13.3. Using the Image" href="#sec.pxe.using">¶</a></span></h2></div></div></div><p>In order to make use of the image all related image parts
      needs to be copied onto the boot server. According to the example
      the following steps needs to be performed: </p><div class="procedure"><a name="proc.pxe.using"></a><ol class="procedure" type="1"><li class="step"><p>Change working directory:</p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/mypxe-result</pre></li><li class="step"><p>Copy of the boot and kernel image:</p><pre class="screen"><span class="command"><strong>cp</strong></span> initrd-netboot-suse-SLES12.x86_64-2.1.1.gz \
  /srv/tftpboot/boot/initrd
<span class="command"><strong>cp</strong></span> initrd-netboot-suse-SLES12.x86_64-2.1.1.kernel \
  /srv/tftpboot/boot/linux</pre></li><li class="step"><p>Copy of the system image and md5 sum:</p><pre class="screen"><span class="command"><strong>cp</strong></span> LimeJeOS-SLE12.x86_64-1.13.1 \
  /srv/tftpboot/image
<span class="command"><strong>cp</strong></span> LimeJeOS-SLE12.x86_64-1.13.1.md5 \
  /srv/tftpboot/image</pre></li><li class="step"><p>Copy of the image boot configuration. Normally the boot
          configuration applies to one client which means it is required
          to obtain the MAC address of this client. If the boot
          configuration should be used globally, copy the KIWI generated
          file as <code class="filename">config.default</code>: </p><pre class="screen"><span class="command"><strong>cp</strong></span> LimeJeOS-SLE12.x86_64-1.13.1.config \
  /srv/tftpboot/KIWI/config.<em class="replaceable"><code>MAC</code></em></pre></li><li class="step"><p>Check the PXE configuration file. The PXE configuration
          controls which kernel and initrd are loaded and which kernel
          parameters are set. When installing the <span class="package">kiwi-pxeboot</span> package,
          a default configuration is added. To make sure the
          configuration is valid according to this example, insert the
          following information into the file
            <code class="filename">/srv/tftpboot/pxelinux.cfg/default</code>: </p><pre class="screen">DEFAULT KIWI-Boot

LABEL KIWI-Boot
    kernel boot/linux
    append initrd=boot/initrd
    IPAPPEND 1

LABEL Local-Boot
    localboot 0</pre></li><li class="step"><p>Connect the client to the network and boot. </p></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.flavours"></a>13.4. Flavours<span class="permalink"><a alt="Permalink" title="13.4. Flavours" href="#sec.pxe.flavours">¶</a></span></h2></div></div></div><p>All the different PXE boot based deployment methods are
      controlled by the
        <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code> (or
        <code class="filename">config.default</code>) file. When a new client
      boots up and there is no client configuration file the new client
      is registered by uploading a control file to the <code class="systemitem">TFTP</code><a class="indexterm" name="idm140065370324128"></a> server. The
      following sections informs about the control and the configuration
      file. </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.client-control-file"></a>13.4.1. The PXE Client Control File<span class="permalink"><a alt="Permalink" title="13.4.1. The PXE Client Control File" href="#sec.pxe.client-control-file">¶</a></span></h3></div></div></div><p>This section describes the netboot client control file: </p><pre class="screen">hwtype.$&lt;$MAC Address$&gt;$</pre><p>The control file is primarily used to set up new netboot
        clients. In this case, there is no configuration file
        corresponding to the client MAC address available. Using the MAC
        address information, the control file is created, which is
        uploaded to the <code class="systemitem">TFTP</code><a class="indexterm" name="idm140065370319536"></a> servers upload directory
          <code class="filename">/var/lib/tftpboot/upload</code>. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.client-config-file"></a>13.4.2. The PXE Client Configuration File<span class="permalink"><a alt="Permalink" title="13.4.2. The PXE Client Configuration File" href="#sec.pxe.client-config-file">¶</a></span></h3></div></div></div><p>This section describes the netboot client configuration
        file: </p><pre class="screen">config.$&lt;$MAC Address$&gt;$</pre><p>The configuration file contains data about image,
        configuration, synchronization, or partition parameters. The
        configuration file is loaded from the TFTP server directory
          <code class="filename">/var/lib/tftpboot/KIWI</code> via TFTP for
        previously installed netboot clients. New netboot clients are
        immediately registered and a new configuration file with the
        corresponding MAC address is created. The standard case for the
        deployment of a PXE image is one image file based on a
        read-write filesystem which is stored onto a local storage
        device of the client. Below, find an example to cover this case. </p><pre class="screen">DISK=/dev/sda
PART='5;S;x,x;L;/'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096'</pre><p>The following format is used: </p><pre class="screen">IMAGE='device;name;version;srvip;bsize;compressed,...,'
CONF='src;dest;srvip;bsize;[hash],...,src;dest;srvip;bsize;[hash]'
PART='size;id;Mount,...,size;id;Mount'
DISK=device</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">IMAGE</code></span></dt><dd><p>Specifies which image (name) should be loaded with
              which version (version) and to which storage device
              (device) it should be linked, e. g., <code class="filename">/dev/ram1</code><a class="indexterm" name="idm140065370309376"></a> or <code class="filename">/dev/hda2</code><a class="indexterm" name="idm140065370307632"></a>. The netboot
              client partition (device) hda2 defines the root file
              system / and hda1 is used for the swap partition. The
              numbering of the hard disk device should not be confused
              with the RAM disk device, where <code class="filename">/dev/ram0</code><a class="indexterm" name="idm140065370305600"></a> is used for the
              initial RAM disk and can not be used as storage device for
              the second stage system image. SUSE recommends to use the
              device <code class="filename">/dev/ram1</code><a class="indexterm" name="idm140065370303664"></a>
              for the RAM disk. If the hard drive is used, a
              corresponding partitioning must be performed. </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">srvip</span></dt><dd><p>Specifies the server IP address for the TFTP
                    download. Must always be indicated, except in PART.
                  </p></dd><dt><span class="term">bsize</span></dt><dd><p>Specifies the block size for the TFTP download.
                    Must always be indicated, except in PART. If the
                    block size is too small according to the maximum
                    number of data packages (32768), linuxrc will
                    automatically calculate a new blocksize for the
                    download. </p></dd><dt><span class="term">compressed</span></dt><dd><p>Specifies if the image file on the TFTP server
                    is compressed and handles it accordingly. To specify
                    a compressed image download only the keyword
                      <code class="literal">"compressed"</code> needs to be added.
                    If compressed is not specified the standard download
                    workflow is used. <span class="bold"><strong>Note:</strong></span> The download will fail if you
                    specify <code class="literal">"compressed"</code> and the
                    image isn’t compressed. It will also fail if you
                    don’t specify <code class="literal">"compressed"</code> but
                    the image is compressed. The name of the compressed
                    image has to contain the suffix <code class="filename">.gz</code><a class="indexterm" name="idm140065370293312"></a> and needs to be
                    compressed with the <span class="command"><strong>gzip</strong></span> tool.
                    Using a compressed image will automatically
                      <span class="emphasis"><em>deactivate</em></span> the multicast
                    download option of atftp. </p></dd></dl></div></dd><dt><span class="term"><code class="varname">CONF</code></span></dt><dd><p>Specifies a comma-separated list of source:target
              configuration files. The source (src) corresponds to the
              path on the TFTP server and is loaded via TFTP. The
              download is made to the file on the netboot client
              indicated by the target (dest). Download only happens when
        configuration files are missing on the client or, if md5sum hash
        is supplied ([hash]), when different. To achieve this, list of
        CONF files (and VENDOR_CONF) files is kept on the client in
        the <code class="filename">/etc/KIWI/InstalledConfigFiles</code> file, and
              is compared to the CONF data gathered from the config.MAC and also
        from other configuration files, e.g. config.group, if supplied.
              Configuration files selected for comparison are those with
        same (dest) path. If destination path (dest) is same for more configuration
        files, only the last one is used (and VENDOR_CONF has always
        precedence to CONF). By comparing configuration file lists
        present in the current CONF, VENDOR_CONF variables and stored in
        the backup file, following actions can result:

</p><div class="table"><a name="tab.configuration.files.synchronization"></a><p class="title"><b>Table 13.1. Configuration files synchronization possibilities</b><span class="permalink"><a alt="Permalink" title="Table 13.1. Configuration files synchronization possibilities" href="#tab.configuration.files.synchronization">¶</a></span></p><div class="table-contents"><table summary="Configuration files synchronization possibilities" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>File from CONF,VENDOR_CONF</th><th>File from InstalledConfigFiles</th><th>Action</th></tr></thead><tbody><tr><td>hash_a</td><td>hash_a</td><td>nothing, keep</td></tr><tr><td>hash_a</td><td>hash_b</td><td>download from server</td></tr><tr><td>none</td><td>hash</td><td>download from server</td></tr><tr><td>hash</td><td>none</td><td>download from server</td></tr><tr><td>none</td><td>none</td><td>nothing, keep</td></tr><tr><td>present</td><td>not present</td><td>download from server (regardless hash)</td></tr><tr><td>not present</td><td>present</td><td>delete on client (regardles hash)</td></tr></tbody></table></div></div><p><br class="table-break">
    Note that actual configuration files (or their md5sum hashes) on the client machine are not tested, only data from the backup file are used. This means that
    actual configuration files can be altered or even deleted without triggering any action, or, on the other hand, an action can be triggered without modifying the
    configuration files, only by modifying or removing of the backup file.
    </p></dd><dt><span class="term"><code class="varname">PART</code></span></dt><dd><p>Specifies the partitioning data. The comma-separated
              list must contain the size (size), the type number (id),
              and the mount point (Mount). The size is measured in MB by
              default. The mount specifies the directory the partition
              is mounted to. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The first element of the list must define the swap
                  partition. </p></li><li class="listitem"><p>The second element of the list must define the
                  root partition. </p></li><li class="listitem"><p>The swap partition must not contain a mount point.
                  A lowercase letter <code class="literal">x</code> must be set
                  instead. </p></li><li class="listitem"><p>If a partition should take all the space left on a
                  disk one can set a lower <code class="literal">x</code> letter
                  as size specification. </p></li></ul></div></dd><dt><span class="term"><code class="varname">RAID</code></span></dt><dd><p>
              In addtion to the PART line it's also allowed to add a raid
              array setup. The first parmater of the RAID line is the raid level.
              So far only raid1 (mirroring) is supported. The second and third
              parameter specifies the raid disk devices which makes up the array.
              If a RAID line is present all partitions in PART will be created
              as raid partitions. The first raid is named md0 the second one md1
              and so on. It's required to specifiy the correct raid partition in
              the IMAGE line according to the PART setup.
              A typical raid image setup could look like this:</p><pre class="screen">DISK=/dev/sda
RAID='1;/dev/sda;/dev/sdb'
IMAGE='/dev/md1;LimeJeOS-openSUSE-##.#.i686;1.11.3;192.168.100.2;4096'
PART='5;S;x,2000;83;/'</pre></dd><dt><span class="term"><code class="varname">DISK</code></span></dt><dd><p>Specifies the hard disk. Used only with PART and
              defines the device via which the hard disk can be
              addressed, e.g., <code class="filename">/dev/hda</code><a class="indexterm" name="idm140065370257808"></a>. </p></dd><dt><span class="term"><code class="varname">REBOOT_IMAGE</code></span></dt><dd><p>If set to a non-empty string, this will reboot the
        system after the initial deployment process is done.
              This means before the system init process is activated
              the system is rebooted. If the machine's default boot
              setup is to boot via PXE it will again boot from the
        network.
            </p></dd><dt><span class="term"><code class="varname">FORCE_KEXEC</code></span></dt><dd><p>During the initial deployment process kiwi checks
              if the running kernel is the same as the kernel installed
              via the system image. If there is a mismatch kiwi activates
              the installed kernel by calling kexec. This is mostly the
              same as to perform a reboot but without the need of the
              BIOS or any bootloader. If FORCE_KEXEC is set to a non-empty
              string kiwi will also perform kexec if the kernel versions
              matches.
            </p></dd><dt><span class="term"><code class="varname">RELOAD_IMAGE</code></span></dt><dd><p>If set to a non-empty string, this forces the
              configured image to be loaded from the server even if the
              image on the disk is up-to-date. The primary purpose of
              this setting is to aid debugging. The option is sensible
              only for disk based systems. </p></dd><dt><span class="term"><code class="varname">RELOAD_CONFIG</code></span></dt><dd><p>If set to a non-empty string, this forces all config
              files to be loaded from the server. The primary purpose of
              this setting is to aid debugging. The option is sensible
              only for disk based systems. </p></dd><dt><span class="term"><code class="varname">COMBINED_IMAGE</code></span></dt><dd><p>If set to a non-empty string, indicates that the both
              image specified needs to be combined into one bootable
              image, whereas the first image defines the read-write part
              and the second image defines the read-only part. </p></dd><dt><span class="term"><code class="varname">KIWI_INITRD</code></span></dt><dd><p>Specifies the KIWI initrd to be used for local boot of
              the system. The variables value must be set to the name of
              the initrd file which is used via PXE network boot. If the
              standard tftp setup suggested with the kiwi-pxeboot
              package is used all initrd files resides in the <code class="filename">boot/</code><a class="indexterm" name="idm140065370243968"></a> directory below the
              tftp server path <code class="filename">/var/lib/tftpboot</code><a class="indexterm" name="idm140065370242224"></a>.
              Because the tftp server do a chroot into the tftp server
              path you need to specify the initrd file as the following
              example shows: </p><pre class="screen">KIWI_INITRD=/boot/<em class="replaceable"><code>name-of-initrd-file</code></em></pre></dd><dt><span class="term"><code class="varname">UNIONFS_CONFIG</code></span></dt><dd><p>For netboot images there is the
              possibility to use overlayfs as container filesystem
              in combination with a compressed system image. The
              recommended compressed filesystem type for the system
              image is <span class="bold"><strong>overlayfs</strong></span>.
            </p><pre class="screen">UNIONFS_CONFIG=/dev/sda2,/dev/sda3,overlayfs</pre><p>In this example the first device <code class="filename">/dev/sda2</code><a class="indexterm" name="idm140065370235840"></a> represents the
              read/write filesystem and the second device <code class="filename">/dev/sda3</code><a class="indexterm" name="idm140065370234000"></a> represents the
              compressed system image filesystem. The union filesystem
              overlayfs is then used to cover the read/write layer
              with the read-only device to one read/write filesystem. If
              a file on the read-only device is going to be written the
              changes inodes are part of the read/write filesystem.
              Please note the device specifications in
                <code class="varname">UNIONFS_CONFIG</code> must correspond with
              the IMAGE and PART information. The following example
              should explain the interconnections: </p><pre class="screen">DISK=/dev/sda
IMAGE='/dev/sda3;image/myImage;1.1.1;192.168.1.1;4096'
PART='200;S;x,300;L;/,x;L;x'
UNIONFS_CONFIG=/dev/sda2,/dev/sda3,overlayfs</pre><p>As the second element of the PART list must define the
              root partition it’s absolutely important that the first
              device in <code class="varname">UNIONFS_CONFIG</code> references
              this device as read/write device. The second device of
                <code class="varname">UNIONFS_CONFIG</code> has to reference the
              given IMAGE device name. </p></dd><dt><span class="term"><code class="varname">KIWI_KERNEL_OPTIONS</code></span></dt><dd><p>Specifies additional command line options to be passed
              to the kernel when booting from disk. For instance, to
              enable a splash screen, you might use
                <code class="literal">vga=0x317</code>
              <code class="literal">splash=silent</code>. </p></dd><dt><span class="term"><code class="varname">KIWI_BOOT_TIMEOUT</code></span></dt><dd><p>Specifies the number of seconds to wait at the grub
              boot screen when doing a local boot. The default is 10.
            </p></dd><dt><span class="term"><code class="varname">NBDROOT</code></span></dt><dd><p>Mount the system image root filesystem remotely via
              NBD (Network Block Device). This means there is a server
              which exports the root directory of the system image via a
              specified export name. The kernel provides the block layer,
              together with a remote port that uses the nbd-server
              program. For more information on how to set up the server,
              see the nbd-server man pages. The kernel on the remote
              client can set up a special network block device named
                <code class="filename">/dev/nb0</code><a class="indexterm" name="idm140065370221648"></a> using
              the nbd-client command. After this device exists, the
              mount program is used to mount the root filesystem. To
              allow the KIWI boot image to use that, the following
              information must be provided: </p><pre class="screen">NBDROOT=NBD.Server.IP.address;\
NBD-Export-Name;/dev/NBD-Device;\
NBD-Swap-Export-Name;/dev/NBD-Swap-Device;\
NBD-Write-Export-Name;/dev/NBD-Write-Device</pre><p>The server IP and the export name are mandatory
              information. Whereas the other parameters are optional.
              The default device names are, NBD-Device = <code class="filename">/dev/nbd0</code><a class="indexterm" name="idm140065370218256"></a>, NBD-Swap-Device =
              <code class="filename">/dev/nbd1</code><a class="indexterm" name="idm140065370216512"></a> and
              NBD-Write-Device = <code class="filename">/dev/ram1
              </code><a class="indexterm" name="idm140065370214768"></a>. The setup of swap and/R/W over nbd depends
              on if there are export names given or not. In addition a
              requested nbd swap space is only established if the client
              has less than 48 MB of RAM. The optional NBD-Write-Export-Name
              and NBD-Write-Device specifies a write COW location for
              the root filesystem. A separate write device is only used
              together with a union setup based on e.g overlayfs</p></dd><dt><span class="term"><code class="varname">AOEROOT</code></span></dt><dd><p>Mount the system image root filesystem remotely via
              AoE (ATA over Ethernet). This means there is a server
              which exports a block device representing the root
              directory of the system image via the AoE subsystem. The
              block device could be a partition of a real or a virtual
              disk. In order to use the AoE subsystem I recommend to
              install the <span class="package">aoetools</span> and
                <span class="package">vblade</span> packages from here first:
                <a class="ulink" href="http://download.opensuse.org/repositories/server:/ltsp" target="_top">http://download.opensuse.org/repositories/server:/ltsp</a>. Once installed the following example shows how to
              export the local <code class="filename">/dev/sdb1</code><a class="indexterm" name="idm140065370209072"></a> partition via AoE:</p><pre class="screen"><span class="command"><strong>vbladed</strong></span> 0 1 eth0 /dev/sdb1</pre><p> Some explanation about this command, each AoE device
              is identified by a couple Major/Minor, with major between
              0-65535 and minor between 0-255. AoE is based just over
              Ethernet on the OSI models so we need to indicate which
              ethernet card we’ll use. In this example we export
                <code class="filename">/dev/sdb1</code><a class="indexterm" name="idm140065370205104"></a> with a
              major value of 0 and minor of 1 on the eth0 interface. We
              are ready to use our partition on the network! To be able
              to use the device KIWI needs the information which AoE
              device contains the root filesystem. In our example this
              is the device <code class="filename">/dev/etherd/e0.1</code><a class="indexterm" name="idm140065370203024"></a>. According to this the
              AOEROOT variable must be set as follows: </p><pre class="screen">AOEROOT=/dev/etherd/e0.1</pre><p> KIWI is now able to mount and use the specified AoE
              device as the remote root filesystem. In case of a
              compressed read-only image with <code class="systemitem">overlayfs</code><a class="indexterm" name="idm140065370200000"></a>, the
              AOEROOT variable can also contain a device for the write
              actions: </p><pre class="screen">AOEROOT=/dev/etherd/e0.1,/dev/ram1</pre><p> Writing to RAM is the default but you also can set
              another device like another aoe location or a local device
              for writing the data </p></dd><dt><span class="term"><code class="varname">NFSROOT</code></span></dt><dd><p>Mount the system image root filesystem remotely via NFS
              (Network File System). This means there is a
              server which exports the root filesystem of the network
              client in such a way that the client can mount it
              read/write. In order to do that, the boot image must know
              the server IP address and the path name where the root
              directory exists on this server. The information must be
              provided as in the following example: </p><pre class="screen">NFSROOT=NFS.Server.IP.address;/path/to/root/tree</pre></dd><dt><span class="term"><code class="varname">KIWI_INITRD</code></span></dt><dd><p>Specifies the KIWI initrd to be used for a local boot
              of the system. The value must be set to the name of the
              initrd file which is used via PXE network boot. If the
              standard TFTP setup suggested with the kiwi-pxeboot
              package is used, all initrd files reside in the <code class="filename">/srv/tftpboot/boot/</code><a class="indexterm" name="idm140065370192144"></a>
              directory. Because the TFTP server does a chroot into the
              TFTP server path, you must specify the initrd file as
              follows: </p><pre class="screen">KIWI_INITRD=/boot/name-of-initrd-file</pre></dd><dt><span class="term"><code class="varname">KIWI_KERNEL</code></span></dt><dd><p>Specifies the kernel to be used for a local boot of
              the system The same path rules as described for
                <code class="varname">KIWI_INITRD</code> applies for the kernel
              setup: </p><pre class="screen">KIWI_KERNEL=/boot/name-of-kernel-file</pre></dd><dt><span class="term"><code class="varname">ERROR_INTERRUPT</code></span></dt><dd><p>Specifies a message which is displayed during first
              deployment. Along with the message a shell is provided.
              This functionality should be used to send the user a
              message if it’s clear the boot process will fail because
              the boot environment or something else influences the PXE
              boot process in a bad way. </p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.another-user"></a>13.4.3. Use Different Download Protocol<span class="permalink"><a alt="Permalink" title="13.4.3. Use Different Download Protocol" href="#sec.pxe.another-user">¶</a></span></h3></div></div></div><p>By default all downloads controlled by the KIWI linuxrc code
        are performed by an atftp call and therefore uses the tftp
        protocol. With PXE the download protocol is fixed and thus you
        can’t change the way how the kernel and the boot image (initrd)
        is downloaded. As soon as Linux takes over control the following
        download protocols http, https and ftp are supported too. KIWI
        makes use of the <span class="command"><strong>curl</strong></span> program to support the
        additional protocols. </p><p>In order to select one of the additional download protocols
        the following kernel parameters needs to be setup: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>kiwiserver</code></em></span></dt><dd><p>Name or IP address of the server who implements the
              protocol </p></dd><dt><span class="term"><em class="parameter"><code>kiwiservertype</code></em></span></dt><dd><p>Name of the download protocol which could be one of
              http, https or ftp </p></dd></dl></div><p>To setup this parameters edit the file
          <code class="filename">/srv/tftpboot/pxelinux.cfg/default</code> on
        your PXE boot server and change the append line accordingly.
        Please note all downloads except for kernel and initrd are now
        controlled by the given server and protocol. You need to make
        sure that this server provides the same directory and file
        structure as initially provided by the <span class="package">kiwi-pxeboot</span> package.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.ram-only-image"></a>13.4.4. RAM Only Image<span class="permalink"><a alt="Permalink" title="13.4.4. RAM Only Image" href="#sec.pxe.ram-only-image">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370174016"></a><p>If there is no local storage and no remote root mount setup
        the image can be stored into the main memory of the client.
        Please be aware that there should be still enough RAM space
        available for the operating system after the image has been
        deployed into RAM. Below, find an example: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use a read-write filesystem in
              <code class="filename">config.xml</code>, for example
              <code class="literal">filesystem="ext3"</code>
          </p></li><li class="listitem"><p>Create
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
          </p><pre class="screen">IMAGE='/dev/ram1;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096'</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.union-image"></a>13.4.5. Union Image<span class="permalink"><a alt="Permalink" title="13.4.5. Union Image" href="#sec.pxe.union-image">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370166144"></a><p>As used in the suse-pxe-client example it is possible to
        make use of the union filesystem; overlayfs, to combine
        two filesystems into one. In case of thin clients there is often
        the need for a compressed filesystem due to space limitations.
        Unfortunately all common compressed filesystems provides only
        read-only access. Combining a read-only filesystem with a
        read-write filesystem is a solution for this problem. In order
        to use a compressed root filesystem based on squashfs make sure your
        <code class="filename">config.xml</code>’s filesystem attribute
        contains <code class="systemitem">squashfs</code><a class="indexterm" name="idm140065370162560"></a>.
      </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.pxe.union.local.local"></a>13.4.5.1. Download to Local Storage, Write to Local Storage<span class="permalink"><a alt="Permalink" title="13.4.5.1. Download to Local Storage, Write to Local Storage" href="#sec.pxe.union.local.local">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370160544"></a><pre class="screen">DISK=/dev/sda
PART='5;S;x,400;L;/,x;L;x'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i386;1.2.8;192.168.100.2;4096'
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,overlayfs
KIWI_INITRD=/boot/initrd</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.pxe.union.local.ram"></a>13.4.5.2. Download to Local Storage, Write to RAM<span class="permalink"><a alt="Permalink" title="13.4.5.2. Download to Local Storage, Write to RAM" href="#sec.pxe.union.local.ram">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370157328"></a><pre class="screen">DISK=/dev/sda
PART='5;S;x,400;L;/'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i386;1.2.8;192.168.100.2;4096'
UNIONFS_CONFIG=tmpfs,/dev/sda2,overlayfs</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.pxe.union.remote.local"></a>13.4.5.3. Mount from Remote, Write to Local Storage<span class="permalink"><a alt="Permalink" title="13.4.5.3. Mount from Remote, Write to Local Storage" href="#sec.pxe.union.remote.local">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370154144"></a><p>For all of the following modes I strongly recommend to check
      on a separate client machine in the network if it is possible to
            access the exported read-only and read-write device locations. If
            accessing devices works the image should also be able to access
            them on boot. If the boot fails it should be clear that the reason
            is not the exported device.
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="envar">NFSROOT</code><a class="indexterm" name="idm140065370151040"></a></span></dt><dd><pre class="screen">PART='5;S;x,x;L;x'
NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=/dev/sda2,nfs,overlayfs</pre></dd><dt><span class="term"><code class="envar">AOEROOT</code><a class="indexterm" name="idm140065370148128"></a></span></dt><dd><pre class="screen">PART='5;S;x,x;L;x'
AOEROOT=/dev/etherd/e0.1,/dev/sda2
UNIONFS_CONFIG=/dev/sda2,aoe,overlayfs</pre></dd><dt><span class="term"><code class="envar">NBDROOT</code><a class="indexterm" name="idm140065370145232"></a></span></dt><dd><pre class="screen">PART='5;S;x,x;L;x'
NBDROOT=192.168.100.7;root1;/dev/nbd0;;;;/dev/sda2
UNIONFS_CONFIG=/dev/sda2,nbd,overlayfs</pre></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.pxe.union.remote.ram"></a>13.4.5.4. Mount from Remote, Write to RAM<span class="permalink"><a alt="Permalink" title="13.4.5.4. Mount from Remote, Write to RAM" href="#sec.pxe.union.remote.ram">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370141824"></a><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="envar">NFSROOT</code><a class="indexterm" name="idm140065370139536"></a></span></dt><dd><pre class="screen">NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=tmpfs,nfs,overlayfs</pre></dd><dt><span class="term"><code class="envar">AOEROOT</code><a class="indexterm" name="idm140065370136656"></a></span></dt><dd><pre class="screen">AOEROOT=/dev/etherd/e0.1
UNIONFS_CONFIG=tmpfs,aoe,overlayfs</pre></dd><dt><span class="term"><code class="envar">NBDROOT</code><a class="indexterm" name="idm140065370133792"></a></span></dt><dd><pre class="screen">NBDROOT=192.168.100.7;root1;/dev/nbd0
UNIONFS_CONFIG=tmpfs,nbd,overlayfs</pre></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.pxe.union.remote.remote"></a>13.4.5.5. Mount from Remote, Write to Remote<span class="permalink"><a alt="Permalink" title="13.4.5.5. Mount from Remote, Write to Remote" href="#sec.pxe.union.remote.remote">¶</a></span></h4></div></div></div><a class="indexterm" name="idm140065370130416"></a><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="envar">NFSROOT</code><a class="indexterm" name="idm140065370128128"></a></span></dt><dd><pre class="screen">NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=/srv/kiwi-read-write-path,nfs,overlayfs</pre></dd><dt><span class="term"><code class="envar">AOEROOT</code><a class="indexterm" name="idm140065370125232"></a></span></dt><dd><pre class="screen">AOEROOT=/dev/etherd/e0.1,/dev/etherd/e1.1
UNIONFS_CONFIG=aoe,aoe,overlayfs</pre></dd><dt><span class="term"><code class="envar">NBDROOT</code><a class="indexterm" name="idm140065370122352"></a></span></dt><dd><pre class="screen">NBDROOT=192.168.100.7;root1;/dev/nbd0;swap1;/dev/nbd1;write1;/dev/nbd2
UNIONFS_CONFIG=nbd,nbd,overlayfs</pre></dd></dl></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.split-image"></a>13.4.6. Split Image<span class="permalink"><a alt="Permalink" title="13.4.6. Split Image" href="#sec.pxe.split-image">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065370118832"></a><p>As an alternative to the <code class="varname">UNIONFS_CONFIG</code>
        method it is also possible to create a split image and combine
        the two portions with the <code class="varname">COMBINED_IMAGE</code>
        method. This allows to use different filesystems without the
        need for an overlay filesystem to combine them together. Below
        find an example: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Add a split type in <code class="filename">config.xml</code>, for
            example </p><pre class="screen">&lt;type fsreadonly="squashfs" 
   image="split" fsreadwrite="ext3" boot="netboot/suse-..."/&gt;</pre></li><li class="listitem"><p>Add a split section inside the type to describe the
              <code class="sgmltag-element">temporary</code> and
              <code class="sgmltag-element">persistent</code> parts. For example:</p><pre class="screen">&lt;split&gt;
  &lt;temporary&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- allow RAM read/write access to: --&gt;</code>
    &lt;file name="/mnt"/&gt; 
    &lt;file name="/mnt/*"/&gt; 
  &lt;/temporary&gt;
  &lt;persistent&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- allow DISK read/write access to: --&gt;</code>
    &lt;file name="/var"/&gt; 
    &lt;file name="/var/*"/&gt; 
    &lt;file name="/boot"/&gt; 
    &lt;file name="/boot/*"/&gt;
    &lt;file name="/etc"/&gt; 
    &lt;file name="/etc/*"/&gt;
    &lt;file name="/home"/&gt;
    &lt;file name="/home/*"/&gt;
  &lt;/persistent&gt; 
&lt;/split&gt;</pre></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>: </p><pre class="screen">IMAGE='/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096,\
      /dev/sda3;suse-##.#-pxe-client-read-write.i686;1.2.8;192.168.100.2;4096'
PART='200;S;x,500;L;/,x;L'
DISK=/dev/sda
COMBINED_IMAGE=yes
KIWI_INITRD=/boot/initrd</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.root-tree-over-nfs"></a>13.4.7. Root Tree Over NFS<span class="permalink"><a alt="Permalink" title="13.4.7. Root Tree Over NFS" href="#sec.pxe.root-tree-over-nfs">¶</a></span></h3></div></div></div><p> Instead of installing the image onto a local storage device
        of the client it is also possible to let the client mount the
        root tree via an <code class="systemitem">NFS</code><a class="indexterm" name="idm140065370104688"></a>
        remote mount. Below find an example: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Export the KIWI prepared tree via NFS.</p></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>: </p><pre class="screen">NFSROOT=192.168.100.7;/tmp/kiwi.nfsroot</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.root-tree-over-nbd"></a>13.4.8. Root Tree Over NBD<span class="permalink"><a alt="Permalink" title="13.4.8. Root Tree Over NBD" href="#sec.pxe.root-tree-over-nbd">¶</a></span></h3></div></div></div><p>As an alternative for root over NFS it is also possible to
        let the client mount the root tree via a special network block
        device. Below find an example: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use nbd-server to export the KIWI prepared tree.</p></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
          </p><pre class="screen">NBDROOT=192.168.100.7;root1;/dev/nbd0</pre></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.root-tree-over-aoe"></a>13.4.9. Root Tree Over AoE<span class="permalink"><a alt="Permalink" title="13.4.9. Root Tree Over AoE" href="#sec.pxe.root-tree-over-aoe">¶</a></span></h3></div></div></div><p>As an alternative for root over NBD it is also possible to
        let the client mount the root device via a special ATA over
        Ethernet network block device. Below find an example: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use the <span class="command"><strong>vbladed</strong></span> command to bind a
            block device to an ethernet interface. The block device can
            be a disk partition or a loop device (losetup) but not a
            directory like with NBD. </p></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>: </p><pre class="screen">AOEROOT=/dev/etherd/e0.1</pre><p>This would require the following command to be called
            first:</p><pre class="screen"><span class="command"><strong>vbladed</strong></span> 0 1 eth0 blockdevice</pre></li></ul></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.groups"></a>13.5. Hardware Grouping<span class="permalink"><a alt="Permalink" title="13.5. Hardware Grouping" href="#sec.pxe.groups">¶</a></span></h2></div></div></div><p>While the PXE standard takes care of the ability to create hardware groups via hardware or
      IP address groups, it does not take into account groups for non-contiguous hardware or IP
      addresses. The PXE standard makes the assumption that each hardware group will be clearly
      delineated by a range of IP addresses, or the hardware is from the same vendor. While an ideal
      scenario, this may not be the case in an established, slightly dated installation where the
      hardware itself has out-lived the vendors that made them.</p><p>KIWI has the ability to create groups for non-contiguous configurations
      where different hardware types may be involved due to newer equipment being rotated into
      production or older hardware failing and replacements are from different vendors. In addition,
      an organization might decide to organize their equipment by function, rather than by vendor,
      and may not be able to use the same hardware from one end to the other. </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm140065370084736"></a>13.5.1. The Group Configuration File<span class="permalink"><a alt="Permalink" title="13.5.1. The Group Configuration File" href="#idm140065370084736">¶</a></span></h3></div></div></div><p>To make use of the grouping functionality, some new configuration files will be
        required. These configuration files currently have to be manually managed rather than
        provided, however future versions of KIWI may provide a means of managing groups more
        effectively once this feature stabilizes. The number of configuration files required will
        depend on the number of hardware groups that will be created, rather than one configuration
        file for each MAC address that will reside on the network. </p><p>There will be one configuration file that will always be required if using groups,
        called:</p><pre class="screen">/srv/tftpboot/KIWI/config.group</pre><p>This file has a new static element that must exist, and one or more dynamic
        elements depending on the number of groups that will be created. For example, the
        config.group file defined below lists 3 distinct groups:</p><pre class="screen">KIWI_GROUP="test1, test2, test3"

test1_KIWI_MAC_LIST="11:11:11:11:11:11, 00:11:00:11:22:CA"

test2_KIWI_MAC_LIST="00:22:00:44:00:4D, 99:3F:21:A2:F4:32"

test3_KIWI_MAC_LIST="00:54:33:FA:44:33, 84:3D:45:2F:5F:33"</pre><p>Note: The above hardware addresses contain random entries, and may not reflect actual
        hardware.</p><p>As we can see in the above example the file contains 1 static element, KIWI_GROUP, and 3
        dynamic elements "test1_KIWI_MAC_LIST, test2_KIWI_MAC_LIST and test3_KIWI_MAC_LIST". The
        definitions of these elements are as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>KIWI_GROUP</p><p>This element is the only static definition that needs to exist when using groups.
            While there is no implicit limit to the number of groups that can be configured, it
            should be kept to a minimum for reasonable management or it could quickly become
            un-manageable. It will need to contain one or more group names separated by comma's (,) and
            spacing (for readability). In the above example, our group names were:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>test1</p></li><li class="listitem"><p>test2</p></li><li class="listitem"><p>test3</p></li></ul></div><p>Valid group names are made up of upper and lower case letters,  and can use numeric, and
            underscore characters. The same rules used to define bash/sh variable names should apply
            here, as these names will have to be used as fully defined bash/sh variables when
            linking hardware addresses to an assigned group. The following is an example that contains
            valid names:</p><pre class="screen">KIWI_GROUP="test1, test_my_name, LIST_HARDWARE, Multple_Case_Group_1"</pre></li><li class="listitem"><p>&lt;GROUP_NAME&gt;_KIWI_MAC_LIST</p><p>The name of this element is dynamic and depends entirely on the list of group names
            that were previously defined. Each group name that was used in the KIWI_GROUP
            variable, must contain a matching dynamic element, and have KIWI_MAC_LIST appended to
            the name. To continue with our previous example, to create hardware lists for the groups 
            already defined, we need 3 dynamic elements called:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>test1_KIWI_MAC_LIST</p></li><li class="listitem"><p>test2_KIWI_MAC_LIST</p></li><li class="listitem"><p>test3_KIWI_MAC_LIST</p></li></ul></div><p>These variables will contain a comma delimited list of the hardware addresses for
            all of the machines being assigned to the appropriate group, but there are some caveats
            that need to be kept in mind. The first caveat is for hardware addresses that contain
            the HEX characters A-F. The PXE standard uses capital letters for these characters, and
            as a result KIWI does upper case comparisons, so a MAC address that is defined with
            lower case letters in this list will never get matched.</p><p>The second caveat is that as the list gets longer, it can be harder to maintain
            and it has the potential to slow down the booting process. However, testing has been 
            completed with 1500+ hosts defined, and there was little delay when transferring the 
            file to a single host. The file size will have a larger impact when trying to download
            it to 1500+ hosts, so some consideration will have to take that into account. 
            The comparison itself still occurred in under half a second while searching 
            through all 1500+ MAC addresses across 3 defined groups.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm140065370066736"></a>13.5.2. The Group Details File<span class="permalink"><a alt="Permalink" title="13.5.2. The Group Details File" href="#idm140065370066736">¶</a></span></h3></div></div></div><p>In addition to the <code class="filename">config.group</code> file,
        each defined group will require a
          <code class="filename">config.&lt;GROUP_NAME&gt;</code> file. This file is
        exactly like a standard KIWI config.&lt;MAC&gt; file, but is
        assigned to a group of hosts rather than a single unit. If we
        continue with the example we used in the previous section, we
        would need the following files:</p><pre class="screen">/srv/tftpboot/KIWI/config.test1
/srv/tftpboot/KIWI/config.test2
/srv/tftpboot/KIWI/config.test3</pre><p>The contents of these files is the same that would normally reside in a config.&lt;MAC&gt;
        file, and all definitions that would be supported for a single host, are supported for a
        group of hosts. In addition, if a host is matched to a group, yet the config.&lt;GROUP_NAME&gt;
        file does not exist, KIWI will error out.</p><p>For example, the following configuration file, called
          <code class="filename">config.test1</code> would be used for the group
        called "test1":</p><pre class="screen">DISK=/dev/sda
PART='5;S;x,x;L;/'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096'
CONF='CONFIGURATIONS/xorg.conf.test1;/etc/X11/xorg.conf;192.168.100.2;4096,\
     CONFIGURATIONS/syslog.conf;/etc/sysconfig/syslog.conf;192.168.100.2;4096'</pre><p>As a result of this configuration file, the image would be
        configured consistently across all the hosts assigned to test1.
        The following file called <code class="filename">config.test2</code>,
        contains a small change that may be specific to a
        function:</p><pre class="screen">DISK=/dev/sda
PART='5;S;x,x;L;/'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096'
CONF='CONFIGURATIONS/xorg.conf.test2;/etc/X11/xorg.conf;192.168.100.2;4096,\
     CONFIGURATIONS/syslog.conf;/etc/sysconfig/syslog.conf;192.168.100.2;4096'</pre><p>As we can see, while group 1 and 2 share the syslog.conf
        configuration file, they have different
          <code class="filename">xorg.conf</code> files defined, therefore two
        distinct groups with one or more hosts assigned to each group
        can now be configured by managing a smaller number of
        files.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm140065370056272"></a>13.5.3.  Using Hardware Mapping to Provide Overrides<span class="permalink"><a alt="Permalink" title="13.5.3.  Using Hardware Mapping to Provide Overrides" href="#idm140065370056272">¶</a></span></h3></div></div></div><p>The only issue with running mixed hardware configurations
        pertains primarily to hardware differences. For instance, it may
        be possible to create a single, <code class="filename">xorg.conf</code>
        file that is able to work with all of the hardware, but there is
        a chance it might not be possible to do so. With this in mind,
        KIWI provides a mechanism to provide "default" configurations
        that works with the most common hardware configuration, while
        providing hardware specific overrides to allow for any
        differences and yet have all hardware linked to the same
        group.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm140065370053984"></a>13.5.3.1. The Hardware Mapping Elements<span class="permalink"><a alt="Permalink" title="13.5.3.1. The Hardware Mapping Elements" href="#idm140065370053984">¶</a></span></h4></div></div></div><p>To make use of the hardware linking mechanism, two
          additional parameters needs to be added to the group details
          file, the one named
            <code class="filename">config.&lt;group_name&gt;</code>. These two
          elements "link" hardware specific configurations to the
          appropriate systems. A general example would look like
          this:</p><pre class="screen">HARDWARE_MAP="vendor_name_model"
vendor_name_model_HARDWARE_MAP="00:00:00:11:11:11"</pre><p>These parameters are not required, and the same functionality can be applied by using
          multiple groups to do the same thing, but that might not be desirable to some
          administrators. This feature allows for a slightly more complex group to be defined, but
          the end result is a single group, that can contain multiple sub-groups ensuring
          flexibility in using a mixed set of hardware. </p><p>The definitions for the above parameters are as follows: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>HARDWARE_MAP</p><p>This element follows the same rules as defined by the KIWI_GROUP element. However,
              this variable will create sub-groups used to ensure multiple types of hardware vendors
              can be used within the same group.  The name of the group(s) should be clearly
              defined, and a good convention to follow would be to use a combination of the vendor
              name with the model number or type. This would allow for cases where the same vendor
              is used, but differences between alternative models requires different maps to be
              used.</p></li><li class="listitem"><p>&lt;HARDWARE_MAP_NAME&gt;_HARDWARE_MAP</p><p>This element behaves exactly like the &lt;GROUP_NAME&gt;_KIWI_MAC_LIST element
              defined above, in that it lists all MAC addreses that need to be linked to a hardware
              map. Any host defined within the list will receive configuration files that have been
              specifically defined in a hardware_config.&lt;hardware_map&gt; file, in addition to any
              files defined within a CONF element.</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm140065370045824"></a>13.5.3.2. The Hardware Mapping Details File<span class="permalink"><a alt="Permalink" title="13.5.3.2. The Hardware Mapping Details File" href="#idm140065370045824">¶</a></span></h4></div></div></div><p>Once the hardware map has been defined, the last step is to ensure configuration
          specific elements are linked to the host(s) in question. This is done by creating a new
          hardware_config.&lt;hardware_map&gt; file. The contents of the file is quite simple, and
          contains only one element called VENDOR_CONF, as the following example shows:</p><pre class="screen">VENDOR_CONF='CONFIGURATIONS/xorg.conf.hardware_name_model;/etc/X11/xorg.conf;192.168.100.2;4096'</pre><p>The format of the VENDOR_CONF values is exactly the same as the CONF variable used in
          the standard host and group configurations. In addition, files defined within this list
          will over-write any files defined in the group configuration, if and only if, all of the
          following cases apply:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The host is assigned to the current hardware map</p></li><li class="listitem"><p>The file is defined within the CONF and VENDOR_CONF elements</p></li></ul></div><p>NOTE: If a file is not defined in the CONF element, but is defined in the VENDOR_CONF
          element, it is simply downloaded to the host as if it was a CONF file. In this case, no
          overwritting will take place as it is considered a new file.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm140065370040128"></a>13.5.3.3. A Complete Example<span class="permalink"><a alt="Permalink" title="13.5.3.3. A Complete Example" href="#idm140065370040128">¶</a></span></h4></div></div></div><p>The following is an example of a group that is using hardware from multiple vendors.
          For the purposes of this example, lets assume the group will have 10 defined hosts, seven
          are imaginative HP thinstations, while the remaining three are older Maxterm thinstations.
          We will also assume that the differences we are trying to address are specific to the
          video card and X.Org drivers used as a result.</p><p>With this in mind, we will need the following KIWI specific files:</p><pre class="screen"><span class="command"><strong>cd</strong></span> /srv/tftpboot/KIWI
<span class="command"><strong>ls</strong></span>
   config.example1
   config.group
   hardware_config.maxterm_3500</pre><p>As we can see, there is a KIWI group file, the group configuration or details file,
          and a new file that we have not seen before called hardware_config.maxterm_3500. We will
          first look at the contents of the config,group file:</p><pre class="screen"><span class="command"><strong>cat</strong></span> config.group

KIWI_GROUP="example1"
example1_KIWI_MAC_LIST=
  "00:00:00:00:00:01 00:00:00:00:00:02 \
   00:00:00:00:00:03 00:00:00:00:00:04 \
   00:00:00:00:00:05 00:00:00:00:00:06 \
   00:00:00:00:00:07 00:00:00:00:00:08 
   00:00:00:00:00:09 00:00:00:00:00:0A"</pre><p>Within the file, there is a group called "example1", with ten hosts defined, in this
          case with imaginary sequential MAC addresses. Next, we look at the config.example1 group
          details/configuration file:</p><pre class="screen"><span class="command"><strong>cat</strong></span> config.example1

KIWI_INITRD=/boot/initrd
KIWI_KERNEL=/boot/linux
DISK=/dev/sda
PART='5;S;x,769;L;/,x;L;x'
IMAGE='/dev/sda2;exmaple-kiosk-opensuse-##.#-pxe-client.i686;0.0.1;192.168.1.2;4096'
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,overlayfs
CONF='prefs.js;/home/kioskuser/.mozilla/firefox/07xvl1ty.default/prefs.js;192.168.1.2;4096,xorg.conf;/etc/X11/xorg.conf;192.168.1.2;4096'
RELOAD_IMAGE=yes
RELOAD_CONFIG=yes
HARDWARE_MAP='maxterm_3500'
maxterm_3500_HARDWARE_MAP='00:00:00:00:00:02 00:00:00:00:00:03 00:00:00:00:00:04'</pre><p>Here, most of the standard KIWI configuration elements are in place, with a few
          extras. There are three areas we want to focus our attention on, the CONF, HARDWARE_MAP
          and maxterm_3500_HARDWARE_MAP variables, as they are the most critical elements to our
          example.</p><p>The first parameter to look at is the CONF parameter,
          which indicates a <code class="filename">prefs.js</code> (for Mozilla
          Firefox), and a xorg.conf (for X Windows) files will be copied
          to the host during boot up. These files should be considered
          defaults for the group, and all hosts defined in this group
          will use these files. As such, when the systems boot, both of
          these files will be copied over to their local file systems
          when the CONF element is processed.</p><p>Lastly, we have a hardware mapping group called "maxterm_3500", with three of the
          groups hosts defined as part of of a sub-group, or hardware map. The content of this file
          is as follows:</p><pre class="screen"><span class="command"><strong>cat</strong></span> hardware_config.maxterm_3500

VENDOR_CONF='xorg.conf.maxterm_3500;/etc/X11/xorg.conf;192.168.1.2;4096,
            someconfig.cfg;/etc/sysconfig/someconfig.cfg;192.168.1.2;4096'</pre><p>When the VENDOR_CONF defintition is used, we are telling KIWI that all files defined
          within this element, are specific to the hardware map they are linked to. As a result, any
          files listed here will be transferred to a host if, and only if, the host has been linked
          to the hardware map via the maxterm_3500_HARDWARE_MAP element. In our example the only
          systems that will receive the xorg.conf.maxterm_3500 file will be the three maxterms we
          linked to the hardware map itself.</p><p>In our VENDOR_CONF element, we are indicating two files
          that should be transferred, in addition to any file
          transferred during the processing of the CONF element. A
          "specific" <code class="filename">xorg.conf</code> file, as well as
          someconfig.cfg. In the case of the xorg.conf.maxterm_3500
          file, when it is transferred to the host, it will overwrite
          the <code class="filename">xorg.conf</code> file that was previously
          transferred via the CONF element. However, with the
            <code class="filename">someconfig.cfg</code> file, because it was not
          previously defined in the CONF element, it will simply get
          transferred over, and is a perfect example of how one could
          enable functionality that is not otherwise configured.</p><p>As a result of this example, we have seven terminals that
          are using a prefs.js and generic xorg.conf file for their
          system configuration, and three terminals that are using
          prefs.js, a new version of the <code class="filename">xorg.conf</code>
          file as well as a file called somconfig.cfg. For the purposes
          of our example, the contents of the
            <code class="filename">prefs.js</code>,
            <code class="filename">xorg.conf</code>, xorg.conf.maxterm_3500 and
            <code class="filename">someconfig.cfg</code> are arbitrary, and don't
          need to be explained here.</p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.oem"></a>Chapter 14. OEM Image / Preload Systems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.oem.building">14.1. Building an OEM System with Installation DVD</a></span></dt><dt><span class="sect1"><a href="#sec.oem.using">14.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">14.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.installation">14.3.1. Specializing the OEM install process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partitioning">14.3.2. Influencing the OEM Partitioning</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">14.3.3. Partition Based Installation</a></span></dt><dt><span class="sect2"><a href="#sec.oem.pxe-based-installation">14.3.4. Network Based Installation</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm140065370019200"></a><a class="indexterm" name="idm140065370017808"></a><a class="indexterm" name="idm140065370016416"></a><p>
   An OEM image is a virtual disk image representing all partitions
   and bootloader information in the same fashion it exists on a
   physical disk. All flavors discussed previously for the VMX
   image type apply also to the OEM image type. The image format matches
   the format of the VMX image type, however an OEM image can do more.
   It is able to expand itself to a custom disk geometry and kiwi can
   create installation images which embeds the OEM image for deployment
   from CD/DVD/Stick and over the network via PXE.
  </p><a class="indexterm" name="idm140065370014464"></a><a class="indexterm" name="idm140065370013456"></a><a class="indexterm" name="idm140065370012448"></a><p>
   The basic idea behind an OEM image is to provide the virtual
   disk data for OEM vendors to support easy deployment of the system
   to physical storage media.
  </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.building"></a>14.1. Building an OEM System with Installation DVD<span class="permalink"><a alt="Permalink" title="14.1. Building an OEM System with Installation DVD" href="#sec.oem.building">¶</a></span></h2></div></div></div><p>
   This example is based on SLES version 12. The image creation process
   actually creates two images. The OEM disk image and an Installation
   ISO image which contains the OEM disk image. As a user I can decide
   to take the OEM disk image and dump it with some tool on the disk of
   the target system or boot the target system from the ISO image
   and run through an image deployment process which could also be
   configured to run without user interaction.
  </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myoem-result --type oem</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.using"></a>14.2. Using the Image<span class="permalink"><a alt="Permalink" title="14.2. Using the Image" href="#sec.oem.using">¶</a></span></h2></div></div></div><a class="indexterm" name="idm140065370006928"></a><a class="indexterm" name="idm140065370005536"></a><p>
     The virtual disk image created by KIWI with the commands shown
     above can be tested using virtualization software such as QEMU,
     VMware, or VirtualBox. The virtual disk is represented by the file
     with the <code class="filename">.raw</code><a class="indexterm" name="idm140065370002912"></a> extension,
     whereas the file with the <code class="filename">.iso</code><a class="indexterm" name="idm140065370001168"></a> extension represents the installation disk for
     this oem image. The ISO image is bootable (<code class="filename">filename.iso</code>)
     and can be burned to optical media. It is recommended to test the
     image on a bare test system. The following command shows how
     to use QEMU to test the OEM disk image (<code class="filename">filename.raw</code>).
    </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result 
<span class="command"><strong>qemu</strong></span> LimeJeOS-SLE12.x86_64-1.13.1.raw</pre><p>or using the <span class="command"><strong>dd</strong></span> command you can dump the
      image onto a test hard disk or USB stick and upon reboot select
      the appropriate device as the boot device in the BIOS: </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result 
<span class="command"><strong>dd</strong></span> if=LimeJeOS-SLE12.x86_64-1.13.1.raw of=/dev/<em class="replaceable"><code>device</code></em></pre><p>
     Note, when testing an oem image using the virtual disk image,
     i.e. the <code class="filename">.raw</code><a class="indexterm" name="idm140065369992448"></a> file, the
     geometry of the disk image is not changed and therefore retains
     the disk geometry of the host system. This implies that the
     re-partitioning performed for a physical disk install during the
     oem boot workflow will be skipped.
    </p><p>
      You can test the installation procedure in a virtual
      environment using the <code class="filename">.iso</code><a class="indexterm" name="idm140065369989936"></a>
      file. In this case the re-partitioning code in the boot image will
      be executed. The following commands show this procedure using
      QEMU. </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result 
<span class="command"><strong>qemu-img</strong></span> create /tmp/mydisk 20G 
<span class="command"><strong>qemu</strong></span> -hda /tmp/mydisk -cdrom LimeJeOS-SLE12.x86_64-1.13.1.iso -boot d</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.flavours"></a>14.3. Flavours<span class="permalink"><a alt="Permalink" title="14.3. Flavours" href="#sec.oem.flavours">¶</a></span></h2></div></div></div><p>
    <a class="indexterm" name="idm140065369984912"></a>
    <a class="indexterm" name="idm140065369983904"></a>  
     As indicated above the use of the <code class="sgmltag-attribute">installiso</code><a class="indexterm" name="idm140065369982400"></a>
     and <code class="sgmltag-attribute">installstick</code><a class="indexterm" name="idm140065369980896"></a> attributes for the oem image
     supports the creation of an installation image. The installation image can
     be created in two formats, one suitable for CD/DVD media and a
     second suitable for a USB stick. The self installing image deploys
     the oem image onto the selected storage device. The installation
     process is a simple image dump using the <span class="command"><strong>dd</strong></span> command.
     During this process the target system remains in terminal mode. The
     following configuration snippets show the use of the <code class="sgmltag-attribute">installiso</code><a class="indexterm" name="idm140065369978224"></a> and <code class="sgmltag-attribute">installstick</code><a class="indexterm" name="idm140065369976720"></a> attributes to create
     the ISO or USB installation image format respectively. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="screen">&lt;type image="name" ... installiso="true" hybrid="true"/&gt;</pre><p>Creates a <code class="filename">.iso</code><a class="indexterm" name="idm140065369973232"></a> file
          which can be burned onto a CD or a DVD. This represents an
          installation CD/DVD. You might have noticed the
          <span class="emphasis"><em>hybrid</em></span> attribute. This turns the ISO into a
          hybrid media which let look the ISO like an ISO and a disk.
          Therefore it's possible to dump the ISO on for example an USB Stick.
          If your bios is not confused about the hybrid setup kiwi did with
          the ISO, the stick will boot like a disk. If it does not work
          use the installstick media as explained below.
        </p></li><li class="listitem"><pre class="screen">&lt;type image="name" ... installstick="true"/&gt;</pre><p>Creates a <code class="filename">.raw.install</code><a class="indexterm" name="idm140065369969040"></a> file which can be dumped
            (<span class="command"><strong>dd</strong></span>) onto a USB stick. This represents an
          installation Stick </p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.installation"></a>14.3.1. Specializing the OEM install process<span class="permalink"><a alt="Permalink" title="14.3.1. Specializing the OEM install process" href="#sec.oem.installation">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065369966064"></a><a class="indexterm" name="idm140065369965056"></a><a class="indexterm" name="idm140065369964048"></a><a class="indexterm" name="idm140065369963040"></a><p>It is possible to specialize the OEM install process by providing
          shell scripts with the following names. For more information how
          to pack the scripts and make them work in the boot code, see
          the chapter <a class="xref" href="#sec.hooks" title="3.4. Boot Image Hook-Scripts">Section 3.4, “Boot Image Hook-Scripts”</a>.
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">preHWdetect.sh</code>
              This script is executed prior to the hardware scan on the
                  target machine.</p></li><li class="listitem"><p><code class="filename">postHWdetect.sh</code>
              This script is executed after the hardware scan on the
                  target machine.</p></li><li class="listitem"><p><code class="filename">preImageDump.sh</code>
              This script is executed immediately prior to the OEM
                  image dump onto the target storage device.</p></li><li class="listitem"><p><code class="filename">postImageDump.sh</code>
              This script is executed directly after the OEM image dump
                  onto the target storage device once the image checksum has
                  been successfully verified.</p></li></ul></div><p>
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.partitioning"></a>14.3.2. Influencing the OEM Partitioning<span class="permalink"><a alt="Permalink" title="14.3.2. Influencing the OEM Partitioning" href="#sec.oem.partitioning">¶</a></span></h3></div></div></div><p>By default the oemboot process will create a swap and an optional
          recovery partition, and will expand all other partitions according
          to the setup in the kiwi configuration and the underlaying disk
          geometry. It is possible to influence the behavior with the
          <code class="sgmltag-element">oem-*</code> elements. See <a class="xref" href="#chap.description" title="Chapter 5. KIWI Image Description">Chapter 5, <i>KIWI Image Description</i></a> for details. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.partition-based-installation"></a>14.3.3. Partition Based Installation<span class="permalink"><a alt="Permalink" title="14.3.3. Partition Based Installation" href="#sec.oem.partition-based-installation">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065369951264"></a><p>
       The default installation method of an OEM is dumping the
       entire virtual disk on the selected target disk and repartition
       the disk to the real geometry. This works but will also wipe
       everything which was on the disk before. KIWI also supports the
       installation into already existing partitions. This means the
       user can setup a disk with free partitions for the KIWI OEM
       installation process. This way already existing data will not be
       touched. In order to activate the partition based install mode
       the following OEM option has to be set in
        <code class="filename">config.xml</code>: </p><pre class="screen">&lt;oem-partition-install&gt;true&lt;/oem-partition-install&gt;</pre><p>Compared to the disk based install the following differences
        should be mentioned: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
           The bootloader will be setup to boot the installed system.
           There is no multiboot setup. The user is expected to implement
           the setup of a multiboot bootloader.
          </p></li><li class="listitem"><p>The oem options for system, swap and home doesn’t have
            any effect if the installation happens in predefined
            partitions. In this mode kiwi will not create additional
            partitions.
          </p></li><li class="listitem"><p>There is no support for remote (PXE) OEM installation
            because KIWI has to loop mount the disk image and need to
            address specific regions inside of the image. These block
            operations are not implemented for remote access
          </p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.pxe-based-installation"></a>14.3.4. Network Based Installation<span class="permalink"><a alt="Permalink" title="14.3.4. Network Based Installation" href="#sec.oem.pxe-based-installation">¶</a></span></h3></div></div></div><a class="indexterm" name="idm140065369942080"></a><a class="indexterm" name="idm140065369941072"></a><p>
      Instead of manually dumping the OEM image on the target device
      or creating a KIWI install CD, USB stick, there is a third
      method of deploying the OEM image on the target device. It's
      possible to let the image be downloaded from a PXE boot server
      over the network. This requires a PXE network boot server to be
      setup properly in the first place For details how to do this
      refer to the chapter: <a class="xref" href="#chap.pxe" title="Chapter 13. PXE Image / Thin Clients">Chapter 13, <i>PXE Image / Thin Clients</i></a>. If your pxe
      server is running the following steps are required to setup the
      install process over the network </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Make sure you have created an install PXE tarball along with
            your oem image:</p><pre class="screen">&lt;type image="oem" ... installpxe="true"/&gt;</pre></li><li class="listitem"><p> unpack the created &lt;image-name&gt;.tgz file and copy the
            initrd and kernel images over to your PXE server:</p><pre class="screen"><span class="command"><strong>tar</strong></span> -xf &lt;image-name&gt;.tgz
<span class="command"><strong>scp</strong></span> initrd-oemboot-*.install.* pxe.server.ip:/srv/tftpboot/boot/initrd
<span class="command"><strong>scp</strong></span> initrd-oemboot-*.kernel.*  pxe.server.ip:/srv/tftpboot/boot/linux</pre></li><li class="listitem"><p> Next copy the system image and md5 sum over to to the PXE
            boot server:</p><pre class="screen"><span class="command"><strong>scp</strong></span> &lt;image-file&gt;.xz  pxe.server.ip:/srv/tftpboot/image/
<span class="command"><strong>scp</strong></span> &lt;image-file&gt;.md5 pxe.server.ip:/srv/tftpboot/image/</pre></li><li class="listitem"><p> At last set the kernel commandline parameters to the append
            line in your PXE configuration (for example:
              <code class="filename">pxelinux.cfg/default</code>). The required
            parameters are stored in the file
              <code class="filename">&lt;image-file&gt;.append</code> from the
            KIWI generated install tarball </p><p> Optionally the image can be stored on a FTP,HTTP server
            specified via the <span class="command"><strong>kiwiserver</strong></span> and
              <span class="command"><strong>kiwiservertype</strong></span> append information. In
            this case make sure you copied the system image and md5 file
            to the correct location on the ftp, http, etc. server. KIWI
            searches the image at one place only which is below the
              <code class="filename">image/</code> directory on the root path of
            the specified server. initrd and linux kernel are loaded by
            PXE thus they require a tftp server to be present. </p></li></ul></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.xen"></a>Chapter 15. Xen Para- and Full virtual Images</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.xen.dom0.building">15.1. Building a Dom0</a></span></dt><dt><span class="sect1"><a href="#sec.xen.dom0.using">15.2. Using the Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.pv.building">15.3. Building a Para Virtual Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.hvm.building">15.4. Building a Full Virtual Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">15.5. Using the Guest Images</a></span></dt></dl></div><a class="indexterm" name="idm140065369923408"></a><a class="indexterm" name="idm140065369922016"></a><a class="indexterm" name="idm140065369920624"></a><p>Xen is a free software virtual machine monitor. It allows
    several guest operating systems to be executed on the same computer
    hardware at the same time. </p><p>A Xen system is structured with the Xen hypervisor as the lowest
    and most privileged layer. Above this layer are one or more guest
    operating systems, which the hypervisor schedules across the
    physical CPUs. The first guest operating system, called in Xen
    terminology <span class="quote">“<span class="quote">domain 0</span>”</span> (dom0), is booted automatically
    when the hypervisor boots and given special management privileges
    and direct access to the physical hardware. The system administrator
    logs into dom0 in order to start any further guest operating
    systems, called <span class="quote">“<span class="quote">domain 0</span>”</span> (domU) in Xen terminology. </p><p>A Xen image is a virtual disk like a vmx but with the xen kernel
    installed for dom0 or para virtual guest images. For full virtual
    guest images any kernel e.g kernel-default can be used together
    with a xen kernel modules packages which must be available for
    the used kernel</p><p>
    In order to run it a Xen dom0 server needs to run. A xen guest
    is booting via a surrounded boot infrastructure. For paravirtual
    images pyGrub or pvGrub can be used, while for HVM an extra hvmloader
    is used. Xen extracts information to boot from the given image
    and boots the guest. Depending on what type of guest is booted also
    the bootloader configuration could be read. Thus this put some
    constraints on the configuration which are addressed by kiwi</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.dom0.building"></a>15.1. Building a Dom0<span class="permalink"><a alt="Permalink" title="15.1. Building a Dom0" href="#sec.xen.dom0.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12. The example provides a
      xenFlavour profile which builds a dom0 image for the oem image type
      as follows</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myoem-result --type oem \
     --add-profile xenFlavour</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.dom0.using"></a>15.2. Using the Dom0 Image<span class="permalink"><a alt="Permalink" title="15.2. Using the Dom0 Image" href="#sec.xen.dom0.using">¶</a></span></h2></div></div></div><p>Basically the dom0 represents the most privileged layer with access
      to the hardware. It is possible to run such an image inside of a full
      virtual system like Qemu but this is not recommended. First and foremost
      because the performance suffers from doing so and secondly because
      kernel-xen is not officially supported to work within a stack of
      hypervisors. For testing however it's ok to just run this oem image
      in Qemu as follows:</p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result
<span class="command"><strong>qemu-img</strong></span> create mydom0 10g
<span class="command"><strong>qemu</strong></span> -cdrom LimeJeOS-SLE12.x86_64-1.13.1.install.iso -hda mydom0 -boot d</pre><p>
      Once installed <span class="emphasis"><em>mydom0</em></span> is a Xen dom0 from which
      other xen guests can be started</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.domU.pv.building"></a>15.3. Building a Para Virtual Xen Guest<span class="permalink"><a alt="Permalink" title="15.3. Building a Para Virtual Xen Guest" href="#sec.xen.domU.pv.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12. The example makes again
      use of the xenFlavour profile but builds a simple vmx image. The
      result is a disk image with kernel-xen prepared for paravirtual boot
      via grub2. In order to boot such a guest a pvGrub or pyGrub
      machine configuration supporting grub2 must be provided</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myvmx-result --type vmx \
     --add-profile xenFlavour</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.domU.hvm.building"></a>15.4. Building a Full Virtual Xen Guest<span class="permalink"><a alt="Permalink" title="15.4. Building a Full Virtual Xen Guest" href="#sec.xen.domU.hvm.building">¶</a></span></h2></div></div></div><p>This example is based on SLES version 12. In contrast to the
      paravirtual guest image this example builds a simple vmx image
      including the standard kernel plus some xen required kernel modules.
      In order to boot such a guest a hvmloader machine configuration
      must be provided</p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myvmx-result --type vmx \
     --add-profile xenFlavourHVM</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.using"></a>15.5. Using the Guest Images<span class="permalink"><a alt="Permalink" title="15.5. Using the Guest Images" href="#sec.xen.using">¶</a></span></h2></div></div></div><p>In order to run a domain U the Xen tool <span class="command"><strong>xm</strong></span>
      needs to be called in conjunction with a domain U
      configuration file like the following example:</p><pre class="screen"><span class="command"><strong>xm</strong></span> create -c config-file</pre><p>
      For paravirtual guest images KIWI supports
      the creation of the configuration file according to information
      given in the KIWI <code class="filename">config.xml</code></p><pre class="screen">&lt;machine memory="512" domain="domU"&gt;
    &lt;vmdisk id="0" device="/dev/xvda" controller="ide"/&gt;
    &lt;vmnic interface=""/&gt;
&lt;/machine&gt;</pre><p>
      If this information exists kiwi creates a file with the
      extension <code class="filename">.xenconfig</code></p><p>
      Please note that not all possible configuration options are
      supported with KIWI xen config file creator. For hvm images
      there is currently no support to create the configuration from
      kiwi. However tools like <span class="emphasis"><em>virt-manager</em></span>
      support you with setting up the machine configuration.</p><p>
      More details how to configure the guest image with Xen is
      provided on <a class="ulink" href="http://www.xenproject.org/help/documentation.html" target="_top">http://www.xenproject.org/help/documentation.html</a></p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.raid"></a>Chapter 16. KIWI RAID Support</h2></div></div></div><a class="indexterm" name="idm140065369892752"></a><p>
   KIWI supports three types of RAID systems:
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Real RAID controllers with its own firmware</span></dt><dd><p>
         KIWI only has to make sure the drivers are part of the
         initrd e.g cciss for the smart array controllers built
         into some server boards.
        </p></dd><dt><span class="term">BIOS RAID controllers</span></dt><dd><p>
         Cheap onboard controller devices with the RAID
         software inside the BIOS (so called fake RAID).
         Linux supports some of them with the 'dmraid' utility
         and the support is a mix of BIOS calls and some
         device mapper calls.
        </p><p>
         The check for these devices can be switched on
         and off with &lt;oem-ataraid-scan&gt;true|false&lt;/oem-ataraid-scan&gt;
        </p></dd><dt><span class="term">Linux software RAID</span></dt><dd><p>
         There is no hardware involved. The Linux kernel
         can control any storage device by adding RAID
         capabilities. All the work done by a real hardware
         controller is done in software. 
        </p><p>
         All this is done using the 'mdadm' utility.
         The metadata for the devices are stored in RAID
         blocks on the storage device which requires them
         to be of the correct partition type.
        </p></dd></dl></div><p>
   The software RAID is supported in a so called degraded mode.
   This means the RAID is created but not all devices to build
   it are attached. That's because an image consists initially
   out of one disk and not more. The user should add devices or
   change the RAID mode manually after deployment. This is an
   easy task if the system comes up prepared for all this. In
   order to use linux software raid in kiwi images you only have
   to set:
  </p><p>
   &lt;type ... mdraid="mirroring"&gt;
  </p><p>
   Currently kiwi supports a degraded mirroring (raid:1) or
   stripping (raid:0) config
   but you can change the mode to any supported raid level after
   deployment.
  </p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.partitions"></a>Chapter 17. KIWI Custom Partitions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#chap.partitions.lvm">17.1. Custom Partitioning via LVM</a></span></dt><dt><span class="sect1"><a href="#chap.partitions.btrfs">17.2. Custom Partitioning via Btrfs</a></span></dt></dl></div><a class="indexterm" name="idm140065369881152"></a><a class="indexterm" name="idm140065369879760"></a><a class="indexterm" name="idm140065369878368"></a><p>
   KIWI supports custom parttions only via LVM, the logical volume manager for the Linux kernel,
   or filesystems with volume support like btrfs or zfs.
  </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chap.partitions.lvm"></a>17.1. Custom Partitioning via LVM<span class="permalink"><a alt="Permalink" title="17.1. Custom Partitioning via LVM" href="#chap.partitions.lvm">¶</a></span></h2></div></div></div><p>
   KIWI supports LVM, the logical volume manager for the Linux kernel
   that manages disk drives and similar mass-storage devices. KIWI
   supports custom parttion only via LVM or filesystems with volume
   support like btrfs or zfs.
  </p><p>
   To define a LVM volume, a <code class="sgmltag-element">systemdisk</code> element
   within the <code class="sgmltag-element">type</code> element in the <code class="filename">config.xml</code> file must be defined.
   The <code class="sgmltag-element">systemdisk</code> element has an optional
   attribute <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm140065369871648"></a>, which specifies
   the volume group name.
  </p><p>
   For additional non root or swap volumes
   The <code class="sgmltag-element">systemdisk</code> element can contain
   the child element <code class="sgmltag-element">volume</code>, with
   four possible attributes:
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">name</code><a class="indexterm" name="idm140065369867744"></a></span></dt><dd><p>
         A required attribute. The name of the volume.
         If mountpoint is not specified the name specifies
         a path which will be created by kiwi if it does not exist
         inside the root directory. However if the name contains the
         kiwi internal path field separator '<span class="emphasis"><em>_</em></span>',
         it's required to specify the path in an additional mountpoint
         attribute. KIWI also makes sure that the volumes are created
         in the correct order of the filesystem hierarchy. The special
         attribute <span class="emphasis"><em>@root</em></span> can be used to control the
         size of the root volume
        </p></dd><dt><span class="term"><code class="sgmltag-attribute">size</code><a class="indexterm" name="idm140065369863536"></a></span></dt><dd><p>
         An optional attribute. Absolute size of the volume. If the size value
         is too small to store all data kiwi will exit.
The value is used as MB by default but you can add "M" and/or "G" as postfix.
        </p></dd><dt><span class="term"><code class="sgmltag-attribute">freespace</code><a class="indexterm" name="idm140065369860512"></a></span></dt><dd><p>
         An optional attribute. Free space to be added to this volume. The value is
used as MB by default but you can add "M" and/or "G" as postfix.
        </p></dd><dt><span class="term"><code class="sgmltag-attribute">mountpoint</code><a class="indexterm" name="idm140065369857552"></a></span></dt><dd><p>
         An optional attribute. The mountpoint specifies a path which has to
         exist inside the root directory.
        </p></dd></dl></div><p>
   For example, the following example will create
   a logical volume named LVtmp with minimal size to
   just store what is in <code class="filename">/tmp</code><a class="indexterm" name="idm140065369854240"></a>
   of the image at build time. The volume is mounted to
   <code class="filename">/tmp</code><a class="indexterm" name="idm140065369852416"></a>:
  </p><pre class="screen">
  &lt;systemdisk name="vgroup-name"&gt;
      &lt;volume name="tmp"/&gt;
  &lt;/systemdisk&gt;
  </pre><p>
   To do the same but with 200 MB of size, use:
  </p><pre class="screen">
  &lt;systemdisk name="vgroup-name"&gt;
      &lt;volume name="tmp" size="200M"/&gt;
  &lt;/systemdisk&gt;
  </pre><p>
    To create the logical volume named
   'foo' &gt;with 200 MB of free space mounted as
   <code class="filename">/tmp</code><a class="indexterm" name="idm140065369848176"></a>, use:
  </p><pre class="screen">
  &lt;systemdisk name="vgroup-name"&gt;
      &lt;volume name="tmp" freespace="200M" mountpoint="tmp"/&gt;
  &lt;/systemdisk&gt;
  </pre><p>
   There are always the volumes LVRoot and LVSwap for the
   rootfs and the swap space. In order to influence LVRoot
   one can use "@root" as a name:
  </p><pre class="screen">
  &lt;systemdisk name="vgroup-name"&gt;
      &lt;volume name="@root" size="2M"/&gt;
  &lt;/systemdisk&gt;
  </pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chap.partitions.btrfs"></a>17.2. Custom Partitioning via Btrfs<span class="permalink"><a alt="Permalink" title="17.2. Custom Partitioning via Btrfs" href="#chap.partitions.btrfs">¶</a></span></h2></div></div></div><p>
   If Btrfs is used as a filesystem, the subvolume
   management is configured via the same
   <code class="sgmltag-element">systemdisk</code> element
   as in the case of LVM. Also the same rules as explained
   for lvm volumes applies to btrfs subvolumes with the
   following exceptions:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">There is no @root volume and no size setup</span></dt><dd><p>
        The btrfs filesystem is created with an initial size which can
        be specified by the <code class="sgmltag-element">size</code> element
        All subvolumes are part of the filesystem itself and managed by
        a namespace. The overall size is shared across the entire
        filesystem and the size of an entity can be controlled by
        a btrfs quota which is not applied by kiwi at the moment
        </p></dd></dl></div><p>
  </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.encryption"></a>Chapter 18. KIWI Encryption Support </h2></div></div></div><a class="indexterm" name="idm140065369838368"></a><a class="indexterm" name="idm140065369836976"></a><p>
   KIWI supports LUKS encrypted images. To setup cryptographic volume along with the given filesystem
   using the LUKS extension, add the parameter luks in the type element in your config.xml. The value
   of the parameter represents the password string used to be able to mount that filesystem while booting:
  </p><p>
   &lt;type ... luks="password"&gt;
  </p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appendix"></a>Appendix A. KIWI Man Pages</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwi">kiwi</a></span><span class="refpurpose"> — Creating Operating System Images</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.config.sh">kiwi::config.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.images.sh">kiwi::images.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwirc">kiwi::kiwirc</a></span><span class="refpurpose"> — Resource file for the Kiwi imaging system</span></dt></dl></div><p>The following pages will show you the man page of KIWI and the
    functions which can be used within <span class="command"><strong>config.sh</strong></span> and
      <span class="command"><strong>index.sh</strong></span>
  </p><div class="refentry"><a name="ref.kiwi.kiwi"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi</span></h2><p>kiwi — Creating Operating System Images</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -l  |   --list }</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -o  |   --clone }  <em class="replaceable"><code>image-path</code></em>  { -d }  <em class="replaceable"><code>destination</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -b  |   --build }  <em class="replaceable"><code>image-path</code></em>  { -d }  <em class="replaceable"><code>destination</code></em> </p></div></div><div class="refsect1"><a name="kiwi.image.basics"></a><h2>Basics</h2><p>
      KIWI is a complete imaging solution that is based on an image
      description. Such a description is represented by a directory
      which includes at least one <code class="filename">config.xml</code> file
      and may as well include other files like scripts or configuration
      data. The <code class="systemitem">kiwi-templates</code> package provides example descriptions
      based on a JeOS system. JeOS means <span class="emphasis"><em>Just enough Operating System</em></span>.
      KIWI provides image templates based on that axiom which means a
      JeOS is a small, text only based image including a predefined
      remote source setup to allow installation of missing software
      components at a later point in time. 
    </p><p>
      Detailed description of the kiwi image system
      exists in the system design document in <a class="ulink" href="file:///usr/share/doc/packages/kiwi/kiwi.pdf" target="_top">file:///usr/share/doc/packages/kiwi/kiwi.pdf</a>. KIWI
      always operates in two steps. The KIWI <code class="option">--build</code> option just
      combines both steps into one to make it easier to start with KIWI.
      The first step is the preparation step and if that step was successful,
      a creation step follows which is able to create different image output
      types. If you have started with an example and want to add you own
      changes it might be a good idea to clone of from this example. This
      can be done by simply copying the entire image description or you can
      let KIWI do that for you by using the <span class="command"><strong>kiwi</strong></span> <code class="option">--clone</code> command.
    </p><p>
      In the preparation step,
      you prepare a directory including the contents of your new
      filesystem based on one or more software package source(s)
      The creation step is based on the result of the
      preparation step and uses the contents of the new image root tree to
      create the output image. If the image type ISO was requested, the
      output image would be a file with the suffix <code class="filename">.iso</code><a class="indexterm" name="idm140065369794384"></a> representing a live system on
      CD or DVD. Other than that KIWI is able to create images for
      virtual and para-virtual (Xen) environments as well as for USB
      stick, PXE network clients and OEM customized Linux systems. 
    </p></div><div class="refsect1"><a name="kiwi.general"></a><h2>General Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">-h</code> | <code class="option">--help</code></span>]</span></dt><dd><p>
     Display help.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--version</code></span>]</span></dt><dd><p>
     Display the KIWI version.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--check-config <em class="replaceable"><code>path-to-the-configuration-file</code></em></code></span>]</span></dt><dd><p>
     Checks the XML configuration file.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--nocolor</code></span>]</span></dt><dd><p>
     Do not use colored output.
    </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.image.prepcreate"></a><h2>Image Preparation and Creation</h2><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -p  |   --prepare }  <em class="replaceable"><code>image-path</code></em> <br> { -r  |   --root }  <em class="replaceable"><code>image-root</code></em>  [--cache <em class="replaceable"><code>directory</code></em>]</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -c  |   --create }  <em class="replaceable"><code>image-root</code></em> <br> { -d  |   --destdir }  <em class="replaceable"><code>destination</code></em>  [--type <em class="replaceable"><code>image-type</code></em>]</p></div></div><div class="refsect1"><a name="kiwi.image.upgrade"></a><h2>Image Upgrade</h2><p>
      If the image root tree is stored and not removed, it can be
      used for upgrading the image according to the changes
      made in the repositories used for this image. If a distributor
      provides an update channel for package updates and an image
        <code class="filename">config.xml</code> includes this update channel as
      repository, it is useful to store the image root tree and upgrade
      the tree according to changes on the update channel. Given that the
      root tree exists it's also possible to add or remove software
      and recreate the image of the desired type.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -u  |   --upgrade }  <em class="replaceable"><code>image-root</code></em>  [--add-package <em class="replaceable"><code>name</code></em>] [--add-pattern <em class="replaceable"><code>name</code></em>]</p></div></div><div class="refsect1"><a name="kiwi.image.system2image"></a><h2>System Analysis</h2><p>
      KIWI provides a module which allows you to analyse
      the running system and create a report and an image description
      representing the current state of the machine. Among others this allows
      you to clone your currently running system into an image.
      The system requires the zypper backend in order to work properly.
    </p><p>
      The process will always place it's result into the
      <code class="filename">/tmp/$OptionValueOf--describe</code> directory. The reason for
      this is because
      <code class="filename">/tmp</code><a class="indexterm" name="idm140065369750048"></a> is always excluded from
      the analysis and therefore
      we can safely place new files there without influencing the
      process itself. You should have at least 100 MB free space for
      the cache file and the image description all the rest are just
      hard links.
    </p><p>
      As one result a HTML based report file is created which
      contains important information about the system. You are free to
      ignore that information but with the risk that the image from
      that description
      does not represent the same system which is running at the moment. 
      The less issues left in the report the better is the result.
      In most cases a manual fine tuning is required. This includes
      the repository selection and the unmanaged files along with the
      configuration details of your currently running operating system.
      You should understand the module as a helper to analyse running
      linux systems.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { --describe }  <em class="replaceable"><code>name</code></em> </p></div></div><div class="refsect1"><a name="kiwi.image.postproc"></a><h2>Image Postprocessing Modes</h2><p>
      The KIWI post-processing modes are used for special image deployment
      tasks, like installing the image on a USB stick. So to say they are the
      third step after preparation and creation. KIWI calls the postprocessing
      modules automatically according to the specified output image type and
      attributes but it's also possible to call them manually.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootvm <em class="replaceable"><code>initrd</code></em>   --bootvm-system <em class="replaceable"><code>systemImage</code></em>  [--bootvm-disksize <em class="replaceable"><code>size</code></em>]</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootcd <em class="replaceable"><code>initrd</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootusb <em class="replaceable"><code>initrd</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installcd <em class="replaceable"><code>initrd</code></em>   --installcd-system <em class="replaceable"><code>raw-system-image</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installstick <em class="replaceable"><code>initrd</code></em>   --installstick-system <em class="replaceable"><code>raw-system-image</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installpxe <em class="replaceable"><code>initrd</code></em>   --installpxe-system <em class="replaceable"><code>raw-system-image</code></em> </p></div></div><div class="refsect1"><a name="idm140065369722448"></a><h2>Image Format Conversion</h2><p>
      The KIWI format conversion is useful to perform the creation of
    another image output format like vmdk for VMware or ovf the open
      virtual machine format. Along with the conversion KIWI also creates
      the virtual machine configuration according to the format if
      there is a machine section specified in the XML description
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --convert <em class="replaceable"><code>systemImage</code></em>  [--format <em class="replaceable"><code>vmdk|ovf|qcow2|vhd</code></em>]</p></div></div><div class="refsect1"><a name="idm140065369717568"></a><h2>Helper Tools</h2><p>
      The helper tools provide optional functions like
      creating a crypted password string for the users section of the
      <code class="filename">config.xml</code> file as well as signing the image
      description with an md5sum hash and adding splash data to
      the boot image used by the bootloader.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --createpassword </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --createhash
      <em class="replaceable"><code>image-path</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -i  |   --info }  <em class="replaceable"><code>ImagePath</code></em>  {--select
      <em class="replaceable"><code>
    repo-patterns|patterns|types|sources|size|profiles|packages|version
    </code></em>}</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --setup-splash <em class="replaceable"><code>initrd</code></em> </p></div><p>
  The following list describes the helper tools more detailed
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">--createpassword</code></span>]</span></dt><dd><p>
      Create a crypted password hash and prints it on the console.
      The user can use the string as value for the pwd attribute in
      the XML users section
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--createhash <em class="replaceable"><code>image-path</code></em></code>
    </span>]</span></dt><dd><p>
      Sign your image description with a md5sum. The result is written to a file
      named <code class="filename">.checksum.md</code> and is checked if KIWI creates
      an image from this description.
    </p></dd><dt><span class="term">[<span class="optional">
      <code class="option">-i</code> | <code class="option">--info <em class="replaceable"><code>image-path</code></em></code>
      <code class="option">--select <em class="replaceable"><code>selection</code></em></code>
    </span>]</span></dt><dd><p>
      List general information about the image description. So far you can get
      information about the available patterns in the configured repositories with
      <em class="replaceable"><code>repo-patterns</code></em>, a list of used patterns for this image
      with <em class="replaceable"><code>patterns</code></em>, a list of supported image types
      with <em class="replaceable"><code>types</code></em>, a list of source URLs with
      <em class="replaceable"><code>sources</code></em>, an estimation about the install size and
      the size of the packages marked as to be deleted with <em class="replaceable"><code>size</code></em>,
      a list of profiles with <em class="replaceable"><code>profiles</code></em>, 
            a list of solved packages to become installed with <em class="replaceable"><code>packages</code></em>,
      and the information about the appliance name and version with <em class="replaceable"><code>version</code></em>
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--setup-splash <em class="replaceable"><code>initrd</code></em></code>
    </span>]</span></dt><dd><p>
      Create splash screen from the data inside the initrd
      and re-create the initrd with the splash screen attached
      to the initrd cpio archive. This enables the kernel
      to load the splash screen at boot time. If splashy is used
      only a link to the original initrd will be created
    </p></dd></dl></div></div><div class="refsect1"><a name="kiwi..global.options"></a><h2>Global Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">--add-profile</code>
      <em class="replaceable"><code>profile-name</code></em></span>]</span></dt><dd><p>
      Use the specified profile. A profile is a part of the
      XML image description and therefore can enhance each section
      with additional information. For example adding packages.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repo</code>
      <em class="replaceable"><code>URL</code></em></span>]</span></dt><dd><p>
      Set/Overwrite the repo URL for the first repo listed in the
            configuration file that does not have a "fixed" status.
      The change is temporary and will not be written to the
      XML file.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repotype</code>
      <em class="replaceable"><code>type</code></em></span>]</span></dt><dd><p>
      Set/Overwrite repo type for the first listed repo.
      The supported repo types depends on the packagemanager.
      Commonly supported are rpm-md, rpm-dir and yast2.
      The change is temporary and will not be written to the
      XML file.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repoalias</code>
      <em class="replaceable"><code>name</code></em></span>]</span></dt><dd><p>
      Set/Overwrite alias name for the first listed repo.
      Alias names are optional free form text. If not set the source
      attribute value is used and builds the alias name by replacing
      each <span class="quote">“<span class="quote">/</span>”</span> with a <span class="quote">“<span class="quote">_</span>”</span>. An alias name should be set if the
      source argument doesn't really explain what this repository
      contains. The change is temporary and will not be written to the
      XML file.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repoprio</code>
      <em class="replaceable"><code>number</code></em></span>]</span></dt><dd><p>
      Set/Overwrite priority for the first listed repo.
      Works with the smart packagemanager only. The Channel
      priority assigned to all packages available in
      this channel (0 if not set). If the exact same package
      is available in more than one channel, the highest
      priority is used.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-repo
      <em class="replaceable"><code>URL</code></em></code>,
      <code class="option">--add-repotype <em class="replaceable"><code>type</code></em></code>
      <code class="option">--add-repoalias <em class="replaceable"><code>name</code></em></code>
      <code class="option">--add-repoprio <em class="replaceable"><code>number</code></em></code>
    </span>]</span></dt><dd><p>
      Add the given repository and type for this run of an
      image prepare or upgrade process. Multiple
            <code class="option">--add-repo</code>/<code class="option">--add-repotype</code>
      options are possible. The change will not be written to the
      <code class="filename">config.xml</code> file</p></dd><dt><span class="term">[<span class="optional"><code class="option">--ignore-repos</code></span>]</span></dt><dd><p>
      Ignore all repositories specified so far, in XML or
      elsewhere. This option should be used in conjunction with
      subsequent calls to <code class="option">--add-repo</code> to specify
      repositories at the commandline that override previous
      specifications.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--logfile <em class="replaceable"><code>Filename</code></em></code>
      | <code class="option">terminal</code></span>]</span></dt><dd><p>
      Write to the log file
      <em class="replaceable"><code>Filename</code></em> instead of the terminal.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--gzip-cmd <em class="replaceable"><code>cmd</code></em></code></span>]</span></dt><dd><p>
      Specify an alternate command to run when compressing
      boot and system images. Command must accept
      <span class="command"><strong>gzip</strong></span> options.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--package-manager <em class="replaceable"><code>smart|zypper</code></em></code>
    </span>]</span></dt><dd><p>
      Set the package manager to use for this image. If set it
      will temporarily overwrite the value set in the xml
      description.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">-A</code> | <code class="option">--target-arch <em class="replaceable"><code>i586|x86_64|armv5tel|ppc</code></em></code>
    </span>]</span></dt><dd><p>
      Set a special target-architecture. This overrides the 
      used architecture for the image-packages in <code class="filename">zypp.conf</code>.
      When used with smart this option doesn't have any effect.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--disk-start-sector <em class="replaceable"><code>number</code></em></code></span>]</span></dt><dd><p>
      The start sector value for virtual disk based images.
      The default is 2048. For newer disks including SSD
      this is a reasonable default. In order to use the old
      style disk layout the value can be set to 32.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--disk-sector-size <em class="replaceable"><code>number</code></em></code></span>]</span></dt><dd><p>
      Overwrite the default 512 byte sector size value.
      This will influence the partition alignment.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--disk-alignment <em class="replaceable"><code>number</code></em></code></span>]</span></dt><dd><p>
      Align the start of each partition to the specified
      value. By default 4096 bytes are used.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--debug</code></span>]</span></dt><dd><p>
      Prints a stack trace in case of internal errors
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--verbose <em class="replaceable"><code>1|2|3</code></em></code>
    </span>]</span></dt><dd><p>
      Controls the verbosity level for the instsource module
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">-y</code> | <code class="option">--yes</code>
    </span>]</span></dt><dd><p>
      Answer any interactive questions with yes
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--create-instsource <em class="replaceable"><code>path-to-config.xml</code></em></code> 
    </span>]</span></dt><dd><p>
      Using this option, it is possible to create a valid installation
      repository from blank RPM file trees. The created tree can be used directly
      for the image creation process afterwards.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--bundle-build</code> 
    </span>]</span></dt><dd><p>
     This option bundles the build results to be suitable for
     publishing it in the buildservice. It allows adding a build-number
     in combination with the <code class="option">--bundle-id</code> option
     as well as a SHA key to the results. It also removes intermediate
     build results not relevant for users if they don't want to rebuild
     the image.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--bundle-id <em class="replaceable"><code>build-number</code></em></code> 
    </span>]</span></dt><dd><p>
      The build-number/string in combination with <code class="option">--bundle-build</code>
    </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.prepare.options"></a><h2>Image Preparation Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">-r</code> | <code class="option">--root
      <em class="replaceable"><code>RootPath</code></em></code></span>]</span></dt><dd><p>
      Set up the physical extend, chroot system below the given
      root-path path. If no <code class="option">--root</code> option is
      given, KIWI will search for the attribute defaultroot in
      <code class="filename">config.xml</code>. If no root directory is
      known, a <span class="command"><strong>mktemp</strong></span> directory will be created
      and used as root directory.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--force-new-root</code></span>]</span></dt><dd><p>
      Force creation of new root directory. If the directory
      already exists, it is deleted.
    </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.prepare.upgrade.options"></a><h2>Image Upgrade/Preparation Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">--cache</code> <em class="replaceable"><code>directory</code></em>
        </span>]</span></dt><dd><p>
            When specifying a cache directory, KIWI will create a cache each for
           patterns and packages and re-use them, if possible, for subsequent
            root tree preparations of this and/or other images 
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--init-cache</code> <em class="replaceable"><code>image description</code></em>
        </span>]</span></dt><dd><p>
          Creates a cache from a KIWI image description.
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--recycle-root</code></span>]</span></dt><dd><p>
         Uses an existing root tree and base the kiwi prepare step on
         top of it. This is used to speed things up. 
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--force-bootstrap</code></span>]</span></dt><dd><p>
          In combination with recycle-root this option forces to call
          the bootstrap phase of kiwi, which is not considered necessary
          under normal circumstations.
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-package</code> <em class="replaceable"><code>package</code></em>
    </span>]</span></dt><dd><p>
      Add the given package name to the list of image packages
      multiple <code class="option">--add-package</code> options are possible. The change
      will not be written to the XML description.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-pattern</code> <em class="replaceable"><code>name</code></em>
        </span>]</span></dt><dd><p>
            Add the given pattern name to the list of image packages
            multiple <code class="option">--add-pattern</code> options are possible. The change
            will not be written to the xml description. Patterns can be handled
            by SUSE based repositories only.
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--del-package</code> <em class="replaceable"><code>package</code></em>
    </span>]</span></dt><dd><p>
      Removes the given package by adding it the list of packages
      to become removed. The change will not be written to the xml
      description.
    </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.create.options"></a><h2>Image Creation Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">-d</code> | <code class="option">--destdir
      <em class="replaceable"><code>DestinationPath</code></em></code></span>]</span></dt><dd><p>
      Specify destination directory to store the image file(s)
      If not specified, KIWI will try to find the attribute 
      <em class="replaceable"><code>defaultdestination</code></em> which can be
      specified in the <em class="replaceable"><code>preferences</code></em> section
      of the <code class="filename">config.xml</code> file. If it exists its value is used as
      destination directory. If no destination information can be found,
      an error occurs.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">-t</code> | <code class="option">--type
      <em class="replaceable"><code>Imagetype</code></em></code></span>]</span></dt><dd><p>
      Specify the output image type to use for this image. Each type
            is described in a <em class="replaceable"><code>type</code></em> section of the
            preferences section. At least one type has to be specified in the
            <code class="filename">config.xml</code> description. By default,
            the types specifying the <span class="emphasis"><em>primary</em></span> attribute will be
            used. If there is no primary attribute set, the first type
            section of the preferences section is the primary type.
            The types are only evaluated when KIWI runs the
            <code class="option">--create</code> step. With the
            option <code class="option">--type</code> one can distinguish between the
            types stored in <code class="filename">config.xml</code>
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">-s</code> | <code class="option">--strip</code></span>]</span></dt><dd><p>
      Strip shared objects and executables - only makes sense in
      combination with <code class="option">--create</code>
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--prebuiltbootimage
      <em class="replaceable"><code>Directory</code></em></code></span>]</span></dt><dd><p>
      Search in <em class="replaceable"><code>Directory</code></em> for
      pre-built boot images.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--isocheck</code></span>]</span></dt><dd><p>
      in case of an iso image the checkmedia program generates
      a md5sum into the ISO header. If the <code class="option">--isocheck</code> option is
      specified a new boot menu entry will be generated which
      allows to check this media
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--lvm</code></span>]</span></dt><dd><p>
      Use the logical volume manager to control the disk.
      The partition table will include one lvm partition and
      one standard ext2 boot partition. Use of this option
      makes sense for the create step only and also only for
      the image types: vmx, oem, and usb
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-blocksize <em class="replaceable"><code>number</code></em></code>
    </span>]</span></dt><dd><p>
      When calling KIWI in creation mode this option will set
      the block size in bytes. For ISO images with the old style
      ramdisk setup a blocksize of 4096 bytes is required
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-journalsize <em class="replaceable"><code>number</code></em></code>
    </span>]</span></dt><dd><p>
      When calling KIWI in creation mode this option will set
      the journal size in mega bytes for ext[23] based filesystems
      and in blocks if the reiser filesystem is used
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-inodesize <em class="replaceable"><code>number</code></em></code>
    </span>]</span></dt><dd><p>
      When calling KIWI in creation mode this option will set
      the inode size in bytes. This option has no effect if the
      reiser filesystem is used
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-inoderatio <em class="replaceable"><code>number</code></em></code>
        </span>]</span></dt><dd><p>
            Set the bytes/inode ratio. This option has no
            effect if the reiser filesystem is used
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-max-mount-count <em class="replaceable"><code>number</code></em></code>
    </span>]</span></dt><dd><p>
      When calling kiwi in creation mode this option will set the number
      of mounts after which the filesystem will be checked. Set to 0 to
      disable checks. This option applies only to ext[234] filesystems.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-check-interval <em class="replaceable"><code>number</code></em></code>
    </span>]</span></dt><dd><p>
      When calling kiwi in creation mode this option will set the maximal time
      between two filesystem checks. Set to 0 to disable time-dependent checks.
      This option applies only to ext[234] filesystems.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fat-storage <em class="replaceable"><code>size in MB</code></em></code>
    </span>]</span></dt><dd><p>
      if the syslinux bootlaoder is used this option allows to
      specify the size of the fat partition. This is useful if
      the fat space is not only used for booting the system but
      also for custom data. Therefore this option makes sense
      when building a USB stick image (image type: usb or oem)
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--partitioner <em class="replaceable"><code>parted|fdasd</code></em></code>
        </span>]</span></dt><dd><p>
      Select the tool to create partition tables. Supported are
      parted and fdasd (s390). By default parted is used
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--check-kernel</code></span>]</span></dt><dd><p>
      Activates check for matching kernels between boot and
      system image. The kernel check also tries to fix the boot
      image if no matching kernel was found.
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--mbrid <em class="replaceable"><code>number</code></em></code></span>]</span></dt><dd><p>
      Specifies a custom mbrid. The number value is treated as
      decimal number which is internally translated into a 4byte
      hex value. The allowed range therefore is from 0x0 to
      max 0xffffffff. By default kiwi creates a random value
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--edit-bootconfig <em class="replaceable"><code>script</code></em></code></span>]</span></dt><dd><p>
      Specifies the location of a custom script which is called
      right before the bootloader is installed. This allows to modify
      the bootloader configuration file written by kiwi. The scripts
      working directory is the one which represents the image
      structure including the bootloader configuration files. Please
      have in mind that according to the image type, architecture
      and bootloader type the files/directory structure and also
      the name of the bootloader configuration files might be
      different.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--edit-bootinstall <em class="replaceable"><code>script</code></em></code></span>]</span></dt><dd><p>
      Specifies the location of a custom script which is called
      right after the bootloader is installed.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--archive-image</code></span>]</span></dt><dd><p>
      When calling kiwi <code class="option">--create</code> this option allows to pack
      the build result(s) into a tar archive.
    </p></dd><dt><span class="term">[<span class="optional"><code class="option">--targetdevice</code> <em class="replaceable"><code>device</code></em></span>]</span></dt><dd><p>
      Use an alternative device instead of the loop device.
    </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.moreinfo"></a><h2>For More Information</h2><p>More information about KIWI, its files can be found at:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="ulink" href="http://en.opensuse.org/Portal:KIWI" target="_top">http://en.opensuse.org/Portal:KIWI</a></span></dt><dd><p>KIWI wiki</p></dd><dt><span class="term"><code class="filename">config.xml</code></span></dt><dd><p>The configuration XML file that contains every
            aspect for the image creation.</p></dd><dt><span class="term"><a class="ulink" href="file:///usr/share/doc/packages/kiwi/kiwi.pdf" target="_top">file:///usr/share/doc/packages/kiwi/kiwi.pdf</a></span></dt><dd><p>The system documentation which describes the supported image
            types in detail.</p></dd><dt><span class="term"><a class="ulink" href="file:///usr/share/doc/packages/kiwi/schema/kiwi.xsd.html" target="_top">file:///usr/share/doc/packages/kiwi/schema/kiwi.xsd.html</a></span></dt><dd><p>The KIWI RELAX NG XML Schema documentation.
          </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="ref.kiwi.config.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::config.sh</span></h2><p>KIWI::config.sh — Customization File for KIWI image description</p></div><div class="refsect1"><a name="kiwi.config.description"></a><h2>Description</h2><p>
      The KIWI image description allows to have an optional
      <code class="filename">config.sh</code> bash script in place. It can be
      used for changes appropriate for all images to be created from a
      given unpacked image (since config.sh runs prior to create step)

      Basically the script should be designed to take over control of adding
      the image operating system configuration. Configuration in that sense
      means all tasks which runs once in an os installation process like
      activating services, creating configuration files, prepare
      an environment for a firstboot workflow, etc.

      The <code class="filename">config.sh</code> script is called
      <span class="emphasis"><em>after</em></span> the following kiwi built in configuration
      tasks: User/Groups, copy of overlay root tree and setup of autoyast
      
      If <code class="filename">config.sh</code> exits with an exit code != 0
      the kiwi process will exit with an error too.
    </p><div class="example"><a name="idm140065369529296"></a><p class="title"><b>Example A.1. Template for config.sh</b></p><div class="example-contents"><pre class="programlisting">
#======================================
# Functions...
#--------------------------------------
test -f /.kconfig &amp;&amp; . /.kconfig
test -f /.profile &amp;&amp; . /.profile

#======================================
# Greeting...
#--------------------------------------
echo "Configure image: [$kiwi_iname]..."

#======================================
# Mount system filesystems
#--------------------------------------
baseMount

#======================================
# Call configuration code/functions
#--------------------------------------
...

#======================================
# Umount kernel filesystems
#--------------------------------------
baseCleanMount

#======================================
# Exit safely
#--------------------------------------
exit 0</pre></div></div><br class="example-break"></div><div class="refsect1"><a name="kiwi.config.functions"></a><h2>Common functions</h2><p>
      The <code class="filename">.kconfig</code> file allows to make use of a common
      set of functions. Functions specific to SUSE Linux specific begin with 
      the name <span class="emphasis"><em>suse</em></span>. Functions applicable to all linux 
      systems starts with the name <span class="emphasis"><em>base</em></span>.
      The following list describes the functions available inside the 
      <code class="filename">config.sh</code> script.
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">baseCleanMount</span>]</span></dt><dd><p>
            Umount the system filesystems <code class="filename">/proc</code>, 
            <code class="filename">/dev/pts</code>, and
            <code class="filename">/sys</code>.
          </p></dd><dt><span class="term">[<span class="optional">baseDisableCtrlAltDel</span>]</span></dt><dd><p>
            Disable the <span class="keycap"><strong>Ctrl</strong></span>-<span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>Del</strong></span> key sequence setting in <code class="filename">/etc/inittab</code>
          </p></dd><dt><span class="term">[<span class="optional">baseGetPackagesForDeletion</span>]</span></dt><dd><p>
            Return the name(s) of packages which will be deleted
          </p></dd><dt><span class="term">[<span class="optional">baseGetProfilesUsed</span>]</span></dt><dd><p>
            Return the name(s) of profiles used to build this image
          </p></dd><dt><span class="term">[<span class="optional">baseSetRunlevel {value}</span>]</span></dt><dd><p>
             Set the default run level
          </p></dd><dt><span class="term">[<span class="optional">baseSetupBoot</span>]</span></dt><dd><p>
             Set up the linuxrc as init
          </p></dd><dt><span class="term">[<span class="optional">baseSetupBusyBox {-f}</span>]</span></dt><dd><p>
             activates busybox if installed for all links from
             the <code class="filename">busybox/busybox.links</code> file—you can 
             choose custom apps to be forced into busybox with the 
            <code class="option">-f</code> option as first parameter, for example: 
          </p><pre class="screen">baseSetupBusyBox -f /bin/zcat /bin/vi</pre></dd><dt><span class="term">[<span class="optional">baseSetupInPlaceGITRepository</span>]</span></dt><dd><p>
            Create an in place git repository of the root
            directory. This process may take some time and you
            may expect problems with binary data handling
          </p></dd><dt><span class="term">[<span class="optional">baseSetupInPlaceSVNRepository {path_list}</span>]</span></dt><dd><p>
            Create an in place subversion repository for the
            specified directories. A standard call could look like this
            baseSetupInPlaceSVNRepository <code class="filename">/etc</code>,
            <code class="filename">/srv</code>, and <code class="filename">/var/log</code> 
          </p></dd><dt><span class="term">[<span class="optional">baseSetupPlainTextGITRepository</span>]</span></dt><dd><p>
            Create an in place git repository of the root
            directory containing all plain/text files.
          </p></dd><dt><span class="term">[<span class="optional">baseSetupUserPermissions</span>]</span></dt><dd><p>
            Search all home directories of all users listed in <code class="filename">/etc/passwd</code>
            and change the ownership of all files to belong to the correct
            user and group.
          </p></dd><dt><span class="term">[<span class="optional">baseStripAndKeep {list of info-files to keep}</span>]</span></dt><dd><p>
              helper function for strip* functions
              read stdin lines of files to check for removing
              params: files which should be keep
          </p></dd><dt><span class="term">[<span class="optional">baseStripDocs {list of docu names to keep}</span>]</span></dt><dd><p>
             remove all documentation, except one given as parameter
          </p></dd><dt><span class="term">[<span class="optional">baseStripInfos {list of info-files to keep}</span>]</span></dt><dd><p>
             remove all info files, except one given as parameter
          </p></dd><dt><span class="term">[<span class="optional">baseStripLocales {list of locales}</span>]</span></dt><dd><p>
             remove all locales, except one given as parameter
          </p></dd><dt><span class="term">[<span class="optional">baseStripMans {list of manpages to keep}</span>]</span></dt><dd><p>
             remove all manual pages, except one given as parameter
             example: baseStripMans more less
          </p></dd><dt><span class="term">[<span class="optional">baseStripRPM</span>]</span></dt><dd><p>
             remove rpms defined in <code class="filename">config.xml</code> in the
             image type=delete section
          </p></dd><dt><span class="term">[<span class="optional">suseRemovePackagesMarkedForDeletion</span>]</span></dt><dd><p>
             remove rpms defined in <code class="filename">config.xml</code> in the
             image type=delete section. The difference compared to baseStripRPM
             is that the suse variant checks if the package is really installed
             prior to passing it to rpm to uninstall it. The suse rpm exits
             with an error exit code while there are other rpm version which
             just ignore if an uninstall request was set on a package which
             is not installed
          </p></dd><dt><span class="term">[<span class="optional">baseStripTools {list of toolpath} {list of tools}</span>]</span></dt><dd><p>
              helper function for suseStripInitrd function
              params: toolpath, tools
          </p></dd><dt><span class="term">[<span class="optional">baseStripUnusedLibs</span>]</span></dt><dd><p>
             remove libraries which are not directly linked
             against applications in the bin directories
          </p></dd><dt><span class="term">[<span class="optional">baseUpdateSysConfig {filename} {variable} {value}</span>]</span></dt><dd><p>
             update sysconfig variable contents
          </p></dd><dt><span class="term">[<span class="optional">Debug {message}</span>]</span></dt><dd><p>
            Helper function to print a message 
            if the variable <code class="varname">DEBUG</code> is set to 1
          </p></dd><dt><span class="term">[<span class="optional">Echo {echo commandline}</span>]</span></dt><dd><p>
            Helper function to print a message to the controlling terminal
          </p></dd><dt><span class="term">[<span class="optional">Rm {list of files}</span>]</span></dt><dd><p>
            Helper function to delete files and announce it to log
          </p></dd><dt><span class="term">[<span class="optional">Rpm {rpm commandline}</span>]</span></dt><dd><p>
            Helper function to the RPM function and announce it to log
          </p></dd><dt><span class="term">[<span class="optional">suseConfig</span>]</span></dt><dd><p>
            Setup keytable language, timezone and hwclock if specified in
            <code class="filename">config.xml</code> and call SuSEconfig afterwards
            SuSEconfig is only called on systems which still support it
          </p></dd><dt><span class="term">[<span class="optional">suseInsertService {servicename}</span>]</span></dt><dd><p>
            This function calls baseInsertService and exists only
            for compatibility reasons
          </p></dd><dt><span class="term">[<span class="optional">suseRemoveService {servicename}</span>]</span></dt><dd><p>
            This function calls baseRemoveService and exists only
            for compatibility reasons
          </p></dd><dt><span class="term">[<span class="optional">baseInsertService {servicename}</span>]</span></dt><dd><p>
            Activate the given service by using the chkconfig or systemctl
            program. Which init system is in use is auto detected
          </p></dd><dt><span class="term">[<span class="optional">baseRemoveService {servicename}</span>]</span></dt><dd><p>
            Deactive the given service by using the chkconfig or systemctl
            program. Which init system is in use is auto detected
          </p></dd><dt><span class="term">[<span class="optional">baseService {servicename} {on|off}</span>]</span></dt><dd><p>
            Activate/Deactivate a service by using the chkconfig or systemctl
            program. The function requires the service name and the value
            on or off as parameters. Which init system is in use is auto
            detected
          </p></dd><dt><span class="term">[<span class="optional">suseActivateDefaultServices</span>]</span></dt><dd><p>
            Activates the following sysVInit services to be on by
            default using the chkconfig program: boot.rootfsck,
            boot.cleanup, boot.localfs, boot.localnet, boot.clock,
            policykitd, dbus, consolekit, haldaemon, network,
            atd, syslog, cron, kbd. And the following for
            systemd systems: network, cron
          </p></dd><dt><span class="term">[<span class="optional">suseSetupProduct</span>]</span></dt><dd><p>
            This function creates the baseproduct link in /etc/products.d
            pointing to the installed product
          </p></dd><dt><span class="term">[<span class="optional">suseSetupProductInformation</span>]</span></dt><dd><p>
            This function will use zypper to search for the installed
            product and install all product specific packages. This function
            only makes sense if zypper is used as packagemanager
          </p></dd><dt><span class="term">[<span class="optional">suseStripPackager {-a}</span>]</span></dt><dd><p>
             Remove smart or zypper packages and db files
             Also remove rpm package and db if <code class="option">-a</code> given
          </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.config.environment"></a><h2>Profile environment variables</h2><p>
      The .profile environment file contains a specific set of variables which
      are listed below. Some of the functions above makes use of the variables.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">$kiwi_compressed</span>]</span></dt><dd><p>
      The value of the compressed attribute set in the type element
      in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_delete</span>]</span></dt><dd><p>
            A list of all packages which are part of the packages section
            with <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065369439872"></a>="<code class="sgmltag-attvalue">delete</code>" in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_drivers</span>]</span></dt><dd><p>
            A comma separated list of the driver entries as listed in the
            drivers section of the <code class="filename">config.xml</code>.
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_iname</span>]</span></dt><dd><p>
            The name of the image as listed in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_iversion</span>]</span></dt><dd><p>
            The image version string major.minor.release
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_keytable</span>]</span></dt><dd><p>
            The contents of the keytable setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_language</span>]</span></dt><dd><p>
            The contents of the locale setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_profiles</span>]</span></dt><dd><p>
            A list of profiles used to build this image
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_size</span>]</span></dt><dd><p>
            The predefined size value for this image. This is not the computed
            size but only the optional size value of the preferences section
            in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_timezone</span>]</span></dt><dd><p>
            The contents of the timezone setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_type</span>]</span></dt><dd><p>
            The basic image type. Can be a simply filesystem image type of
            ext2, ext3, reiserfs, squashfs, cpio, or one of the following complex
            image types: iso, split, usb, vmx, oem, xen, or pxe.
          </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="ref.kiwi.images.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::images.sh</span></h2><p>KIWI::images.sh — Customization File for KIWI image description</p></div><div class="refsect1"><a name="kiwi.images.description"></a><h2>Description</h2><p>
      The KIWI image description allows to have an optional
      <code class="filename">images.sh</code> bash script in place. It can be
      used for changes appropriate for certain images/image types on
      case-by-case basis (since it runs at beginning of create step)

      Basically the script should be designed to take over control of
      handling image type specific tasks. For example if building the
      oem type requires some additional package or config it can be
      handled in images.sh. Please keep in mind there is only one
      unpacked root tree the script operates in. This means all
      changes are permanent and will not be automatically restored.
      It is also the script authors tasks to check if changes done
      before do not interfere in a negative way if another image type
      is created from the same unpacked image root tree

      If <code class="filename">images.sh</code> exitswith an exit code != 0
      the kiwi process will exit with an error too.
    </p><div class="example"><a name="idm140065369404144"></a><p class="title"><b>Example A.2. Template for images.sh</b></p><div class="example-contents"><pre class="programlisting">#======================================
# Functions...
#--------------------------------------
test -f /.kconfig &amp;&amp; . /.kconfig
test -f /.profile &amp;&amp; . /.profile

#======================================
# Greeting...
#--------------------------------------
echo "Configure image: [$kiwi_iname]..."

#======================================
# Call configuration code/functions
#--------------------------------------
...

#======================================
# Exit safely
#--------------------------------------
exit</pre></div></div><br class="example-break"></div><div class="refsect1"><a name="kiwi.image.functions"></a><h2>Common functions</h2><p>
     The <code class="filename">.kconfig</code> file allows to make use of a common
      set of functions. Functions specific to SUSE Linux specific begin with 
      the name <span class="emphasis"><em>suse</em></span>. Functions applicable to all linux 
      systems starts with the name <span class="emphasis"><em>base</em></span>.
      The following list describes the functions available inside the
      <code class="filename">images.sh</code> script.
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">baseCleanMount</span>]</span></dt><dd><p>
            Umount the system filesystems <code class="filename">/proc</code>, 
            <code class="filename">/dev/pts</code>, and
            <code class="filename">/sys</code>.
          </p></dd><dt><span class="term">[<span class="optional">baseGetProfilesUsed</span>]</span></dt><dd><p>
            Return the name(s) of profiles used to build this image.
          </p></dd><dt><span class="term">[<span class="optional">baseGetPackagesForDeletion</span>]</span></dt><dd><p>
            Return the list of packages setup in the packages <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065369390384"></a>="<code class="sgmltag-attvalue">delete</code>"
            section of the <code class="filename">config.xml</code> used to build
            this image.
          </p></dd><dt><span class="term">[<span class="optional">suseGFXBoot {theme} {loadertype}</span>]</span></dt><dd><p>
            This function requires the gfxboot and at least one bootsplash-theme-*
            package to be installed in order to work correctly. The function
            creates from this package data a graphics boot screen for the isolinux
            and grub boot loaders. Additionally it creates the bootsplash files
            for the resolutions 800x600, 1024x768, and 1280x1024
          </p></dd><dt><span class="term">[<span class="optional">suseStripKernel</span>]</span></dt><dd><p>
            This function removes all kernel drivers which are not listed in
            the *drivers sections of the <code class="filename">config.xml</code>
            file.
          </p></dd><dt><span class="term">[<span class="optional">suseStripInitrd</span>]</span></dt><dd><p>
            This function removes a whole bunch of tools binaries and libraries which
            are not required in order to boot a suse system with KIWI.
          </p></dd><dt><span class="term">[<span class="optional">Rm {list of files}</span>]</span></dt><dd><p>
            Helper function to delete files and announce it to log.
          </p></dd><dt><span class="term">[<span class="optional">Rpm {rpm commandline}</span>]</span></dt><dd><p>
            Helper function to the rpm function and announce it to log.
          </p></dd><dt><span class="term">[<span class="optional">Echo {echo commandline}</span>]</span></dt><dd><p>
            Helper function to print a message to the controlling
            terminal.
          </p></dd><dt><span class="term">[<span class="optional">Debug {message}</span>]</span></dt><dd><p>
            Helper function to print a message 
            if the variable <code class="varname">DEBUG</code> is set to 1.
          </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.images.environment"></a><h2>Profile environment variables</h2><p>
      The .profile environment file contains a specific set of variables which
      are listed below. Some of the functions above makes use of the variables.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">$kiwi_iname</span>]</span></dt><dd><p>
            The name of the image as listed in config.xml
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_iversion</span>]</span></dt><dd><p>
            The image version string major.minor.release
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_keytable</span>]</span></dt><dd><p>
            The contents of the keytable setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_language</span>]</span></dt><dd><p>
            The contents of the locale setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_timezone</span>]</span></dt><dd><p>
            The contents of the timezone setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_delete</span>]</span></dt><dd><p>
            A list of all packages which are part of the packages section
            with <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm140065369359520"></a>="<code class="sgmltag-attvalue">delete</code>" in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_profiles</span>]</span></dt><dd><p>
            A list of profiles used to build this image
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_drivers</span>]</span></dt><dd><p>
            A comma separated list of the driver entries as listed in the
            drivers section of the <code class="filename">config.xml</code>. 
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_size</span>]</span></dt><dd><p>
            The predefined size value for this image. This is not the computed
            size but only the optional size value of the preferences section
            in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_compressed</span>]</span></dt><dd><p>
      The value of the compressed attribute set in the type element 
      in config.xml
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_type</span>]</span></dt><dd><p>
            The basic image type. Can be a simply filesystem image type of
            ext2, ext3, reiserfs, squashfs, and cpio or one of the following complex
            image types: iso split usb vmx oem xen pxe
          </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="ref.kiwi.kiwirc"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::kiwirc</span></h2><p>KIWI::kiwirc — Resource file for the Kiwi imaging system</p></div><div class="refsect1"><a name="kiwi.kiwirc.description"></a><h2>Description</h2><p>
      The KIWI imaging toolchain supports the use of an optional resource
      file named <code class="filename">.kiwirc</code> located in the users home directory.
    </p><p>
      The file is sourced by a Perl process and thus Perl compatible syntax
      for the supported variable settings is required.
    </p><div class="example"><a name="idm140065369334112"></a><p class="title"><b>Example A.3. Template for .kiwi.rc</b></p><div class="example-contents"><pre class="screen">$BasePath='/usr/share/kiwi';
$Gzip='bzip2';
$LogServerPort='4455';
$System='/usr/share/kiwi/image';</pre></div></div><br class="example-break"></div><div class="refsect1"><a name="kiwi.kiwirc.settings"></a><h2>Supported Resource Settings</h2><p>
      KIWI recognizes the BasePath, Gzip, LogServerPort, LuksCipher, and 
      System settings in the <code class="filename">.kiwirc</code> file.
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">BasePath</span>]</span></dt><dd><p>
            Path to the location of the KIWI image system components, such as
            modules, tests, image descriptions etc.
          </p><p>
            The default value is <code class="filename">/usr/share/kiwi</code>
          </p></dd><dt><span class="term">[<span class="optional">Gzip</span>]</span></dt><dd><p>
            Specify the compression utility to be used for various compression
            tasks during image generation.
          </p><p>
            The default value is <span class="command"><strong>gzip</strong></span> <code class="option">-9</code>
          </p></dd><dt><span class="term">[<span class="optional">LogServerPort</span>]</span></dt><dd><p>
            Specify a port number for log message queuing.
          </p><p>
            The default value is off
          </p></dd><dt><span class="term">[<span class="optional">LuksCipher</span>]</span></dt><dd><p>
            Specify the cipher for the encrypted Luks filesystem.
          </p></dd><dt><span class="term">[<span class="optional">System</span>]</span></dt><dd><p>
            Specify the location of the KIWI system image description.
          </p><p>
            The default value is the value of BasePath concatenated with
            /image.
          </p></dd></dl></div></div></div></div></div></body></html>
