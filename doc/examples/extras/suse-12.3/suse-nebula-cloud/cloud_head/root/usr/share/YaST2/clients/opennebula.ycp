/**
 * File:        clients/opennebula.ycp
 * Package:     Configuration of OpenNebula CLoud head node
 * Authors:     Jiri Suchomel <jsuchome@suse.cz>
 *              Robert Scwheikert <rjschwei@suse.com>
 *
 * License:     GPL v2
 *
 */

{
    textdomain "susenebula";
 
    import "FileUtils";
    import "Hostname";
    import "IP";
    import "Label";
    import "Mode";
    import "Netmask";
    import "Popup";
    import "Report";
    import "Service";
    import "Wizard";
 
    import "YaPI::NETWORK";
 
    string hostname = "SUSENebula-Head";
    string domain   = "";
    string ip       = "192.168.1.2";
    string netmask  = "255.255.255.0";
    string ip_min   = "";
    string ip_max   = "";
    string clustername  = "SUSENebula";
    string route    = "";
    string cadminp  = "susenebula";
    list<string> nameservers  = [];
    list<string> searchdomains    = [];
 
    // network export map
    map network     = $[];
    // dhcp server export map
    map dhcp        = $[];
 
    // write entered settings to the system
    boolean WriteSettings () {
 
    // 1. Write Network
    map<string,any> write_network = $[
        "hostname"  : network["hostname"]:$[],
        "dns"   : network["dns"]:$[],
    ];
 
    write_network["hostname","domain"]  = domain;
    write_network["hostname","name"]    = hostname;
 
    write_network["dns","nameservers"]  = nameservers;
    write_network["dns","searches"]     = searchdomains;
 
    write_network["route"]  = $[
        "default"   : $[
        "via"   : route
        ]
    ];
 
    map interface   = network["interfaces"]:$[];
 
    // ip r|grep default|cut -d' ' -f5
    if (haskey (interface, "eth0"))
    {
        interface["eth0","bootproto"]   = "static";
        interface["eth0","ipaddr"]  = sformat ("%1/%2", ip, Netmask::ToBits (netmask));
        write_network["interface"]  = interface;
    }
    y2internal ("network to write: %1", write_network);
    map network_written = YaPI::NETWORK::Write (write_network);
 
    Service::Restart ("network");
 
    // 2. Write DHCP server DhcpServer: settings/directives/range
    // Min/Max IP -> set the IP address range for dhcp server.
 
    // Read DhcpServer after network is configured
    /*
    DhcpServer::Read ();
    dhcp    = DhcpServer::Export ();
    y2internal ("dhcp: %1", dhcp);
    */
 
    string subnet_ip    = IP::ComputeNetwork (ip, netmask);
 
    dhcp["allowed_interfaces"]  = ["eth0"];
    dhcp["start_service"]       = true;
    dhcp["use_ldap"]        = false;
    dhcp["settings"]        = [
      $[
        "children"      : [],
        "directives"    : [
        $[
            "key"       : "default-lease-time",
            "type"      : "directive",
            "value"     : "14400"
        ],
        $[
            "key"       : "max-lease-time",
            "type"      : "directive",
            "value"     : "172800"
        ],
        $[
             "key"      : "range",
            "type"      : "directive",
            "value"     : sformat ("%1 %2", ip_min, ip_max)
        ]
        ],
        "id"        : sformat ("%1 netmask %2", subnet_ip, netmask),
        "options"       : [],
        "parent_id"     : "",
        "parent_type"   : "",
        "type"      : "subnet"
      ],
      $[
        "children"      : [
        $[
            "id"    : sformat ("%1 netmask %2", subnet_ip, netmask),
            "type"  : "subnet"
        ]
        ],
        "directives"    : [
        $[
            "key"   : "max-lease-time",
            "type"  : "directive",
            "value" : "7200"
        ],
        $[
            "key"   : "ddns-updates",
            "type"  : "directive",
            "value" : "off"
        ],
        $[
            "key"   : "ddns-update-style",
            "type"  : "directive",
            "value" : "none"
        ],
        $[
            "key"   : "log-facility",
            "type"  : "directive",
            "value" : "local7"
        ],
        $[
            "key"   : "default-lease-time",
            "type"  : "directive",
            "value" : "600"
        ],
        ],
        "options"   : [
        $[
            "key"   : "suse-nebula",
            "type"  : "option",
            "value" : "code 239 = ip-address"
        ],
        $[
            "key"   : "suse-nebula",
            "type"  : "option",
            "value" : ip
        ],
        $[
            "key"   : "domain-name",
            "type"  : "option",
            "value" : sformat ("\"%1\"", domain),
        ],
        ],
        "id"    :"",
        "parent_id"     : "",
        "parent_type"   : "",
        "type"      : ""
      ]
    ];
    /*
    y2internal ("importing dhcp settings: %1", dhcp);
    DhcpServer::Import (dhcp);
    DhcpServer::Write ();
    */
 
    string dhcpd_conf   = sformat (
"option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;
option domain-name \"%1\";
max-lease-time 7200;
# Custom option to identify this DHCP server as the cloud DHCP server
# Define the new option
option suse-nebula code 239 = ip-address;
# Set the value
option suse-nebula %2;
# Set the address range to be handed out.
subnet %3 netmask %4 {
    range %5 %6;
    default-lease-time 86400000;
    max-lease-time 1728000000000;
}", domain, ip, subnet_ip, netmask, ip_min, ip_max);
 
    SCR::Write (.target.string, "/etc/dhcpd.conf", dhcpd_conf);
 
    SCR::Write (.sysconfig.dhcpd.DHCPD_INTERFACE, "eth0");
    SCR::Write (.sysconfig.dhcpd, nil);
 
    Service::Enable ("dhcpd");
    Service::Start ("dhcpd");

    // 3. Write onedamin authentication file
    string oneauth = sformat ("oneadmin:%1", cadminp);
    SCR::Write (.target.string, "/var/lib/one/.one/one_auth", oneauth);
 
	return true;
    }
 
    // initialize network data
    boolean ReadNetworkSettings () {
    network = YaPI::NETWORK::Read ();
    y2internal ("network: %1", network);
    nameservers = network["dns","nameservers"]:[];
    searchdomains   = network["dns","searches"]:[];
    return true;
    }
 
    ReadNetworkSettings ();
 
    term contents = `HBox (`HSpacing (1), `VBox (
    `Frame (_("Network Configuration"), `VBox (
        // text entry label
        `InputField (`id ("clustername"), `opt (`hstretch), _("C&luster Name"), clustername),
        `HBox (
        // text entry label
        `InputField (`id ("hostname"), `opt (`hstretch), _("&Hostname"), hostname),
        // text entry label
        `InputField (`id ("domain"), `opt (`hstretch), _("&Domain Name"), domain)
        ),
        `HBox (
        // text entry label
        `InputField (`id ("ip"), `opt (`hstretch), _("&IP Address"), ip),
        // text entry label
        `InputField (`id ("netmask"), `opt (`hstretch), _("&Netmask"), netmask)
        ),
        // text entry label
        `InputField (`id ("route"), `opt (`hstretch), _("Default Route"), route),
        `HBox (
        // text entry label
        `InputField (`id ("nameservers"), `opt (`hstretch), _("Name Servers"), mergestring (nameservers, " ")),
        // text entry label
        `InputField (`id ("searches"), `opt (`hstretch), _("Search Domains"), mergestring (searchdomains, " "))
        )
    )),
    `VSpacing (2),
    // frame label
    `Frame (_("IP Address Range for Cloud Nodes"), `HBox (
        // text entry label
        `InputField (`id ("ip_min"), `opt (`hstretch), _("Min IP Address"), ip_min),
        // text entry label
        `InputField (`id ("ip_max"), `opt (`hstretch), _("Max IP Address"), ip_max)
    )),
    `VSpacing (2),
    // frame label
    `Frame (_("Cloud Administrator"), `VBox (
        // text entry label
        `InputField (`id ("cadminp"), `opt (`hstretch), _("Password for Cloud Administration"), cadminp),
        `VSpacing (1),
        `Label ("The password is stored in plain text in the file /var/lib/one/.one/one_auth and is used for cloud administration only.
This is not the password for the cloud administrator (oneadmin) user account. The oneadmin account has no password.")
    ))
    ), `HSpacing (1));
 
    if (Mode::normal ())
    Wizard::OpenOKDialog ();
 
    string help_text    = "";
 
    // dialog caption
    Wizard::SetContents (_("SUSENebula"), contents, help_text, true, true);
 
    UI::ChangeWidget (`id ("hostname"), `ValidChars, Hostname::ValidChars);
    foreach (string key, ["ip", "ip_min", "ip_max"], {
    UI::ChangeWidget (`id (key), `ValidChars, IP::ValidChars4);
    });
    any ret = `back;
    while (true)
    {
    ret = UI::UserInput ();
    if (ret == `ok || ret == `next)
    {
        cadminp = (string) UI::QueryWidget (`id ("cadminp"), `Value);
        clustername = (string) UI::QueryWidget (`id ("clustername"), `Value);
        hostname    = (string) UI::QueryWidget (`id ("hostname"), `Value);
        domain  = (string) UI::QueryWidget (`id ("domain"), `Value);
        ip      = (string) UI::QueryWidget (`id ("ip"), `Value);
        ip_min  = (string) UI::QueryWidget (`id ("ip_min"), `Value);
        ip_max  = (string) UI::QueryWidget (`id ("ip_max"), `Value);
        netmask = (string) UI::QueryWidget (`id ("netmask"), `Value);
        route   = (string) UI::QueryWidget (`id ("route"), `Value);
        string dns  = (string) UI::QueryWidget (`id ("nameservers"), `Value);
        nameservers = splitstring (dns, ", ");
        string searches = (string) UI::QueryWidget (`id ("searches"), `Value);
        searchdomains = splitstring (searches, ", ");
 
        if (!Hostname::Check (hostname))
        {
        Report::Error (Hostname::ValidHost ());
        UI::SetFocus (`id ("hostname"));
        continue;
        }
        if (!Hostname::CheckDomain (domain))
        {
        Report::Error (Hostname::ValidDomain ());
        UI::SetFocus (`id ("domain"));
        continue;
        }
        if (!IP::Check (ip))
        {
        Report::Error (IP::Valid4 ());
        UI::SetFocus (`id ("ip"));
        continue;
        }
        if (!IP::Check (ip_min))
        {
        Report::Error (IP::Valid4 ());
        UI::SetFocus (`id ("ip_min"));
        continue;
        }
        if (!IP::Check (ip_max))
        {
        Report::Error (IP::Valid4 ());
        UI::SetFocus (`id ("ip_max"));
        continue;
        }
 
        if (IP::ToInteger (ip_min) <= IP::ToInteger (ip) &&
        IP::ToInteger (ip) <= IP::ToInteger (ip_max))
        {
        // error message
        Report::Error (_("IP Address is within the IP range that should be offered by DHCP server."));
        UI::SetFocus (`id ("ip_min"));
        continue;
        }
 
        if (IP::ToInteger (ip_min) > IP::ToInteger (ip_max))
        {
        // error message
        Popup::Message(_("The lowest address must be lower than the highest one."));
        UI::SetFocus (`id ("ip_min"));
        continue;
        }
 
 
        WriteSettings ();
        break;
    }
    if (ret == `cancel || ret == `abort)
    {
        break;
    }
    if (ret == `back)
    {
        break;
    }
    }
    if (Mode::normal ())
    Wizard::CloseDialog ();
    return ret;
}
